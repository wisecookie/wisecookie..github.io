<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-pair知识点" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/10/pair%E7%9F%A5%E8%AF%86%E7%82%B9/" class="article-date">
  <time class="dt-published" datetime="2023-01-10T03:30:29.000Z" itemprop="datePublished">2023-01-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/01/10/pair%E7%9F%A5%E8%AF%86%E7%82%B9/">pair知识点</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>C++ pair型<br>pair 是 一种模版类型。每个pair 可以存储两个值。</p>
<p>如果一个函数有两个返回值并且是不同类型，一种方法是写个struct ，但为了方便可以使用 c++ 自带的pair型 ，返回一个pair 。</p>
<p>另外，在一个对象有多个属性时 ，一般使用struct ，但是如果只有两个属性的时候，就可以用pair 进行操作。。。</p>
<p>如果有三个属性的话，其实也是可以用pair 。。。。</p>
<p> pair&lt;int ,pair&lt;int ,int &gt; &gt; a;<br>1<br>（后边的两个 &gt; &gt; 要有空格，否则就会是 &gt;&gt; 位移运算符）</p>
<p>生成方法有两种：</p>
<p>pair&lt;int ,int &gt;p (5,6);<br>pair&lt;int ,int &gt; p1&#x3D; make_pair(5,6);<br>1<br>2<br>对于取值，每个pair 都有两个属性值 first 和second</p>
<p> cout &lt;&lt; p1.first &lt;&lt; p1.second;<br>1<br>可以理解为struct的两个变量</p>
<p>对于排序函数sort ，pair自带属性为first优先进行升序排序，其次为second进行升序排序，代码举例：</p>
<p>#include<iostream><br>#include<cstdio><br>#include<cstring><br>#include<algorithm><br>#define mmm(a,b) memset(a,b,sizeof(a))<br>#define mk make_pair<br>#define fi first<br>#define se second<br>#define pill pair&lt;int, int&gt;<br>using namespace std; </p>
<p>int main()<br>{<br>    pill a[200];<br>    mmm(a,0);<br>    for(int i&#x3D;1;i&lt;&#x3D;10;i++){<br>        a[i]&#x3D;mk(20-i,i);<br>    }</p>
<pre><code>for(int i=1;i&lt;=10;i++)&#123;
    cout&lt;&lt;a[i].fi&lt;&lt;&#39; &#39;&lt;&lt;a[i].se&lt;&lt;endl;
&#125;cout&lt;&lt;endl;

sort(a+1,a+11);
for(int i=1;i&lt;=10;i++)&#123;
    cout&lt;&lt;a[i].fi&lt;&lt;&#39; &#39;&lt;&lt;a[i].se&lt;&lt;endl;
&#125;cout&lt;&lt;endl;

a[2].first=10;
sort(a+1,a+11);
cout&lt;&lt;&quot;11 9 change to 10 9&quot;&lt;&lt;endl&lt;&lt;endl;
for(int i=1;i&lt;=10;i++)&#123;
    cout&lt;&lt;a[i].fi&lt;&lt;&#39; &#39;&lt;&lt;a[i].se&lt;&lt;endl;
&#125;
</code></pre>
<p>}<br>————————————————<br>版权声明：本文为CSDN博主「JK Chen」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/jk_chen_acmer/article/details/79268165">https://blog.csdn.net/jk_chen_acmer/article/details/79268165</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/01/10/pair%E7%9F%A5%E8%AF%86%E7%82%B9/" data-id="clhle1vkg0006fgw1ar5f0z1x" data-title="pair知识点" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-堆的知识点" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/10/%E5%A0%86%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9/" class="article-date">
  <time class="dt-published" datetime="2023-01-10T03:26:22.000Z" itemprop="datePublished">2023-01-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/01/10/%E5%A0%86%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9/">堆的知识点</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>前言<br>最近在刷算法题的时候遇到了需要使用堆来解决的问题(尤其是TOP k 问题)，所以想把这些方法总结一下，防止后面忘记了还得到处找资料。希望能帮助到大家<br>参考链接1<br>参考链接2</p>
<p>堆(heap)的介绍<br>对通常是一个可以被看做一棵树的数组对象，满足两个条件：1，堆中的某个结点的值总是不大于或者不小于其父结点的值 2，堆是一颗完全二叉树<br>根结点最大的数叫做大根堆，最小的叫做小根堆。<br>堆排序中建堆的时间复杂度为O(n)<br>在C++ STL中没有堆的数据结构，所以借助其中的 priority_queue(默认是大根堆)</p>
<p>priority_queue<br>常用的方法如下：</p>
<p>priority_queue, 优先队列，默认是大根堆<br>    size()<br>    empty()<br>    push()  插入一个元素<br>    top()  返回堆顶元素<br>    pop()  弹出堆顶元素<br>    定义成小根堆的方式：priority_queue&lt;int, vector<int>, greater<int>&gt; q;<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>priority_queue使用<br>定义：priority_queue&lt;Type, Container, Functional&gt; ，priority_queue属于是容器适配器，需要指定底层的容器，所以第一个参数Type是queue里面存的数据的类型，第二个参数Container是要使用的底层容器(一般是vector)，Functional 就是比较的方式（准确来说应该是比较方式的类型）.<br>当数据是基本数据类型时可以使用默认的比较方式，使用如下：<br>&#x2F;&#x2F;升序队列<br>priority_queue &lt;int,vector<int>,greater<int> &gt; q;<br>&#x2F;&#x2F;降序队列<br>priority_queue &lt;int,vector<int>,less<int> &gt;q;<br>&#x2F;&#x2F;greater和less是std实现的两个仿函数（就是使一个类的使用看上去像一个函数。<br>&#x2F;&#x2F;其实现就是类中实现一个operator()，这个类就有了类似函数的行为，就是一个仿函数类了）<br>1<br>2<br>3<br>4<br>5<br>6<br>当使用自定的数据类型时，比较方式的写法<br>lambda函数（如果有不清楚的可以参考我的这篇文章：c++11新特性）<br>auto cmp &#x3D; [](pair&lt;int, int&gt; left, pair&lt;int, int&gt; right) -&gt; bool { return left.second &gt; right.second; };<br>priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, decltype(cmp)&gt;  pri_que(cmp);<br>1<br>2<br>仿函数实现(最常用)<br>class mycomparison {<br>public:<br>    bool operator()(const pair&lt;int, int&gt;&amp; left, const pair&lt;int, int&gt;&amp; right) {<br>        return left.second &gt; right.second;<br>    }<br>};<br>priority_queue&lt;pair&lt;int,int&gt;,vector&lt;pair&lt;int, int&gt;&gt;,mycomparison&gt; pri_que2;<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>在自定义类型的类或者结构体中，重载运算符</p>
<p>struct tmp1 &#x2F;&#x2F;运算符重载&lt;<br>{<br>    int x;<br>    tmp1(int a) {x &#x3D; a;}<br>    bool operator&lt;(const tmp1&amp; a) const<br>    {<br>        return x &lt; a.x; &#x2F;&#x2F;大顶堆<br>    }<br>}<br>priority_queue<tmp1> pri_que3;<br>————————————————</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_43964318/article/details/125879319">https://blog.csdn.net/qq_43964318/article/details/125879319</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/01/10/%E5%A0%86%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9/" data-id="clhle1vkp000mfgw13sgccju1" data-title="堆的知识点" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-week12" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/10/week12/" class="article-date">
  <time class="dt-published" datetime="2023-01-10T02:00:46.000Z" itemprop="datePublished">2023-01-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/01/10/week12/">week12</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="宝物筛选"><a href="#宝物筛选" class="headerlink" title="宝物筛选"></a>宝物筛选</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>终于，破解了千年的难题。小 FF 找到了王室的宝物室，里面堆满了无数价值连城的宝物。</p>
<p>这下小 FF 可发财了，嘎嘎。但是这里的宝物实在是太多了，小 FF 的采集车似乎装不下那么多宝物。看来小 FF 只能含泪舍弃其中的一部分宝物了。</p>
<p>小 FF 对洞穴里的宝物进行了整理，他发现每样宝物都有一件或者多件。他粗略估算了下每样宝物的价值，之后开始了宝物筛选工作：小 FF 有一个最大载重为 $W$ 的采集车，洞穴里总共有 $n$ 种宝物，每种宝物的价值为 $v_i$，重量为 $w_i$，每种宝物有 $m_i$ 件。小 FF 希望在采集车不超载的前提下，选择一些宝物装进采集车，使得它们的价值和最大。</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行为一个整数 $n$ 和 $W$，分别表示宝物种数和采集车的最大载重。</p>
<p>接下来 $n$ 行每行三个整数 $v_i,w_i,m_i$。</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出仅一个整数，表示在采集车不超载的情况下收集的宝物的最大价值。</p>
<h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4 20</span><br><span class="line">3 9 3</span><br><span class="line">5 9 1</span><br><span class="line">9 4 2</span><br><span class="line">8 1 3</span><br></pre></td></tr></table></figure>

<h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">47</span><br></pre></td></tr></table></figure>

<h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p>对于 $30%$ 的数据，$n\leq \sum m_i\leq 10^4$，$0\le W\leq 10^3$。</p>
<p>对于 $100%$ 的数据，$n\leq \sum m_i \leq 10^5$，$0\le W\leq 4\times 10^4$，$1\leq n\le 100$。<img src="https://cdn.luogu.com.cn/upload/pic/652.png"></p>
<h2 id="Analyse"><a href="#Analyse" class="headerlink" title="Analyse:"></a>Analyse:</h2><p>唯一的问题就是数量实在是太多了</p>
<p>直接写模板的话肯定会超时</p>
<p>那么就需要用到优化了</p>
<p>这里用到的是二进制优化</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h2><pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
int n,m,ans,cnt=1;
int f[1000005];
int w[1000005],v[1000005];//记得将数组开大
int main()
&#123;
    int a,b,c;
    cin&gt;&gt;n;
    cin&gt;&gt;m;
    
    for(int i=1;i&lt;=n;++i)
    &#123;
        cin&gt;&gt;a;
        cin&gt;&gt;b;
        cin&gt;&gt;c;
        for(int j=1;j&lt;=c;j&lt;&lt;=1)
        &#123;
            v[++cnt]=j*a,w[cnt]=j*b;
            c-=j;
        &#125;
        if(c) v[++cnt]=a*c,w[cnt]=b*c;
        
    &#125;
    
    for(int i=1;i&lt;=cnt;++i)
     for(int j=m;j&gt;=w[i];--j)
      f[j]=max(f[j],f[j-w[i]]+v[i]);
    //简单的多重背包 
    cout&lt;&lt;f[m];
    return 0;
&#125;
</code></pre>
<h1 id="尴尬的数字"><a href="#尴尬的数字" class="headerlink" title="尴尬的数字"></a>尴尬的数字</h1><h2 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h2><p>Bessie 刚刚学会了不同进制数之间的转换，但是她总是犯错误，因为她的两个前蹄不能轻松的握住钢笔。</p>
<h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>每当 Bessie 将一个数转换成新的进制时，她总会写错一位数字。例如，她将 14 转化成 2 进制数，正确的结果是 1110，但她可能会写成 0110 或 1111。Bessie 从不会意外的增加或删减数字，所以她可能会写出以 0 开头的错误数字。</p>
<p>给出 Bessie 转换后 $N$ 的 2 进制形式和 3 进制形式，请计算出 $N$ 的正确数值（用十进制表示）。$N$ 可能会达到 $10^9$，输入数据保证解的存在唯一性。</p>
<h2 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行，$N$ 的 2 进制表示（有一位是错误的数字）。</p>
<p>第二行，$N$ 的 3 进制表示（有一位是错误的数字）。</p>
<h2 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h2><p>$N$ 的正确值。</p>
<h2 id="样例-1-1"><a href="#样例-1-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-1"><a href="#样例输入-1-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1010</span><br><span class="line">212</span><br></pre></td></tr></table></figure>

<h3 id="样例输出-1-1"><a href="#样例输出-1-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">14</span><br></pre></td></tr></table></figure>

<h2 id="Analyse-1"><a href="#Analyse-1" class="headerlink" title="Analyse:"></a>Analyse:</h2><p>注意到本题n仅为10^9^，那位数就不会很多了 二进制大概30位，三进制会更少些 所以可以直接暴力搜索有问题的位。</p>
<h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code:"></a>Code:</h2><pre><code>#include&lt;iostream&gt;
#include&lt;cmath&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
int l1,l2;
long long sum1;
char s1[10000],s2[10000];
int n1[10000],n2[10000];
void dfs(long long num,int tot,int pos)&#123;
    if(tot==l2)&#123;
        if(sum1==num)&#123;
            cout&lt;&lt;sum1;
            exit(0);
        &#125;
        return ;
    &#125;
    if(pos)    dfs(num+n2[tot]*pow(3,tot),tot+1,pos);
    else&#123;
        if(n2[tot]!=0&amp;&amp;tot!=l2-1)    dfs(num,tot+1,1);
        else dfs(num,tot+1,pos);
        if(n2[tot]!=1)    dfs(num+pow(3,tot),tot+1,1);
        else dfs(num+pow(3,tot),tot+1,pos);
        if(n2[tot]!=2)    dfs(num+2*pow(3,tot),tot+1,1);
        else dfs(num+2*pow(3,tot),tot+1,pos);
    &#125;
&#125;
int main()&#123;
    cin&gt;&gt;s1;
    cin&gt;&gt;s2;
    l1=strlen(s1);
    l2=strlen(s2);
    if(s1[0]==&#39;0&#39;)&#123;
        for(int i=0;i&lt;l1;i++)
            sum1+=pow(2,i)*(s1[l1-1-i]-&#39;0&#39;);
        long long x=pow(2,l1-1);
        cout&lt;&lt;sum1+x;
        return 0;
    &#125;
    if(s2[0]==&#39;0&#39;)&#123;
        for(int i=0;i&lt;l2;i++)
            sum1+=pow(3,i)*(s2[l2-1-i]-&#39;0&#39;);
        long long x=pow(3,l2-1);
        cout&lt;&lt;sum1+x;
        return 0;
    &#125;
    for(int i=0;i&lt;l1;i++)    n1[i]=s1[l1-1-i]-&#39;0&#39;;
    for(int i=0;i&lt;l2;i++)    n2[i]=s2[l2-1-i]-&#39;0&#39;;
    for(int i=0;i&lt;l1;i++)    sum1+=pow(2,i)*n1[i];
    for(int i=0;i&lt;l1;i++)&#123;
        if(n1[i]&amp;&amp;i!=l1-1)    sum1-=pow(2,i);
        else sum1+=pow(2,i);
        dfs(0,0,0);
        if(n1[i]&amp;&amp;i!=l1-1)    sum1+=pow(2,i);
        else sum1-=pow(2,i);
    &#125;
&#125;
</code></pre>
<h1 id="传智杯-4-初赛-小卡和质数"><a href="#传智杯-4-初赛-小卡和质数" class="headerlink" title="[传智杯 #4 初赛] 小卡和质数"></a>[传智杯 #4 初赛] 小卡和质数</h1><h2 id="题目背景-1"><a href="#题目背景-1" class="headerlink" title="题目背景"></a>题目背景</h2><p>小卡最近迷上了质数，所以他想到了一个和质数有关的问题来考考你。</p>
<p>质数是指在大于1的自然数中，除了1和它本身以外不再有其他因数的自然数。</p>
<h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>小卡有 $T(1\le T\le 10^5)$ 组询问。每次询问给你两个正整数 $x,y(1\le x,y\le 10^9)$。</p>
<p>小卡想知道，第 $x$ 个质数和第 $y$ 个质数是否满足 $p_x \oplus p_y &#x3D;1$，即第 $x$ 个质数和第 $y$ 个质数的异或值是否是$1$。</p>
<h2 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行一个正整数 $T$，表示询问的数量。</p>
<p>接下来 $T$ 行，每行两个正整数 $x,y$，表示询问的是第 $x$ 个质数和第 $y$ 个质数。</p>
<h2 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式"></a>输出格式</h2><p>$T$ 行，每行一个字符串<code>Yes</code>或<code>No</code>，分别表示两个质数的异或值是 $1$ 或不是 $1$。</p>
<h2 id="样例-1-2"><a href="#样例-1-2" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-2"><a href="#样例输入-1-2" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">1 2</span><br><span class="line">23 145</span><br><span class="line">66 2</span><br><span class="line">1 14</span><br></pre></td></tr></table></figure>

<h3 id="样例输出-1-2"><a href="#样例输出-1-2" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Yes</span><br><span class="line">No</span><br><span class="line">No</span><br><span class="line">No</span><br></pre></td></tr></table></figure>

<h2 id="Analyse-2"><a href="#Analyse-2" class="headerlink" title="Analyse:"></a>Analyse:</h2><p>偶数中只有 2 是质数，而易知在其它质数中，只有 3 和 2 的异或值为 1。最终得到：两个质数只能是 3 和 2。</p>
<p>3 是第 2 个质数，2 是第一个质数，则 x 和 y 为 2 和 1。注意两数可能调换位置。</p>
<h2 id="Code-2"><a href="#Code-2" class="headerlink" title="Code:"></a>Code:</h2><pre><code>#include&lt;iostream&gt;
#include&lt;cmath&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
int l1,l2;
long long sum1;
char s1[10000],s2[10000];
int n1[10000],n2[10000];
void dfs(long long num,int tot,int pos)&#123;
    if(tot==l2)&#123;
        if(sum1==num)&#123;
            cout&lt;&lt;sum1;
            exit(0);
        &#125;
        return ;
    &#125;
    if(pos)    dfs(num+n2[tot]*pow(3,tot),tot+1,pos);
    else&#123;
        if(n2[tot]!=0&amp;&amp;tot!=l2-1)    dfs(num,tot+1,1);
        else dfs(num,tot+1,pos);
        if(n2[tot]!=1)    dfs(num+pow(3,tot),tot+1,1);
        else dfs(num+pow(3,tot),tot+1,pos);
        if(n2[tot]!=2)    dfs(num+2*pow(3,tot),tot+1,1);
        else dfs(num+2*pow(3,tot),tot+1,pos);
    &#125;
&#125;
int main()&#123;
    cin&gt;&gt;s1;
    cin&gt;&gt;s2;
    l1=strlen(s1);
    l2=strlen(s2);
    if(s1[0]==&#39;0&#39;)&#123;
        for(int i=0;i&lt;l1;i++)
            sum1+=pow(2,i)*(s1[l1-1-i]-&#39;0&#39;);
        long long x=pow(2,l1-1);
        cout&lt;&lt;sum1+x;
        return 0;
    &#125;
    if(s2[0]==&#39;0&#39;)&#123;
        for(int i=0;i&lt;l2;i++)
            sum1+=pow(3,i)*(s2[l2-1-i]-&#39;0&#39;);
        long long x=pow(3,l2-1);
        cout&lt;&lt;sum1+x;
        return 0;
    &#125;
    for(int i=0;i&lt;l1;i++)    n1[i]=s1[l1-1-i]-&#39;0&#39;;
    for(int i=0;i&lt;l2;i++)    n2[i]=s2[l2-1-i]-&#39;0&#39;;
    for(int i=0;i&lt;l1;i++)    sum1+=pow(2,i)*n1[i];
    for(int i=0;i&lt;l1;i++)&#123;
        if(n1[i]&amp;&amp;i!=l1-1)    sum1-=pow(2,i);
        else sum1+=pow(2,i);
        dfs(0,0,0);
        if(n1[i]&amp;&amp;i!=l1-1)    sum1+=pow(2,i);
        else sum1-=pow(2,i);
    &#125;
&#125;
</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/01/10/week12/" data-id="clhle1vkj000afgw15h79g72c" data-title="week12" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-week11" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/10/week11/" class="article-date">
  <time class="dt-published" datetime="2023-01-10T02:00:28.000Z" itemprop="datePublished">2023-01-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/01/10/week11/">week11</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="汤姆斯的天堂梦"><a href="#汤姆斯的天堂梦" class="headerlink" title="汤姆斯的天堂梦"></a>汤姆斯的天堂梦</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>汤姆斯生活在一个等级为 $0$ 的星球上。那里的环境极其恶劣，每天 $12$ 小时的工作和成堆的垃圾让人忍无可忍。他向往着等级为 $N$ 的星球上天堂般的生活。</p>
<p>有一些航班将人从低等级的星球送上高一级的星球，有时需要向驾驶员支付一定金额的费用，有时却又可以得到一定的金钱。</p>
<p>汤姆斯预先知道了从 $0$ 等级星球去 $N$ 等级星球所有的航线和需要支付（或者可以得到）的金钱，他想寻找一条价格最低（甚至获得金钱最多）的航线。</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行一个正整数 $N$（$N \le 100$），接下来的数据可分为 $N$ 个段落，每段的第一行一个整数 $K_i$（$K_i \le 100$），表示等级为 $i$ 的星球有 $K_i$ 个。</p>
<p>接下来的 $K_i$ 行中第 $j$ 行依次表示与等级为 $i$，编号为 $j$ 的星球相连的等级为 $i - 1$ 的星球的编号和此航线需要的费用（正数表示支出，负数表示收益，费用的绝对值不超过 $1000$）。</p>
<p>每行以 $0$ 结束，每行的航线数 $\le 100$。</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出所需（或所得）费用。正数表示支出，负数表示收益。</p>
<h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">2</span><br><span class="line">1 15 0</span><br><span class="line">1 5 0</span><br><span class="line">3</span><br><span class="line">1 -5 2 10 0</span><br><span class="line">1 3 0</span><br><span class="line">2 40 0</span><br><span class="line">2</span><br><span class="line">1 1 2 5 3 -5 0</span><br><span class="line">2 -19 3 -20 0</span><br></pre></td></tr></table></figure>

<h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-1</span><br></pre></td></tr></table></figure>

<h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p>对于 $100 %$ 的数据，$1 \le N \le 100$，$1 \le K_i \le 100$。</p>
<p>样例解释：</p>
<p><img src="https://cdn.luogu.com.cn/upload/pic/652.png"></p>
<h2 id="Analyse-这道题的状态转移方程很好找，用i表示星球的等级，j表示星球编号，c为代价，可得f-i-j-x3D-min-f-i-1-j-c，f-i-j-，然后这道题就迎刃而解了"><a href="#Analyse-这道题的状态转移方程很好找，用i表示星球的等级，j表示星球编号，c为代价，可得f-i-j-x3D-min-f-i-1-j-c，f-i-j-，然后这道题就迎刃而解了" class="headerlink" title="Analyse: 这道题的状态转移方程很好找，用i表示星球的等级，j表示星球编号，c为代价，可得f[i][j]&#x3D;min(f[i - 1][j] + c，f[i][j])，然后这道题就迎刃而解了"></a>Analyse: 这道题的状态转移方程很好找，用i表示星球的等级，j表示星球编号，c为代价，可得f[i][j]&#x3D;min(f[i - 1][j] + c，f[i][j])，然后这道题就迎刃而解了</h2><h2 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h2><pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
int a[10001];    
int n,m,ans;
int main()
&#123;
    cin&gt;&gt;n&gt;&gt;m;
    for(int i=1;i&lt;=m;i++)
    &#123;
        int x,y;
        cin&gt;&gt;x&gt;&gt;y;
        a[x]++;
        a[y]++;
    &#125;
    for(int i=1;i&lt;=n;i++)
    &#123;
        if(a[i]%2==1)
              ans++;
    &#125;
    if(ans)
       cout&lt;&lt;ans/2;
    else
       cout&lt;&lt;ans+1;
    return 0;
&#125;
</code></pre>
<h1 id="跑步"><a href="#跑步" class="headerlink" title="跑步"></a>跑步</h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>路人甲准备跑 $n$ 圈来锻炼自己的身体，他准备分多次（$\gt1$）跑完，每次都跑正整数圈，然后休息下再继续跑。</p>
<p>为了有效地提高自己的体能，他决定每次跑的圈数都必须比上次跑的多。</p>
<p>可以假设他刚开始跑了 $0$ 圈，那么请问他可以有多少种跑完这 $n$ 圈的方案？</p>
<h2 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h2><p>一行一个整数，代表 $n$。</p>
<h2 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h2><p>一个整数表示跑完这 $n$ 圈的方案数。</p>
<h2 id="样例-1-1"><a href="#样例-1-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-1"><a href="#样例输入-1-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">212</span><br></pre></td></tr></table></figure>

<h3 id="样例输出-1-1"><a href="#样例输出-1-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">995645335</span><br></pre></td></tr></table></figure>

<h2 id="提示-1"><a href="#提示-1" class="headerlink" title="提示"></a>提示</h2><h4 id="数据规模与约定"><a href="#数据规模与约定" class="headerlink" title="数据规模与约定"></a>数据规模与约定</h4><p>对于 $100%$ 的数据，保证 $5\le n\le 500$。</p>
<h2 id="Analyse-什么是动规？"><a href="#Analyse-什么是动规？" class="headerlink" title="Analyse:什么是动规？"></a>Analyse:<strong>什么是动规？</strong></h2><pre><code>动规，全称动态规划
指动态地演变每一步，类似著名的斐波那契数列：
末路等于来路之和……
实现过程即为开一个足够的数组，然后模拟每一步，最终答案为数组的第n项。
时间复杂度：低
</code></pre>
<h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code:"></a>Code:</h2><pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
int a[10001];    
int n,m,ans;
int main()
&#123;
    cin&gt;&gt;n&gt;&gt;m;
    for(int i=1;i&lt;=m;i++)
    &#123;
        int x,y;
        cin&gt;&gt;x&gt;&gt;y;
        a[x]++;
        a[y]++;
    &#125;
    for(int i=1;i&lt;=n;i++)
    &#123;
        if(a[i]%2==1)
              ans++;
    &#125;
    if(ans)
       cout&lt;&lt;ans/2;
    else
       cout&lt;&lt;ans+1;
    return 0;
&#125;
</code></pre>
<h1 id="跑步-1"><a href="#跑步-1" class="headerlink" title="跑步"></a>跑步</h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>路人甲准备跑 $n$ 圈来锻炼自己的身体，他准备分多次（$\gt1$）跑完，每次都跑正整数圈，然后休息下再继续跑。</p>
<p>为了有效地提高自己的体能，他决定每次跑的圈数都必须比上次跑的多。</p>
<p>可以假设他刚开始跑了 $0$ 圈，那么请问他可以有多少种跑完这 $n$ 圈的方案？</p>
<h2 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式"></a>输入格式</h2><p>一行一个整数，代表 $n$。</p>
<h2 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式"></a>输出格式</h2><p>一个整数表示跑完这 $n$ 圈的方案数。</p>
<h2 id="样例-1-2"><a href="#样例-1-2" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-2"><a href="#样例输入-1-2" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">212</span><br></pre></td></tr></table></figure>

<h3 id="样例输出-1-2"><a href="#样例输出-1-2" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">995645335</span><br></pre></td></tr></table></figure>

<h2 id="提示-2"><a href="#提示-2" class="headerlink" title="提示"></a>提示</h2><h4 id="数据规模与约定-1"><a href="#数据规模与约定-1" class="headerlink" title="数据规模与约定"></a>数据规模与约定</h4><p>对于 $100%$ 的数据，保证 $5\le n\le 500$。</p>
<h2 id="Analyse-Code"><a href="#Analyse-Code" class="headerlink" title="Analyse:## Code:"></a>Analyse:## Code:</h2><pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
int a[10001];    
int n,m,ans;
int main()
&#123;
    cin&gt;&gt;n&gt;&gt;m;
    for(int i=1;i&lt;=m;i++)
    &#123;
        int x,y;
        cin&gt;&gt;x&gt;&gt;y;
        a[x]++;
        a[y]++;
    &#125;
    for(int i=1;i&lt;=n;i++)
    &#123;
        if(a[i]%2==1)
              ans++;
    &#125;
    if(ans)
       cout&lt;&lt;ans/2;
    else
       cout&lt;&lt;ans+1;
    return 0;
&#125;
</code></pre>
<h1 id="蓝桥杯-2021-省-AB-砝码称重"><a href="#蓝桥杯-2021-省-AB-砝码称重" class="headerlink" title="[蓝桥杯 2021 省 AB] 砝码称重"></a>[蓝桥杯 2021 省 AB] 砝码称重</h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p>你有一架天平和 $N$ 个砝码, 这 $N$ 个砝码重量依次是 $W_{1}, W_{2}, \cdots, W_{N}$ 。 请你计算一共可以称出多少种不同的重量?</p>
<p>注意砝码可以放在天平两边。</p>
<h2 id="输入格式-3"><a href="#输入格式-3" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入的第一行包含一个整数 $N$ 。</p>
<p>第二行包含 $N$ 个整数: $W_{1}, W_{2}, W_{3}, \cdots, W_{N}$ 。</p>
<h2 id="输出格式-3"><a href="#输出格式-3" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一个整数代表答案。</p>
<h2 id="样例-1-3"><a href="#样例-1-3" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-3"><a href="#样例输入-1-3" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">1 4 6</span><br></pre></td></tr></table></figure>

<h3 id="样例输出-1-3"><a href="#样例输出-1-3" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10</span><br></pre></td></tr></table></figure>

<h2 id="提示-3"><a href="#提示-3" class="headerlink" title="提示"></a>提示</h2><p><strong>【样例说明】</strong></p>
<p>能称出的 10 种重量是: $1 、 2 、 3 、 4 、 5 、 6 、 7 、 9 、 10 、 11$ 。</p>
<p>$$<br>\begin{aligned}<br>&amp;1&#x3D;1 \<br>&amp;2&#x3D;6-4(\text { 天平一边放 } 6, \text { 另一边放 4) } \<br>&amp;3&#x3D;4-1 \<br>&amp;4&#x3D;4 \<br>&amp;5&#x3D;6-1 \<br>&amp;6&#x3D;6 \<br>&amp;7&#x3D;1+6 \<br>&amp;9&#x3D;4+6-1 \<br>&amp;10&#x3D;4+6 \<br>&amp;11&#x3D;1+4+6<br>\end{aligned}<br>$$</p>
<p><strong>【评测用例规模与约定】</strong></p>
<p>对于 $50 %$ 的评测用例, $1 \leq N \leq 15$ 。</p>
<p>对于所有评测用例, $1 \leq N \leq 100, N$ 个砝码总重不超过 $10^5$。 </p>
<p>蓝桥杯 2021 第一轮省赛 A 组 F 题（B 组 G 题）。</p>
<h2 id="Analyse-Code-1"><a href="#Analyse-Code-1" class="headerlink" title="Analyse:## Code:"></a>Analyse:## Code:</h2><pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
int a[10001];    
int n,m,ans;
int main()
&#123;
    cin&gt;&gt;n&gt;&gt;m;
    for(int i=1;i&lt;=m;i++)
    &#123;
        int x,y;
        cin&gt;&gt;x&gt;&gt;y;
        a[x]++;
        a[y]++;
    &#125;
    for(int i=1;i&lt;=n;i++)
    &#123;
        if(a[i]%2==1)
              ans++;
    &#125;
    if(ans)
       cout&lt;&lt;ans/2;
    else
       cout&lt;&lt;ans+1;
    return 0;
&#125;
</code></pre>
<h1 id="遗址"><a href="#遗址" class="headerlink" title="遗址"></a>遗址</h1><h2 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h2><p>很久很久以前有一座寺庙，从上往下看寺庙的形状正好是一个正方形，由 $4$ 个角上竖立的圆柱搭建而成。现在圆柱都倒塌了，只在地上留下圆形的痕迹，可是现在地上有很多这样的痕迹，专家说一定是最大的那个。</p>
<p>写一个程序，给出圆柱的坐标，找出由 $4$ 个圆柱构成的最大的正方形，因为这就是寺庙的位置，要求计算出最大的面积。注意正方形的边不一定平行于坐标轴。</p>
<p>例如图有 $10$ 根柱子，其中 $(4,2),(5,2),(5,3),(4,3)$ 可以形成一个正方形，$(1,1),(4,0),(5,3),(2,4)$ 也可以，后者是其中最大的，面积为 $10$。</p>
<p><img src="https://cdn.luogu.com.cn/upload/pic/869.png"></p>
<h2 id="输入格式-4"><a href="#输入格式-4" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行包含一个 $N(1\leq N\leq 3000)$，表示柱子的数量。</p>
<p>接下来 $N$ 行，每行有两个空格隔开的整数表示柱子的坐标（坐标值在 $0$ 到 $5000$ 之间），柱子的位置互不相同。</p>
<h2 id="输出格式-4"><a href="#输出格式-4" class="headerlink" title="输出格式"></a>输出格式</h2><p>如果存在正方形，输出最大的面积，否则输出 $0$。</p>
<h2 id="样例-1-4"><a href="#样例-1-4" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-4"><a href="#样例输入-1-4" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line"> 9 4</span><br><span class="line"> 4 3</span><br><span class="line"> 1 1</span><br><span class="line"> 4 2</span><br><span class="line"> 2 4</span><br><span class="line"> 5 8</span><br><span class="line"> 4 0</span><br><span class="line"> 5 3</span><br><span class="line"> 0 5</span><br><span class="line"> 5 2</span><br></pre></td></tr></table></figure>

<h3 id="样例输出-1-4"><a href="#样例输出-1-4" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10</span><br></pre></td></tr></table></figure>

<h2 id="提示-4"><a href="#提示-4" class="headerlink" title="提示"></a>提示</h2><p>【数据范围】</p>
<p>$30%$ 满足：$1\leq N \leq100$。</p>
<p>$60%$ 满足：$1\leq N \leq500$。</p>
<p>$100%$ 满足：$1\leq N \leq3000$。</p>
<h2 id="Analyse-我们的难点在于如何判断两个点是倾斜的情况"><a href="#Analyse-我们的难点在于如何判断两个点是倾斜的情况" class="headerlink" title="Analyse:### 我们的难点在于如何判断两个点是倾斜的情况."></a>Analyse:### 我们的难点在于如何判断两个点是倾斜的情况.</h2><p>容易发现一个将一个倾斜正方形围起来之后,四个三角形是相等的. 像这样↓ <img src="https://i.loli.net/2018/09/06/5b9080d67ca2b.png"></p>
<p>很明显全等吧!<del>证明过程略</del></p>
<p>然后我们需要<strong>考虑的是两个点所在直线斜率是正还是负</strong>的问题</p>
<p>(亲测只考虑一种情况,不能AC此题.)</p>
<p><code>求斜率的公式： k=Δy/Δx</code></p>
<p><strong>分母不能为0!</strong></p>
<p>然后我们又开始画图 emmm</p>
<p><strong>斜率为负</strong>有两种情况.我们可以画图如下↓ <img src="https://i.loli.net/2018/09/06/5b90a49775949.png"></p>
<p><strong>斜率为正</strong>.同样有两种情况如下↓ <img src="https://i.loli.net/2018/09/06/5b909ec9c8eef.png">Code:</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;map&gt;
using namespace std;
struct A&#123;
    int x,y; 
&#125;a[5005]; 
int n,a1,a2;
int maxn=0;
int a3[5005][5005];
int main()&#123;
    scanf(&quot;%d&quot;,&amp;n);
    for(int i=1;i&lt;=n;i++)&#123;
        scanf(&quot;%d%d&quot;,&amp;a[i].x,&amp;a[i].y);
        a3[a[i].x][a[i].y]=1;
    &#125;
    for(int i=2;i&lt;=n;i++)&#123;
        for(int j=1;j&lt;i;j++)&#123;
            if(i!=j)&#123;
                a1=(a[i].x&gt;=a[j].x?a[i].x-a[j].x:a[j].x-a[i].x);
                a2=(a[i].y&gt;=a[j].y?a[i].y-a[j].y:a[j].y-a[i].y);
                if(a[j].y-a1&gt;=0&amp;&amp;a[j].x+a2&lt;=5000&amp;&amp;a[i].y-a1&gt;=0&amp;&amp;a[i].x+a2&lt;=5000)&#123;
                    if(a3[a[i].x+a2][a[i].y-a1]&amp;&amp;a3[a[j].x+a2][a[j].y-a1])&#123;
                        maxn=(maxn&gt;=(a1*a1+a2*a2)?maxn:(a1*a1+a2*a2));
                    &#125;	
                &#125;
                if(a[j].y+a1&lt;=5000&amp;&amp;a[j].x-a2&gt;=0&amp;&amp;a[i].y+a1&lt;=5000&amp;&amp;a[i].x-a2&gt;=0)&#123;
                    if(a3[a[i].x-a2][a[i].y+a1]&amp;&amp;a3[a[j].x-a2][a[j].y+a1])&#123;
                        maxn=(maxn&gt;=(a1*a1+a2*a2)?maxn:(a1*a1+a2*a2));
                    &#125;
                &#125;
                
            &#125;
        &#125;
    &#125;
    cout&lt;&lt;maxn;
&#125;
</code></pre>
<h1 id="蓝桥杯-2022-国-A-环境治理"><a href="#蓝桥杯-2022-国-A-环境治理" class="headerlink" title="[蓝桥杯 2022 国 A] 环境治理"></a>[蓝桥杯 2022 国 A] 环境治理</h1><h2 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h2><p>LQ 国拥有 $n$ 个城市，从 $0$ 到 $n - 1$ 编号，这 $n$ 个城市两两之间都有且仅有一条双向道路连接，这意味着任意两个城市之间都是可达的。每条道路都有一个属性 $D$，表示这条道路的灰尘度。当从一个城市 A 前往另一个城市 B 时，可能存在多条路线，每条路线的灰尘度定义为这条路线所经过的所有道路的灰尘度之和，LQ 国的人都很讨厌灰尘，所以他们总会优先选择灰尘度最小的路线。</p>
<p>LQ 国很看重居民的出行环境，他们用一个指标 $P$ 来衡量 LQ 国的出行环境，$P$ 定义为：</p>
<p>$$P&#x3D;\sum \limits_{i&#x3D;0}^{n-1} \sum \limits_{j&#x3D;0}^{n-1} d(i,j)$$</p>
<p>其中 $d(i,j)$ 表示城市 $i$ 到城市 $j$ 之间灰尘度最小的路线对应的灰尘度的值。</p>
<p>为了改善出行环境，每个城市都要有所作为，当某个城市进行道路改善时，会将与这个城市直接相连的所有道路的灰尘度都减少 $1$，但每条道路都有一个灰尘度的下限值 $L$，当灰尘度达到道路的下限值时，无论再怎么改善，道路的灰尘度也不会再减小了。</p>
<p>具体的计划是这样的：</p>
<ul>
<li>第 $1$ 天，$0$ 号城市对与其直接相连的道路环境进行改善；</li>
<li>第 $2$ 天，$1$ 号城市对与其直接相连的道路环境进行改善；</li>
</ul>
<p>……</p>
<ul>
<li>第 $n$ 天，$n - 1$ 号城市对与其直接相连的道路环境进行改善；</li>
<li>第 $n + 1$ 天，$0$ 号城市对与其直接相连的道路环境进行改善；</li>
<li>第 $n + 2$ 天，$1$ 号城市对与其直接相连的道路环境进行改善；</li>
</ul>
<p>……</p>
<p>LQ 国想要使得 $P$ 指标满足 $P \leq Q$。请问最少要经过多少天之后，$P$ 指标可以满足 $P \leq Q$。如果在初始时就已经满足条件，则输出 $0$；如果永远不可能满足，则输出 $-1$。</p>
<h2 id="输入格式-5"><a href="#输入格式-5" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入的第一行包含两个整数 $n, Q$，用一个空格分隔，分别表示城市个数和期望达到的 $P$ 指标。</p>
<p>接下来 $n$ 行，每行包含 $n$ 个整数，相邻两个整数之间用一个空格分隔，其中第 $i$ 行第 $j$ 列的值 $D_{i,j} (D_{i,j}&#x3D;D_{j,i},D_{i,i} &#x3D; 0)$ 表示城市 $i$ 与城市 $j$ 之间直接相连的那条道路的灰尘度。</p>
<p>接下来 $n$ 行，每行包含 $n$ 个整数，相邻两个整数之间用一个空格分隔，其中第 $i$ 行第 $j$ 列的值 $L_{i,j} (L_{i,j} &#x3D; L_{j,i}, L_{i,i} &#x3D; 0)$ 表示城市 $i$ 与城市 $j$ 之间直接相连的那条道路的灰尘度的下限值。</p>
<h2 id="输出格式-5"><a href="#输出格式-5" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一行包含一个整数表示答案。</p>
<h2 id="样例-1-5"><a href="#样例-1-5" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-5"><a href="#样例输入-1-5" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">3 10</span><br><span class="line">0 2 4</span><br><span class="line">2 0 1</span><br><span class="line">4 1 0</span><br><span class="line">0 2 2</span><br><span class="line">2 0 0</span><br><span class="line">2 0 0</span><br></pre></td></tr></table></figure>

<h3 id="样例输出-1-5"><a href="#样例输出-1-5" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure>

<h2 id="提示-5"><a href="#提示-5" class="headerlink" title="提示"></a>提示</h2><p><strong>【样例说明】</strong></p>
<p>初始时的图如下所示，每条边上的数字表示这条道路的灰尘度：</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/5lz6auke.png"></p>
<p>此时每对顶点之间的灰尘度最小的路线对应的灰尘度为：</p>
<ul>
<li>$d(0, 0) &#x3D; 0, d(0, 1) &#x3D; 2, d(0, 2) &#x3D; 3$；</li>
<li>$d(1, 0) &#x3D; 2, d(1, 1) &#x3D; 0, d(1, 2) &#x3D; 1$；</li>
<li>$d(2, 0) &#x3D; 3, d(2, 1) &#x3D; 1, d(2, 2) &#x3D; 0$。</li>
</ul>
<p>初始时的 $P$ 指标为 $(2 + 3 + 1) \times 2 &#x3D; 12$，不满足 $P \leq Q &#x3D; 10$;</p>
<p>第一天，$0$ 号城市进行道路改善，改善后的图示如下：</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/mrhf5wx6.png"></p>
<p>注意到边 $(0, 2)$ 的值减小了 $1$，但 $(0, 1)$ 并没有减小，因为 $L_{0,1} &#x3D; 2$ ，所以 $(0, 1)$ 的值不可以再减小了。此时每对顶点之间的灰尘度最小的路线对应的灰尘度为：</p>
<ul>
<li>$d(0, 0) &#x3D; 0, d(0, 1) &#x3D; 2, d(0, 2) &#x3D; 3$，</li>
<li>$d(1, 0) &#x3D; 2, d(1, 1) &#x3D; 0, d(1, 2) &#x3D; 1$，</li>
<li>$d(2, 0) &#x3D; 3, d(2, 1) &#x3D; 1, d(2, 2) &#x3D; 0$。</li>
</ul>
<p>此时 $P$ 仍为 $12$。</p>
<p>第二天，1 号城市进行道路改善，改善后的图示如下：</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/tjxis3yb.png"></p>
<p>此时每对顶点之间的灰尘度最小的路线对应的灰尘度为：</p>
<ul>
<li>$d(0, 0) &#x3D; 0, d(0, 1) &#x3D; 2, d(0, 2) &#x3D; 2$，</li>
<li>$d(1, 0) &#x3D; 2, d(1, 1) &#x3D; 0, d(1, 2) &#x3D; 0$，</li>
<li>$d(2, 0) &#x3D; 2, d(2, 1) &#x3D; 0, d(2, 2) &#x3D; 0$。</li>
</ul>
<p>此时的 $P$ 指标为 $(2 + 2) \times 2 &#x3D; 8 &lt; Q$，此时已经满足条件。</p>
<p>所以答案是 $2$。</p>
<p><strong>【评测用例规模与约定】</strong></p>
<ul>
<li>对于 $30%$ 的评测用例，$1 \leq n \leq 10$，$0 \leq L_{i,j} \leq D_{i,j} \leq 10$；</li>
<li>对于 $60%$ 的评测用例，$1 \leq n \leq 50$，$0 \leq L_{i,j} \leq D_{i,j} \leq 10^5$；</li>
<li>对于所有评测用例，$1 \leq n \leq 100$，$0 \leq L_{i,j} \leq D_{i,j} \leq 10^5$，$0 \leq Q \leq 2^{31} - 1$。</li>
</ul>
<p>蓝桥杯 2022 国赛 A 组 F 题。</p>
<h2 id="Analyse"><a href="#Analyse" class="headerlink" title="Analyse:"></a>Analyse:</h2><p>P &#x3D; 任意两点之间的最短距离的和，可以用 Floyd 算法求，单次检查复杂度 O(n3)</p>
<p>由于道路改善发生的次数越多，指标 P 越小。故根据这种单调性，可以采用二分，二分道路改善次数 x。已知道路改善次数的情况，我们可以很快的知道图上每一条边当下的边权，然后我们可以用 Floyd 算法计算一下指标 P，判断指标 P 是否小于等于 Q 即可，复杂度 O(n3logK)，其中 K 为最大的道路改善次数，设成 109 左右即可。</p>
<h2 id="Analyse-Code-2"><a href="#Analyse-Code-2" class="headerlink" title="Analyse:## Code:"></a>Analyse:## Code:</h2><pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
int a[10001];    
int n,m,ans;
int main()
&#123;
    cin&gt;&gt;n&gt;&gt;m;
    for(int i=1;i&lt;=m;i++)
    &#123;
        int x,y;
        cin&gt;&gt;x&gt;&gt;y;
        a[x]++;
        a[y]++;
    &#125;
    for(int i=1;i&lt;=n;i++)
    &#123;
        if(a[i]%2==1)
              ans++;
    &#125;
    if(ans)
       cout&lt;&lt;ans/2;
    else
       cout&lt;&lt;ans+1;
    return 0;
&#125;
</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/01/10/week11/" data-id="clhle1vkj0009fgw1f63sbz9e" data-title="week11" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-week10" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/10/week10/" class="article-date">
  <time class="dt-published" datetime="2023-01-10T02:00:08.000Z" itemprop="datePublished">2023-01-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/01/10/week10/">week10</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Einstein学画画"><a href="#Einstein学画画" class="headerlink" title="Einstein学画画"></a>Einstein学画画</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Einstein 学起了画画。</p>
<p>此人比较懒~~，他希望用最少的笔画画出一张画……</p>
<p>给定一个无向图，包含 $n$ 个顶点（编号 $1 \sim n$），$m$ 条边，求最少用多少笔可以画出图中所有的边。</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行两个整数 $n, m$。</p>
<p>接下来 $m$ 行，每行两个数 $a, b$（$a \ne b$），表示 $a, b$ 两点之间有一条边相连。</p>
<p>一条边不会被描述多次。</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>一个数，即问题的答案。</p>
<h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5 5</span><br><span class="line">2 3</span><br><span class="line">2 4</span><br><span class="line">2 5</span><br><span class="line">3 4</span><br><span class="line">4 5</span><br></pre></td></tr></table></figure>

<h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure>

<h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p>对于 $50 %$ 的数据，$n \le 50$，$m \le 100$。</p>
<p>对于 $100%$ 的数据，$1 \le n \le 1000$，$1 \le m \le {10}^5$。</p>
<h2 id="Analyse"><a href="#Analyse" class="headerlink" title="Analyse:"></a>Analyse:</h2><p>复习了图论，这里其实就是单纯考察对半欧拉图概念的理解与深化，不懂的同学点链接自己看：</p>
<p>[<a target="_blank" rel="noopener" href="http://baike.sogou.com/v10809694.htm?fromTitle=%E5%8D%8A%E6%AC%A7%E6%8B%89%E5%9B%BE">半欧拉图 - 搜狗百科</a><a target="_blank" rel="noopener" href="http://baike.sogou.com/v10809694.htm?fromTitle=%E5%8D%8A%E6%AC%A7%E6%8B%89%E5%9B%BE">半欧拉图 - 搜狗百科</a>]</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h2><pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
int a[10001];    
int n,m,ans;
int main()
&#123;
    cin&gt;&gt;n&gt;&gt;m;
    for(int i=1;i&lt;=m;i++)
    &#123;
        int x,y;
        cin&gt;&gt;x&gt;&gt;y;
        a[x]++;
        a[y]++;
    &#125;
    for(int i=1;i&lt;=n;i++)
    &#123;
        if(a[i]%2==1)
              ans++;
    &#125;
    if(ans)
       cout&lt;&lt;ans/2;
    else
       cout&lt;&lt;ans+1;
    return 0;
&#125;
</code></pre>
<h1 id="蓝桥杯-2017-国-C-合根植物"><a href="#蓝桥杯-2017-国-C-合根植物" class="headerlink" title="[蓝桥杯 2017 国 C] 合根植物"></a>[蓝桥杯 2017 国 C] 合根植物</h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>w 星球的一个种植园，被分成 $m \times n$ 个小格子（东西方向 $m$ 行，南北方向 $n$ 列）。每个格子里种了一株合根植物。</p>
<p>这种植物有个特点，它的根可能会沿着南北或东西方向伸展，从而与另一个格子的植物合成为一体。</p>
<p>如果我们告诉你哪些小格子间出现了连根现象，你能说出这个园中一共有多少株合根植物吗？</p>
<h2 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行，两个整数 $m$，$n$，用空格分开，表示格子的行数、列数（$1&lt;m,n&lt;1000$）。</p>
<p>接下来一行，一个整数 $k$，表示下面还有 $k$ 行数据 $(0&lt;k&lt;10^5)$。</p>
<p>接下来 $k$ 行，第行两个整数 $a$，$b$，表示编号为 $a$ 的小格子和编号为 $b$ 的小格子合根了。</p>
<p>格子的编号一行一行，从上到下，从左到右编号。</p>
<p>比如：$5 \times 4$ 的小格子，编号：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1  2  3  4</span><br><span class="line">5  6  7  8</span><br><span class="line">9  10 11 12</span><br><span class="line">13 14 15 16</span><br><span class="line">17 18 19 20</span><br></pre></td></tr></table></figure>

<h2 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h2><p>一行一个整数，表示答案</p>
<h2 id="样例-1-1"><a href="#样例-1-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-1"><a href="#样例输入-1-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">5 4</span><br><span class="line">16</span><br><span class="line">2 3</span><br><span class="line">1 5</span><br><span class="line">5 9</span><br><span class="line">4 8</span><br><span class="line">7 8</span><br><span class="line">9 10</span><br><span class="line">10 11</span><br><span class="line">11 12</span><br><span class="line">10 14</span><br><span class="line">12 16</span><br><span class="line">14 18</span><br><span class="line">17 18</span><br><span class="line">15 19</span><br><span class="line">19 20</span><br><span class="line">9 13</span><br><span class="line">13 17</span><br></pre></td></tr></table></figure>

<h3 id="样例输出-1-1"><a href="#样例输出-1-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure>

<h2 id="提示-1"><a href="#提示-1" class="headerlink" title="提示"></a>提示</h2><h2 id="样例解释"><a href="#样例解释" class="headerlink" title="样例解释"></a>样例解释</h2><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/9q0xulxh.png"></p>
<p>时限 1 秒, 256M。蓝桥杯 2017 年第八届国赛</p>
<h2 id="Analyse-1"><a href="#Analyse-1" class="headerlink" title="Analyse:"></a>Analyse:</h2><h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code:"></a>Code:</h2><pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
int n,m,num,x,y,sum;
int set[1000006],rank[1000006];
void init()&#123;                        //初始化每个节点的父节点均为本身
    for(int i=1;i&lt;=n;i++)&#123;          //深度为0
        set[i]=i;
        rank[i]=0;
    &#125;
&#125;
int find(int a)&#123;                    //查找这个集合的最终父节点
    //如果集合i的父亲是自己，说明自己就是源头，返回自己的标号
    if(set[a]==a)
        return a;
    //否则查找集合i的父亲的源头
    return set[a]=find(set[a]);
&#125;
void merge(int a,int b)&#123;                //将两个集合合二为一
    a = find(a);                        //先找到两个集合的源头
    b = find(b);
    if(a==b) return; //如果两个集合指向的是同一个源头，则说明两个集合是同一个集合，不再考虑
    if(rank[a]&gt;rank[b])set[b]=a;        //如果A集合的深度大于B集合。将B挂到A上，使集合的深度尽可能均匀
    else&#123;
        if(rank[a]==rank[b])rank[b]++;  //B若大于A，则将A挂到B上
        set[a]=b;
    &#125;
&#125;
int main()&#123;
    cin&gt;&gt;m&gt;&gt;n;
    n*=m;
    cin&gt;&gt;num;
    init();
    for(int i=0;i&lt;num;i++)&#123;
        scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
        merge(x,y);
    &#125;
    for(int i=1;i&lt;=n;i++)&#123;
        if(find(i)==i)sum++;
    &#125;
    cout&lt;&lt;sum&lt;&lt;endl;
    printf(&quot;%d\n&quot;,sum);
&#125;
</code></pre>
<h1 id="NOIP2017-提高组-奶酪"><a href="#NOIP2017-提高组-奶酪" class="headerlink" title="[NOIP2017 提高组] 奶酪"></a>[NOIP2017 提高组] 奶酪</h1><h2 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h2><p>NOIP2017 提高组 D2T1</p>
<h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>现有一块大奶酪，它的高度为 $h$，它的长度和宽度我们可以认为是无限大的，奶酪中间有许多半径相同的球形空洞。我们可以在这块奶酪中建立空间坐标系，在坐标系中，奶酪的下表面为 $z &#x3D; 0$，奶酪的上表面为 $z &#x3D; h$。</p>
<p>现在，奶酪的下表面有一只小老鼠 Jerry，它知道奶酪中所有空洞的球心所在的坐标。如果两个空洞相切或是相交，则 Jerry 可以从其中一个空洞跑到另一个空洞，特别地，如果一个空洞与下表面相切或是相交，Jerry 则可以从奶酪下表面跑进空洞；如果一个空洞与上表面相切或是相交，Jerry 则可以从空洞跑到奶酪上表面。</p>
<p>位于奶酪下表面的 Jerry 想知道，在不破坏奶酪的情况下，能否利用已有的空洞跑 到奶酪的上表面去?</p>
<p>空间内两点 $P_1(x_1,y_1,z_1)$、$P2(x_2,y_2,z_2)$ 的距离公式如下：</p>
<p>$$\mathrm{dist}(P_1,P_2)&#x3D;\sqrt{(x_1-x_2)^2+(y_1-y_2)^2+(z_1-z_2)^2}$$</p>
<h2 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式"></a>输入格式</h2><p>每个输入文件包含多组数据。</p>
<p>第一行，包含一个正整数 $T$，代表该输入文件中所含的数据组数。</p>
<p>接下来是 $T$ 组数据，每组数据的格式如下： 第一行包含三个正整数 $n,h,r$，两个数之间以一个空格分开，分别代表奶酪中空洞的数量，奶酪的高度和空洞的半径。</p>
<p>接下来的 $n$ 行，每行包含三个整数 $x,y,z$，两个数之间以一个空格分开，表示空洞球心坐标为 $(x,y,z)$。</p>
<h2 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式"></a>输出格式</h2><p>$T$ 行，分别对应 $T$ 组数据的答案，如果在第 $i$ 组数据中，Jerry 能从下表面跑到上表面，则输出 <code>Yes</code>，如果不能，则输出 <code>No</code>。</p>
<h2 id="样例-1-2"><a href="#样例-1-2" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-2"><a href="#样例输入-1-2" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">3 </span><br><span class="line">2 4 1 </span><br><span class="line">0 0 1 </span><br><span class="line">0 0 3 </span><br><span class="line">2 5 1 </span><br><span class="line">0 0 1 </span><br><span class="line">0 0 4 </span><br><span class="line">2 5 2 </span><br><span class="line">0 0 2 </span><br><span class="line">2 0 4</span><br></pre></td></tr></table></figure>

<h3 id="样例输出-1-2"><a href="#样例输出-1-2" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Yes</span><br><span class="line">No</span><br><span class="line">Yes</span><br></pre></td></tr></table></figure>

<h2 id="提示-2"><a href="#提示-2" class="headerlink" title="提示"></a>提示</h2><p>【输入输出样例 $1$ 说明】</p>
<p> <img src="https://cdn.luogu.com.cn/upload/pic/10860.png"> </p>
<p>第一组数据,由奶酪的剖面图可见：</p>
<p>第一个空洞在 $(0,0,0)$ 与下表面相切；</p>
<p>第二个空洞在 $(0,0,4)$ 与上表面相切；</p>
<p>两个空洞在 $(0,0,2)$ 相切。</p>
<p>输出 <code>Yes</code>。</p>
<p>第二组数据,由奶酪的剖面图可见：</p>
<p>两个空洞既不相交也不相切。</p>
<p>输出 <code>No</code>。</p>
<p>第三组数据,由奶酪的剖面图可见：</p>
<p>两个空洞相交，且与上下表面相切或相交。</p>
<p>输出 <code>Yes</code>。</p>
<p>【数据规模与约定】</p>
<p>对于 $20%$ 的数据，$n &#x3D; 1$，$1 \le h$，$r \le  10^4$，坐标的绝对值不超过 $10^4$。</p>
<p>对于 $40%$ 的数据，$1 \le n \le 8$，$1 \le h$，$r \le 10^4$，坐标的绝对值不超过 $10^4$。</p>
<p>对于 $80%$ 的数据，$1 \le n \le 10^3$，$1 \le h , r \le 10^4$，坐标的绝对值不超过 $10^4$。</p>
<p>对于 $100%$ 的数据，$1 \le n \le 1\times 10^3$，$1 \le h , r \le 10^9$，$T \le 20$，坐标的绝对值不超过 $10^9$。</p>
<h2 id="Analyse-2"><a href="#Analyse-2" class="headerlink" title="Analyse:"></a>Analyse:</h2><h2 id="Code-2"><a href="#Code-2" class="headerlink" title="Code:"></a>Code:</h2><pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
typedef long long L2;
using namespace std;
const int maxn = 1e5 + 5;
const int num = 1e3 + 5;
int Ma[num];
L2 a1[num], a2[num], a3[num];
int t, n;
int h, r;
void init() &#123;
    for (int i = 0; i &lt;= n + 1; i++) Ma[i] = i;//, deep[i] = 1;
&#125;
bool isTangency(L2 x1, L2 y1, L2 z1, L2 x2, L2 y2, L2 z2, L2 r) &#123;
    return&#123; (x1 - x2)*(x1 - x2) + (y1 - y2)*(y1 - y2) + (z1 - z2)*(z1 - z2) &lt;= 4 * r*r &#125;;
&#125;
int find(int a1) &#123;
    return a1==Ma[a1]?a1:(Ma[a1]=find(Ma[a1]));

&#125;
void merge(int a1, int a2) &#123;
    Ma[find(a1)] = find(a2);

&#125;
int main() &#123;
    cin &gt;&gt; t;
    while (t--) &#123;
        memset(a1, 0, sizeof(a1));
        memset(a2, 0, sizeof(a2));
        memset(a3, 0, sizeof(a3));
        cin &gt;&gt; n &gt;&gt; h &gt;&gt; r;
        init();
        for (int i = 1; i &lt;= n; i++) &#123;
            cin &gt;&gt; a1[i] &gt;&gt; a2[i] &gt;&gt; a3[i];
        &#125;
        for (int i = 1; i &lt;= n; i++) &#123;
            if (h - a3[i] &lt;= r) merge(i, n + 1);
            if (a3[i] &lt;= r) merge(i, 0);
        &#125;
        for (int i = 1; i &lt;= n; i++) &#123;
            for (int j = i + 1; j &lt;= n; j++) &#123;
                if (isTangency(a1[i], a2[i], a3[i], a1[j], a2[j], a3[j], r)) &#123;
                    merge(i, j);
                &#125;
            &#125;
        &#125;

        if (find(0) == find(n + 1)) cout &lt;&lt; &quot;Yes&quot;&lt;&lt;endl;
        else cout &lt;&lt; &quot;No&quot;&lt;&lt;endl;
    &#125;
    return 0;
&#125;
</code></pre>
<h1 id="灾后重建"><a href="#灾后重建" class="headerlink" title="灾后重建"></a>灾后重建</h1><h2 id="题目背景-1"><a href="#题目背景-1" class="headerlink" title="题目背景"></a>题目背景</h2><p>B 地区在地震过后，所有村庄都造成了一定的损毁，而这场地震却没对公路造成什么影响。但是在村庄重建好之前，所有与未重建完成的村庄的公路均无法通车。换句话说，只有连接着两个重建完成的村庄的公路才能通车，只能到达重建完成的村庄。</p>
<h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p>给出 B 地区的村庄数 $N$，村庄编号从 $0$ 到 $N-1$，和所有 $M$ 条公路的长度，公路是双向的。并给出第 $i$ 个村庄重建完成的时间 $t_i$，你可以认为是同时开始重建并在第 $t_i$ 天重建完成，并且在当天即可通车。若 $t_i$ 为 $0$ 则说明地震未对此地区造成损坏，一开始就可以通车。之后有 $Q$ 个询问 $(x,y,t)$，对于每个询问你要回答在第 $t$ 天，从村庄 $x$ 到村庄 $y$ 的最短路径长度为多少。如果无法找到从 $x$ 村庄到 $y$ 村庄的路径，经过若干个已重建完成的村庄，或者村庄 $x$ 或村庄 $y$ 在第 $t$ 天仍未重建完成，则需要返回 <code>-1</code>。</p>
<h2 id="输入格式-3"><a href="#输入格式-3" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行包含两个正整数$N,M$，表示了村庄的数目与公路的数量。</p>
<p>第二行包含$N$个非负整数$t_0, t_1,…, t_{N-1}$，表示了每个村庄重建完成的时间，数据保证了$t_0 ≤ t_1 ≤ … ≤ t_{N-1}$。</p>
<p>接下来$M$行，每行$3$个非负整数$i, j, w$，$w$为不超过$10000$的正整数，表示了有一条连接村庄$i$与村庄$j$的道路，长度为$w$，保证$i≠j$，且对于任意一对村庄只会存在一条道路。</p>
<p>接下来一行也就是$M+3$行包含一个正整数$Q$，表示$Q$个询问。</p>
<p>接下来$Q$行，每行$3$个非负整数$x, y, t$，询问在第$t$天，从村庄$x$到村庄$y$的最短路径长度为多少，数据保证了$t$是不下降的。</p>
<h2 id="输出格式-3"><a href="#输出格式-3" class="headerlink" title="输出格式"></a>输出格式</h2><p>共$Q$行，对每一个询问$(x, y, t)$输出对应的答案，即在第$t$天，从村庄$x$到村庄$y$的最短路径长度为多少。如果在第t天无法找到从$x$村庄到$y$村庄的路径，经过若干个已重建完成的村庄，或者村庄x或村庄$y$在第$t$天仍未修复完成，则输出$-1$。</p>
<h2 id="样例-1-3"><a href="#样例-1-3" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-3"><a href="#样例输入-1-3" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">4 5</span><br><span class="line">1 2 3 4</span><br><span class="line">0 2 1</span><br><span class="line">2 3 1</span><br><span class="line">3 1 2</span><br><span class="line">2 1 4</span><br><span class="line">0 3 5</span><br><span class="line">4</span><br><span class="line">2 0 2</span><br><span class="line">0 1 2</span><br><span class="line">0 1 3</span><br><span class="line">0 1 4</span><br></pre></td></tr></table></figure>

<h3 id="样例输出-1-3"><a href="#样例输出-1-3" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-1</span><br><span class="line">-1</span><br><span class="line">5</span><br><span class="line">4</span><br></pre></td></tr></table></figure>

<h2 id="提示-3"><a href="#提示-3" class="headerlink" title="提示"></a>提示</h2><p>对于$30%$的数据，有$N≤50$；</p>
<p>对于$30%$的数据，有$t_i&#x3D; 0$，其中有$20%$的数据有$t_i &#x3D; 0$且$N&gt;50$；</p>
<p>对于$50%$的数据，有$Q≤100$；</p>
<p>对于$100%$的数据，有$N≤200$，$M≤N \times (N-1)&#x2F;2$，$Q≤50000$，所有输入数据涉及整数均不超过$100000$。</p>
<h2 id="Analyse-3"><a href="#Analyse-3" class="headerlink" title="Analyse:"></a>Analyse:</h2><p><strong>正好就是Floyd算法中使用前k个节点更新最短路的思维</strong></p>
<h2 id="Code-3"><a href="#Code-3" class="headerlink" title="Code:"></a>Code:</h2><pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
int a[10001];    
int n,m,ans;
int main()
&#123;
    cin&gt;&gt;n&gt;&gt;m;
    for(int i=1;i&lt;=m;i++)
    &#123;
        int x,y;
        cin&gt;&gt;x&gt;&gt;y;
        a[x]++;
        a[y]++;
    &#125;
    for(int i=1;i&lt;=n;i++)
    &#123;
        if(a[i]%2==1)
              ans++;
    &#125;
    if(ans)
       cout&lt;&lt;ans/2;
    else
       cout&lt;&lt;ans+1;
    return 0;
&#125;
</code></pre>
<h1 id="HAOI2006-聪明的猴子"><a href="#HAOI2006-聪明的猴子" class="headerlink" title="[HAOI2006]聪明的猴子"></a>[HAOI2006]聪明的猴子</h1><h2 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h2><p>在一个热带雨林中生存着一群猴子，它们以树上的果子为生。昨天下了一场大雨，现在雨过天晴，但整个雨林的地表还是被大水淹没着，部分植物的树冠露在水面上。猴子不会游泳，但跳跃能力比较强，它们仍然可以在露出水面的不同树冠上来回穿梭，以找到喜欢吃的果实。</p>
<p>现在，在这个地区露出水面的有N棵树，假设每棵树本身的直径都很小，可以忽略不计。我们在这块区域上建立直角坐标系，则每一棵树的位置由其所对应的坐标表示(任意两棵树的坐标都不相同)。</p>
<p>在这个地区住着的猴子有M个，下雨时，它们都躲到了茂密高大的树冠中，没有被大水冲走。由于各个猴子的年龄不同、身体素质不同，它们跳跃的能力不同。有的猴子跳跃的距离比较远(当然也可以跳到较近的树上)，而有些猴子跳跃的距离就比较近。这些猴子非常聪明，它们通过目测就可以准确地判断出自己能否跳到对面的树上。</p>
<p>【问题】现已知猴子的数量及每一个猴子的最大跳跃距离，还知道露出水面的每一棵树的坐标，你的任务是统计有多少个猴子可以在这个地区露出水面的所有树冠上觅食。</p>
<h2 id="输入格式-4"><a href="#输入格式-4" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入文件monkey.in包括：</p>
<p>第1行为一个整数，表示猴子的个数M(2&lt;&#x3D;M&lt;&#x3D;500)；</p>
<p>第2行为M个整数，依次表示猴子的最大跳跃距离（每个整数值在1–1000之间）；</p>
<p>第3行为一个整数表示树的总棵数N(2&lt;&#x3D;N&lt;&#x3D;1000)；</p>
<p>第4行至第N+3行为N棵树的坐标（横纵坐标均为整数，范围为：-1000–1000）。</p>
<p>（同一行的整数间用空格分开）</p>
<h2 id="输出格式-4"><a href="#输出格式-4" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出文件monkey.out包括一个整数，表示可以在这个地区的所有树冠上觅食的猴子数。</p>
<h2 id="样例-1-4"><a href="#样例-1-4" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-4"><a href="#样例输入-1-4" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line"> 1 2 3 4</span><br><span class="line">6</span><br><span class="line">0 0</span><br><span class="line">1 0</span><br><span class="line">1 2</span><br><span class="line">-1 -1</span><br><span class="line">-2 0</span><br><span class="line">2 2</span><br></pre></td></tr></table></figure>

<h3 id="样例输出-1-4"><a href="#样例输出-1-4" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>

<h2 id="提示-4"><a href="#提示-4" class="headerlink" title="提示"></a>提示</h2><p>【数据规模】</p>
<p>对于40%的数据，保证有2&lt;&#x3D;N &lt;&#x3D;100，1&lt;&#x3D;M&lt;&#x3D;100</p>
<p>对于全部的数据，保证有2&lt;&#x3D;N &lt;&#x3D; 1000，1&lt;&#x3D;M&#x3D;500</p>
<p>感谢@charlie003 修正数据</p>
<h2 id="Analyse-4"><a href="#Analyse-4" class="headerlink" title="Analyse:"></a>Analyse:</h2><h2 id="Code-4"><a href="#Code-4" class="headerlink" title="Code:"></a>Code:</h2><pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
int a[10001];    
int n,m,ans;
int main()
&#123;
    cin&gt;&gt;n&gt;&gt;m;
    for(int i=1;i&lt;=m;i++)
    &#123;
        int x,y;
        cin&gt;&gt;x&gt;&gt;y;
        a[x]++;
        a[y]++;
    &#125;
    for(int i=1;i&lt;=n;i++)
    &#123;
        if(a[i]%2==1)
              ans++;
    &#125;
    if(ans)
       cout&lt;&lt;ans/2;
    else
       cout&lt;&lt;ans+1;
    return 0;
&#125;
</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/01/10/week10/" data-id="clhle1vki0008fgw1ak06bpy9" data-title="week10" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-week9" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/10/week9/" class="article-date">
  <time class="dt-published" datetime="2023-01-10T01:59:58.000Z" itemprop="datePublished">2023-01-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/01/10/week9/">week9</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="【深基18-例3】查找文献"><a href="#【深基18-例3】查找文献" class="headerlink" title="【深基18.例3】查找文献"></a>【深基18.例3】查找文献</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>小K 喜欢翻看洛谷博客获取知识。每篇文章可能会有若干个（也有可能没有）参考文献的链接指向别的博客文章。小K 求知欲旺盛，如果他看了某篇文章，那么他一定会去看这篇文章的参考文献（如果他之前已经看过这篇参考文献的话就不用再看它了）。</p>
<p>假设洛谷博客里面一共有 $n(n\le10^5)$ 篇文章（编号为 1 到 $n$）以及 $m(m\le10^6)$ 条参考文献引用关系。目前小 K 已经打开了编号为 1 的一篇文章，请帮助小 K 设计一种方法，使小 K 可以不重复、不遗漏的看完所有他能看到的文章。</p>
<p>这边是已经整理好的参考文献关系图，其中，文献 X → Y 表示文章 X 有参考文献 Y。不保证编号为 1 的文章没有被其他文章引用。</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/f4n4tlhi.png"></p>
<p>请对这个图分别进行 DFS 和 BFS，并输出遍历结果。如果有很多篇文章可以参阅，请先看编号较小的那篇(因此你可能需要先排序)。</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>共 $m+1$ 行，第 1 行为 2 个数，$n$ 和 $m$，分别表示一共有 $n(n\le10^5)$ 篇文章（编号为 1 到 $n$）以及$m(m\le10^6)$ 条参考文献引用关系。</p>
<p>接下来 $m$ 行，每行有两个整数 $X,Y$ 表示文章 X 有参考文献 Y。</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>共 2 行。<br>第一行为 DFS 遍历结果，第二行为 BFS 遍历结果。</p>
<h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">8 9</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">1 4</span><br><span class="line">2 5</span><br><span class="line">2 6</span><br><span class="line">3 7</span><br><span class="line">4 7</span><br><span class="line">4 8</span><br><span class="line">7 8</span><br></pre></td></tr></table></figure>

<h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 2 5 6 3 7 8 4 </span><br><span class="line">1 2 3 4 5 6 7 8</span><br></pre></td></tr></table></figure>

<h2 id="Analyse"><a href="#Analyse" class="headerlink" title="Analyse:"></a>Analyse:</h2><p>你一张有向图，要你把它深度遍历一遍再广度遍历一遍。</p>
<p>首先我们得明白什么叫DFS和BFS。</p>
<p>DFS，用通俗的话来说，就是你从图的一个结点出发，选择了下一个你需要遍历的结点，然后你再以你所选择的点作为新的起点，继续向下选择，直到你选择的结点没有了下一个结点，或者它所有的子节点都被访问过。</p>
<p><strong>那么此时怎么办呢？</strong></p>
<p>那你就要按照你选择的路径，依次跳回，直到你跳回的节点有了字节点，再进行遍历，以此类推。</p>
<p>BFS，用通俗的话来说，就是你从图中的一个节点出发，其有几个子节点，你会先将这所有的子节点遍历，再挑其中的一个子节点，遍历它的所有子节点，再换到另外一个结点遍历其所有的子节点。这样一层层遍历，以此类推。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h2><pre><code>#include &lt;iostream&gt;
using namespace std;
int main()
&#123;
    const int A = 1e4 + 5;
    int a[A], b[A], c[A], e[1005];
    int x1, x2, x3, x4, n, m;
    char a1, a2;
    cin &gt;&gt; x1 &gt;&gt; a1 &gt;&gt; x2 &gt;&gt; x3 &gt;&gt; a2 &gt;&gt; x4 &gt;&gt; n;
    m = (x3 - x1) * 60 + x4 - x2;
    for (int i = 1; i &lt;= n; i++)
    &#123;
        cin &gt;&gt; a[i] &gt;&gt; b[i] &gt;&gt; c[i];
        if (c[i] == 0)
            c[i] = 1e9;
    &#125;

    for(int i=1;i&lt;=n;i++)
        for (int j = m; j &gt;= a[i]; j--)
        &#123;
            if (a[i] == 0)
            &#123;
                for (int p = 1; p &lt;= m; p++)
                    e[p] += b[i] * c[i];
                break;
            &#125;
            else
            &#123;
                for (int t = 1; t &lt;= c[i] &amp;&amp; j &gt;= a[i] * t; t++)
                    e[j] = max(e[j], e[j - a[i] * t] + b[i] * t);
            &#125;
        &#125;
    cout &lt;&lt; e[m];
    return 0;
&#125;
</code></pre>
<h1 id="【模板】floyd"><a href="#【模板】floyd" class="headerlink" title="【模板】floyd"></a>【模板】floyd</h1><h2 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h2><p>模板题，无背景</p>
<h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>给出n个点，m条边的无向图，求每个点到其他点的距离之和%998244354的值</p>
<h2 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行两个数n，m含义如上<br>从第二行开始，共m行，每行三个数x，y，l，代表从x到y点的长度为l</p>
<h2 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h2><p>n行，每行一个数，第i行代表点i到其他点的距离之和</p>
<h2 id="样例-1-1"><a href="#样例-1-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-1"><a href="#样例输入-1-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2 1</span><br><span class="line">1 2 4</span><br></pre></td></tr></table></figure>

<h3 id="样例输出-1-1"><a href="#样例输出-1-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">4</span><br></pre></td></tr></table></figure>

<h2 id="样例-2"><a href="#样例-2" class="headerlink" title="样例 #2"></a>样例 #2</h2><h3 id="样例输入-2"><a href="#样例输入-2" class="headerlink" title="样例输入 #2"></a>样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">4 5</span><br><span class="line">1 2 1</span><br><span class="line">1 3 2</span><br><span class="line">2 3 2</span><br><span class="line">3 4 3</span><br><span class="line">2 4 4</span><br></pre></td></tr></table></figure>

<h3 id="样例输出-2"><a href="#样例输出-2" class="headerlink" title="样例输出 #2"></a>样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">8</span><br><span class="line">7</span><br><span class="line">7</span><br><span class="line">12</span><br></pre></td></tr></table></figure>

<h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p>模板题，保证图联通<br>n&lt;&#x3D;500<br>m&lt;&#x3D;10000<br>1&lt;&#x3D;x,y&lt;&#x3D;n<br>l&lt;&#x3D;1e9</p>
<p>Code:</p>
<pre><code>#include &lt;iostream&gt;
using namespace std;
int main()
&#123;
    const int A = 1e4 + 5;
    int a[A], b[A], c[A], e[1005];
    int x1, x2, x3, x4, n, m;
    char a1, a2;
    cin &gt;&gt; x1 &gt;&gt; a1 &gt;&gt; x2 &gt;&gt; x3 &gt;&gt; a2 &gt;&gt; x4 &gt;&gt; n;
    m = (x3 - x1) * 60 + x4 - x2;
    for (int i = 1; i &lt;= n; i++)
    &#123;
        cin &gt;&gt; a[i] &gt;&gt; b[i] &gt;&gt; c[i];
        if (c[i] == 0)
            c[i] = 1e9;
    &#125;

    for(int i=1;i&lt;=n;i++)
        for (int j = m; j &gt;= a[i]; j--)
        &#123;
            if (a[i] == 0)
            &#123;
                for (int p = 1; p &lt;= m; p++)
                    e[p] += b[i] * c[i];
                break;
            &#125;
            else
            &#123;
                for (int t = 1; t &lt;= c[i] &amp;&amp; j &gt;= a[i] * t; t++)
                    e[j] = max(e[j], e[j - a[i] * t] + b[i] * t);
            &#125;
        &#125;
    cout &lt;&lt; e[m];
    return 0;
&#125;
</code></pre>
<h1 id="【模板】单源最短路径（标准版）"><a href="#【模板】单源最短路径（标准版）" class="headerlink" title="【模板】单源最短路径（标准版）"></a>【模板】单源最短路径（标准版）</h1><h2 id="题目背景-1"><a href="#题目背景-1" class="headerlink" title="题目背景"></a>题目背景</h2><p>2018 年 7 月 19 日，某位同学在 <a target="_blank" rel="noopener" href="https://www.luogu.org/problemnew/show/P4768">NOI Day 1 T1 归程</a> 一题里非常熟练地使用了一个广为人知的算法求最短路。</p>
<p>然后呢？</p>
<p>$100 \rightarrow 60$；</p>
<p>$\text{Ag} \rightarrow \text{Cu}$；</p>
<p>最终，他因此没能与理想的大学达成契约。</p>
<p>小 F 衷心祝愿大家不再重蹈覆辙。</p>
<h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个 $n$ 个点，$m$ 条有向边的带非负权图，请你计算从 $s$ 出发，到每个点的距离。</p>
<p>数据保证你能从 $s$ 出发到任意点。</p>
<h2 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行为三个正整数 $n, m, s$。<br>第二行起 $m$ 行，每行三个非负整数 $u_i, v_i, w_i$，表示从 $u_i$ 到 $v_i$ 有一条权值为 $w_i$ 的有向边。</p>
<h2 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一行 $n$ 个空格分隔的非负整数，表示 $s$ 到每个点的距离。</p>
<h2 id="样例-1-2"><a href="#样例-1-2" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-2"><a href="#样例输入-1-2" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">4 6 1</span><br><span class="line">1 2 2</span><br><span class="line">2 3 2</span><br><span class="line">2 4 1</span><br><span class="line">1 3 5</span><br><span class="line">3 4 3</span><br><span class="line">1 4 4</span><br></pre></td></tr></table></figure>

<h3 id="样例输出-1-2"><a href="#样例输出-1-2" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 2 4 3</span><br></pre></td></tr></table></figure>

<h2 id="提示-1"><a href="#提示-1" class="headerlink" title="提示"></a>提示</h2><p>样例解释请参考 <a target="_blank" rel="noopener" href="https://www.luogu.org/problemnew/show/P3371">数据随机的模板题</a>。</p>
<p>$1 \leq n \leq 10^5$；</p>
<p>$1 \leq m \leq 2\times 10^5$；</p>
<p>$s &#x3D; 1$；</p>
<p>$1 \leq u_i, v_i\leq n$；</p>
<p>$0 \leq w_i \leq 10 ^ 9$,</p>
<p>$0 \leq \sum w_i \leq 10 ^ 9$。</p>
<p>本题数据可能会持续更新，但不会重测，望周知。</p>
<p>2018.09.04 数据更新 from @zzq</p>
<h2 id="Analyse-1"><a href="#Analyse-1" class="headerlink" title="Analyse:"></a>Analyse:</h2><h3 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h3><ul>
<li>(令start&#x3D;1)</li>
<li>开始时我们把dis[start]初始化为0,其余点初始化为inf <img src="https://i.loli.net/2018/07/25/5b583277e47e9.png" alt="初始化"></li>
<li>第一轮循环找到dis值最小的点1,将1变成白点,对所有与1相连的蓝点的dis值进行修改,使得dis[2]&#x3D;2,dis[3]&#x3D;4,dis[4]&#x3D;7 <img src="https://i.loli.net/2018/07/25/5b58347b9a37b.png" alt="1"></li>
<li>第二轮循环找到dis值最小的点2,将2变成白点,对所有与2相连的蓝点的dis值进行修改,使得dis[3]&#x3D;3,dis[5]&#x3D;4 <img src="https://i.loli.net/2018/07/25/5b586fa8de335.png" alt="2"></li>
<li>第三轮循环找到dis值最小的点3,将3变成白点,对所有与2相连的蓝点的dis值进行修改,使得dis[4]&#x3D;4 <img src="https://i.loli.net/2018/07/25/5b58703e8d0d6.png" alt="3"></li>
<li>接下来两轮循环分别将4,5设为白点,算法结束,求出所有点的最短路径</li>
<li>时间复杂度O(n2)</li>
</ul>
<h3 id="为什么dijkstra不能处理有负权边的情况"><a href="#为什么dijkstra不能处理有负权边的情况" class="headerlink" title="为什么dijkstra不能处理有负权边的情况?"></a>为什么dijkstra不能处理有负权边的情况?</h3><ul>
<li>我们来看下面这张图 <img src="https://i.loli.net/2018/07/25/5b58724845b8d.png" alt="4"></li>
<li>2到3的边权为−4,显然从1到3的最短路径为−2 (1−&gt;2−&gt;3).但在循环开始时程序会找到当前dis值最小的点3,并标记它为白点.</li>
<li>这时的dis[3]&#x3D;1,然而1并不是起点到3的最短路径.因为3已经被标为白点,所以dis[3]不会再被修改了.我们在边权存在负数的情况下得到了错误的答案.</li>
</ul>
<h3 id="什么是dijkstra"><a href="#什么是dijkstra" class="headerlink" title="什么是dijkstra?"></a>什么是dijkstra?</h3><ul>
<li><p>dijkstra是一种单源最短路径算法,时间复杂度上限为O(n2)(朴素),在实际应用中较为稳定;加上堆优化之后更是具有O((n+m)log2​n)的时间复杂度,在稠密图中有不俗的表现.</p>
<p>1.这道题利用里vector建立<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E9%82%BB%E6%8E%A5%E8%A1%A8&spm=1001.2101.3001.7020">邻接表</a>。</p>
<p>2.运用<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97&spm=1001.2101.3001.7020">优先队列</a>重载运算符。</p>
<p>3.用的dijkstra算法的思想。</p>
<p>4.运用vis数组进行标记。</p>
<p>5.运用队列进行回溯。</p>
</li>
</ul>
<h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code:"></a>Code:</h2><pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
#define INF 2147483647
#define P pair&lt;long long , int&gt; 
int n, m, s, cnt, a3[100010], a1[100010], a2[100010];
class node
&#123;
public:
    int to, next, w;
&#125;E[200010];

priority_queue&lt;P, vector&lt;P&gt;, greater&lt;P&gt; &gt;a;
void add(int u, int v, int w)
&#123;
    E[++cnt].w = w;
    E[cnt].to = v;
    E[cnt].next = a3[u];
    a3[u] = cnt;
&#125;
void dijkstra()
&#123;
    for (int i = 1; i &lt;= n; i++)
        a1[i] = INF;
    a1[s] = 0;
    a.push(make_pair(0, s));
    while (!a.empty())
    &#123;
        int x = a.top().second;
        a.pop();
        if (!a2[x])
        &#123;
            a2[x] = 1;



            for (int i = a3[x]; i; i = E[i].next)
                if (a1[E[i].to] &gt; a1[x] + E[i].w)
                &#123;
                    a1[E[i].to] = a1[x] + E[i].w;
                    a.push(make_pair(a1[E[i].to], E[i].to));
                &#125;
        &#125;
    &#125;
&#125;
int main()
&#123;
    int i;
    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;
    i=m;
    while(i&gt;=1)&#123;
        int u, v, w;
        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;
        add(u, v, w);
        i--;
    &#125;
    i=1;
    dijkstra();
    while(i&lt;=n)&#123;
        cout &lt;&lt; a1[i]&lt;&lt;&quot; &quot;;
        i++;
    &#125;

    return 0;
&#125;
</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/01/10/week9/" data-id="clhle1vkl000efgw13679dvbe" data-title="week9" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-week8" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/09/week8/" class="article-date">
  <time class="dt-published" datetime="2023-01-09T15:06:05.000Z" itemprop="datePublished">2023-01-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/01/09/week8/">week8</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <pre><code>title: Test 7
date: 2022-12-19 20:14:51
tags:
</code></pre>
<p>This is the 8th week.</p>
<h3 id="樱花"><a href="#樱花" class="headerlink" title="# 樱花"></a># 樱花</h3><h2 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h2><p>《爱与愁的故事第四弹·plant》第一章。</p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>爱与愁大神后院里种了 $n$ 棵樱花树，每棵都有美学值 $C_i(0 \le C_i \le 200)$。爱与愁大神在每天上学前都会来赏花。爱与愁大神可是生物学霸，他懂得如何欣赏樱花：一种樱花树看一遍过，一种樱花树最多看 $A_i(0 \le A_i \le 100)$ 遍，一种樱花树可以看无数遍。但是看每棵樱花树都有一定的时间 $T_i(0 \le T_i \le 100)$。爱与愁大神离去上学的时间只剩下一小会儿了。求解看哪几棵樱花树能使美学值最高且爱与愁大神能准时（或提早）去上学。</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>共 $n+1$行：</p>
<p>第 $1$ 行：现在时间 $T_s$（几时：几分），去上学的时间 $T_e$（几时：几分），爱与愁大神院子里有几棵樱花树 $n$。这里的 $T_s$，$T_e$ 格式为：<code>hh:mm</code>，其中 $0 \leq hh \leq 23$，$0 \leq mm \leq 59$，且 $hh,mm,n$ 均为正整数。</p>
<p>第 $2$ 行到第 $n+1$ 行，每行三个正整数：看完第 $i$ 棵树的耗费时间 $T_i$，第 $i$ 棵树的美学值 $C_i$，看第 $i$ 棵树的次数 $P_i$（$P_i&#x3D;0$ 表示无数次，$P_i$ 是其他数字表示最多可看的次数 $P_i$）。</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>只有一个整数，表示最大美学值。</p>
<h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">6:50 7:00 3</span><br><span class="line">2 1 0</span><br><span class="line">3 3 1</span><br><span class="line">4 5 4</span><br></pre></td></tr></table></figure>

<h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">11</span><br></pre></td></tr></table></figure>

<h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p>$100%$ 数据：$T_e-T_s \leq 1000$（即开始时间距离结束时间不超过 $1000$ 分钟），$n \leq 10000$。保证 $T_e,T_s$ 为同一天内的时间。</p>
<p>样例解释：赏第一棵樱花树一次，赏第三棵樱花树 $2$ 次。</p>
<h3 id="Analyse："><a href="#Analyse：" class="headerlink" title="Analyse："></a>Analyse：</h3><p><a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98&spm=1001.2101.3001.7020">背包问题</a></p>
<p><strong>很清晰看到樱花树可以看得次数有三种，一次，多次，无数次，很显然这是一道混合背包的裸题，要用到二进制优化。</strong></p>
<p>这是一道混合背包板子题。使用二进制对数量有限且不为1的物品进行分割，化归为数量为1的物品。然后依据物品数为1或无限，分别按照0&#x2F;1背包、完全背包进行处理。0&#x2F;1背包、完全背包具体步骤</p>
<pre><code>#include &lt;iostream&gt;
using namespace std;
int main()
&#123;
    const int A = 1e4 + 5;
    int a[A], b[A], c[A], e[1005];
    int x1, x2, x3, x4, n, m;
    char a1, a2;
    cin &gt;&gt; x1 &gt;&gt; a1 &gt;&gt; x2 &gt;&gt; x3 &gt;&gt; a2 &gt;&gt; x4 &gt;&gt; n;
    m = (x3 - x1) * 60 + x4 - x2;
    for (int i = 1; i &lt;= n; i++)
    &#123;
        cin &gt;&gt; a[i] &gt;&gt; b[i] &gt;&gt; c[i];
        if (c[i] == 0)
            c[i] = 1e9;
    &#125;

    for(int i=1;i&lt;=n;i++)
        for (int j = m; j &gt;= a[i]; j--)
        &#123;
            if (a[i] == 0)
            &#123;
                for (int p = 1; p &lt;= m; p++)
                    e[p] += b[i] * c[i];
                break;
            &#125;
            else
            &#123;
                for (int t = 1; t &lt;= c[i] &amp;&amp; j &gt;= a[i] * t; t++)
                    e[j] = max(e[j], e[j - a[i] * t] + b[i] * t);
            &#125;
        &#125;
    cout &lt;&lt; e[m];
    return 0;
&#125;
</code></pre>
<h1 id="疯狂的采药"><a href="#疯狂的采药" class="headerlink" title="疯狂的采药"></a>疯狂的采药</h1><h2 id="题目背景-1"><a href="#题目背景-1" class="headerlink" title="题目背景"></a>题目背景</h2><p>此题为纪念 LiYuxiang 而生。</p>
<h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>LiYuxiang 是个天资聪颖的孩子，他的梦想是成为世界上最伟大的医师。为此，他想拜附近最有威望的医师为师。医师为了判断他的资质，给他出了一个难题。医师把他带到一个到处都是草药的山洞里对他说：“孩子，这个山洞里有一些不同种类的草药，采每一种都需要一些时间，每一种也有它自身的价值。我会给你一段时间，在这段时间里，你可以采到一些草药。如果你是一个聪明的孩子，你应该可以让采到的草药的总价值最大。”</p>
<p>如果你是 LiYuxiang，你能完成这个任务吗？</p>
<p>此题和原题的不同点：</p>
<p>$1$. 每种草药可以无限制地疯狂采摘。</p>
<p>$2$. 药的种类眼花缭乱，采药时间好长好长啊！师傅等得菊花都谢了！</p>
<h2 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入第一行有两个整数，分别代表总共能够用来采药的时间 $t$ 和代表山洞里的草药的数目 $m$。</p>
<p>第 $2$ 到第 $(m + 1)$ 行，每行两个整数，第 $(i + 1)$ 行的整数 $a_i, b_i$ 分别表示采摘第 $i$ 种草药的时间和该草药的价值。</p>
<h2 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一行，这一行只包含一个整数，表示在规定的时间内，可以采到的草药的最大总价值。</p>
<h2 id="样例-1-1"><a href="#样例-1-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-1"><a href="#样例输入-1-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">70 3</span><br><span class="line">71 100</span><br><span class="line">69 1</span><br><span class="line">1 2</span><br></pre></td></tr></table></figure>

<h3 id="样例输出-1-1"><a href="#样例输出-1-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">140</span><br></pre></td></tr></table></figure>

<h2 id="提示-1"><a href="#提示-1" class="headerlink" title="提示"></a>提示</h2><h4 id="数据规模与约定"><a href="#数据规模与约定" class="headerlink" title="数据规模与约定"></a>数据规模与约定</h4><ul>
<li>对于 $30%$ 的数据，保证 $m \le 10^3$ 。</li>
<li>对于 $100%$ 的数据，保证 $1 \leq m \le 10^4$，$1 \leq t \leq 10^7$，且 $1 \leq m \times t \leq 10^7$，$1 \leq a_i, b_i \leq 10^4$。</li>
</ul>
<h3 id="Analyse：-1"><a href="#Analyse：-1" class="headerlink" title="Analyse："></a>Analyse：</h3><ol>
<li><p>假设只有一惟 fi​，如果是倒序推那么当前 f1​ ~ fi−1​ 都是上一个草药遗留下来的状态，显然不符合要求。</p>
<p>正序推的话 f1​ ~ fi−1​ 均为当前草药已经推过的状态，符合要求。</p>
<p>所以完全背包和 01 背包的区别就在于对时间大小枚举的顺序不同。</p>
<p>本题最多有 107 时间，每种草药的价值最大是 104，所以极限情况下价值总和是 107×104&#x3D;1011，会爆 int，所以要开 long long</p>
</li>
</ol>
<h3 id="My-Code"><a href="#My-Code" class="headerlink" title="My Code:"></a>My Code:</h3><pre><code>#include &lt;iostream&gt;
using namespace std;
const int a1 = 1e7 + 10, a2 = 1e4 + 10;
int main() &#123;
    int a[a2], b[a2],n, m;
    long c[a1];
    scanf(&quot;%d%d&quot;, &amp;m, &amp;n);
    for (int i = 1; i &lt;= n; i++)
        cin&gt;&gt;a[i]&gt;&gt;b[i];

    for (int i = 1; i &lt;= n; i++)
        for (int j = a[i]; j &lt;= m; j++)
            c[j] = max(c[j], c[j - a[i]] + b[i]);

    cout&lt;&lt;c[m];

    return 0;
&#125;
</code></pre>
<h1 id="NOIP2012-普及组-摆花"><a href="#NOIP2012-普及组-摆花" class="headerlink" title="# [NOIP2012 普及组] 摆花"></a># [NOIP2012 普及组] 摆花</h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>小明的花店新开张，为了吸引顾客，他想在花店的门口摆上一排花，共 $m$ 盆。通过调查顾客的喜好，小明列出了顾客最喜欢的 $n$ 种花，从 $1$ 到 $n$ 标号。为了在门口展出更多种花，规定第 $i$ 种花不能超过 $a_i$ 盆，摆花时同一种花放在一起，且不同种类的花需按标号的从小到大的顺序依次摆列。</p>
<p>试编程计算，一共有多少种不同的摆花方案。</p>
<h2 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行包含两个正整数 $n$ 和 $m$，中间用一个空格隔开。</p>
<p>第二行有 $n$ 个整数，每两个整数之间用一个空格隔开，依次表示 $a_1,a_2, \cdots ,a_n$。</p>
<h2 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式"></a>输出格式</h2><p>一个整数，表示有多少种方案。注意：因为方案数可能很多，请输出方案数对 $10^6+7$ 取模的结果。</p>
<h2 id="样例-1-2"><a href="#样例-1-2" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-2"><a href="#样例输入-1-2" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2 4</span><br><span class="line">3 2</span><br></pre></td></tr></table></figure>

<h3 id="样例输出-1-2"><a href="#样例输出-1-2" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure>

<h2 id="提示-2"><a href="#提示-2" class="headerlink" title="提示"></a>提示</h2><p>【数据范围】</p>
<p>对于 $20%$ 数据，有 $0&lt;n \le 8,0&lt;m \le 8,0 \le a_i \le 8$。</p>
<p>对于 $50%$ 数据，有 $0&lt;n \le 20,0&lt;m \le 20,0 \le a_i \le 20$。</p>
<p>对于 $100%$ 数据，有 $0&lt;n \le 100,0&lt;m \le 100,0 \le a_i \le 100$。</p>
<p>NOIP 2012 普及组 第三题</p>
<h3 id="Analyse：-2"><a href="#Analyse：-2" class="headerlink" title="Analyse："></a>Analyse：</h3><p>这道题的价值在于，它既可以从简单的动态规划开始，一路优化，也可以从生成函数的视角观察，继续优化。</p>
<p>从这个题我才知道DP并不是全都有max,min函数的啊，DP的核心其实是从上一层的最优解推下一层的最优解，但这个题的最优即所有方案加起来的和，所以这个题没有取max,min。</p>
<h3 id="My-Code-1"><a href="#My-Code-1" class="headerlink" title="My Code:"></a>My Code:</h3><pre><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
#define B 1000007;
int n,m;            
int A[10010];
int a[1100][1100]; 
int main()
&#123;
    cin&gt;&gt;n&gt;&gt;m;
    for(int i=1;i&lt;=n;i++) cin&gt;&gt;A[i];
    for(int i=0;i&lt;=A[1];i++) a[1][i] = 1;
    
    for(int i=1;i&lt;=n;i++) a[i][0] = 1;
    
    for(int i=2;i&lt;=n;i++)
        for(int j=1;j&lt;=m;j++)
            for(int k=0;k&lt;=A[i] &amp;&amp; k&lt;=j;k++)
                a[i][j] = (a[i][j]+a[i-1][j-k])%B;
                
    cout&lt;&lt;a[n][m];
    return 0;			
                 
&#125; 
</code></pre>
<h1 id="NOIP2006-提高组-金明的预算方案"><a href="#NOIP2006-提高组-金明的预算方案" class="headerlink" title="[NOIP2006 提高组] 金明的预算方案"></a>[NOIP2006 提高组] 金明的预算方案</h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p>金明今天很开心，家里购置的新房就要领钥匙了，新房里有一间金明自己专用的很宽敞的房间。更让他高兴的是，妈妈昨天对他说：“你的房间需要购买哪些物品，怎么布置，你说了算，只要不超过 $n$ 元钱就行”。今天一早，金明就开始做预算了，他把想买的物品分为两类：主件与附件，附件是从属于某个主件的，下表就是一些主件与附件的例子：</p>
<table>
<thead>
<tr>
<th align="center">主件</th>
<th align="center">附件</th>
</tr>
</thead>
<tbody><tr>
<td align="center">电脑</td>
<td align="center">打印机，扫描仪</td>
</tr>
<tr>
<td align="center">书柜</td>
<td align="center">图书</td>
</tr>
<tr>
<td align="center">书桌</td>
<td align="center">台灯，文具</td>
</tr>
<tr>
<td align="center">工作椅</td>
<td align="center">无</td>
</tr>
</tbody></table>
<p>如果要买归类为附件的物品，必须先买该附件所属的主件。每个主件可以有 $0$ 个、$1$ 个或 $2$ 个附件。每个附件对应一个主件，附件不再有从属于自己的附件。金明想买的东西很多，肯定会超过妈妈限定的 $n$ 元。于是，他把每件物品规定了一个重要度，分为 $5$ 等：用整数 $1 \sim 5$ 表示，第 $5$ 等最重要。他还从因特网上查到了每件物品的价格（都是 $10$ 元的整数倍）。他希望在不超过 $n$ 元的前提下，使每件物品的价格与重要度的乘积的总和最大。</p>
<p>设第 $j$ 件物品的价格为 $v_j$，重要度为$w_j$，共选中了 $k$ 件物品，编号依次为 $j_1,j_2,\dots,j_k$，则所求的总和为：</p>
<p>$v_{j_1} \times w_{j_1}+v_{j_2} \times w_{j_2}+ \dots +v_{j_k} \times w_{j_k}$。</p>
<p>请你帮助金明设计一个满足要求的购物单。</p>
<h2 id="输入格式-3"><a href="#输入格式-3" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行有两个整数，分别表示总钱数 $n$ 和希望购买的物品个数 $m$。</p>
<p>第 $2$ 到第 $(m + 1)$ 行，每行三个整数，第 $(i + 1)$ 行的整数 $v_i$，$p_i$，$q_i$ 分别表示第 $i$ 件物品的价格、重要度以及它对应的的主件。如果 $q_i&#x3D;0$，表示该物品本身是主件。</p>
<h2 id="输出格式-3"><a href="#输出格式-3" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一行一个整数表示答案。</p>
<h2 id="样例-1-3"><a href="#样例-1-3" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-3"><a href="#样例输入-1-3" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1000 5</span><br><span class="line">800 2 0</span><br><span class="line">400 5 1</span><br><span class="line">300 5 1</span><br><span class="line">400 3 0</span><br><span class="line">500 2 0</span><br></pre></td></tr></table></figure>

<h3 id="样例输出-1-3"><a href="#样例输出-1-3" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2200</span><br></pre></td></tr></table></figure>

<h2 id="提示-3"><a href="#提示-3" class="headerlink" title="提示"></a>提示</h2><h4 id="数据规模与约定-1"><a href="#数据规模与约定-1" class="headerlink" title="数据规模与约定"></a>数据规模与约定</h4><p>对于全部的测试点，保证 $1 \leq n \leq 3.2 \times 10^4$，$1 \leq m \leq 60$，$0 \leq v_i \leq 10^4$，$1 \leq p_i \leq 5$，$0 \leq q_i \leq m$，答案不超过 $2 \times 10^5$。</p>
<h3 id="Analyse：-3"><a href="#Analyse：-3" class="headerlink" title="Analyse："></a>Analyse：</h3><ol>
<li><ul>
<li><p>我们可以对主件i的“附件集合”先进行一次01背包，得到费用依次为0..V-c[i]。所有这些值时相应的最大价值f’[0..V-c[i]]。</p>
</li>
<li><p>那么这个主件及它的附件集合相当于V-c[i]+1个物品的物品组，其中费用为c[i]+k的物品的价值为f’[k]+w[i]。也就是说原来指数级的策略中有很多策略都是冗余的，通过一次01背包后，将主件i转化为V-c[i]+1个物品的物品组，就可以直接解决问题了。</p>
</li>
</ul>
</li>
</ol>
<h3 id="My-Code-2"><a href="#My-Code-2" class="headerlink" title="My Code:"></a>My Code:</h3><pre><code>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
using namespace std;
int n,m,x,y,id,f2[60][3201],num[60],t1;
struct node&#123;
    int v,c,d1,d2,c1,c2;
&#125;a[51];
int re()
&#123;
    int a=0,f=1;
    char ch=getchar();
    while(ch&lt;&#39;0&#39; || ch&gt;&#39;9&#39;) &#123;
        if(ch==&#39;-&#39;) f=-1;ch=getchar();
        &#125;
    while(ch&gt;=&#39;0&#39; &amp;&amp; ch&lt;=&#39;9&#39;) &#123;
        a=(a&lt;&lt;1)+(a&lt;&lt;3)+ch-&#39;0&#39;;ch=getchar();
        &#125;
    return a*f;
&#125;
int main()
&#123;
    n=re()/10;m=re();
    for(int i=1;i&lt;=m;i++)
    &#123;
        x=re()/10;
        y=re()*x;
        id=re();
        if(id)
        &#123;
            id=num[id];
            if(a[id].d1) a[id].d2=y,a[id].c2=x;
            else a[id].d1=y,a[id].c1=x;
        &#125;
        else a[++t1].c=x,a[t1].v=y,num[i]=t1;
    &#125;
    m=t1;
    for(int i=1;i&lt;=m;i++)
      for(int j=n;j;j--)
      &#123;
      	f2[i][j]=f2[i-1][j];
      	if(j&gt;=a[i].c) f2[i][j]=max(f2[i][j],f2[i-1][j-a[i].c]+a[i].v);
      	if(j&gt;=a[i].c+a[i].c1) f2[i][j]=max(f2[i][j],f2[i-1][j-a[i].c-a[i].c1]+a[i].v+a[i].d1);
      	if(j&gt;=a[i].c+a[i].c2) f2[i][j]=max(f2[i][j],f2[i-1][j-a[i].c-a[i].c2]+a[i].v+a[i].d2);
      	if(j&gt;=a[i].c+a[i].c1+a[i].c2) f2[i][j]=max(f2[i][j],f2[i-1][j-a[i].c-a[i].c1-a[i].c2]+a[i].v+a[i].d1+a[i].d2);
      &#125;
    cout&lt;&lt;f2[m][n]*10;
    
    return 0;
&#125;
</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/01/09/week8/" data-id="clhle1vkm000gfgw147nmgep2" data-title="week8" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Test-7" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/12/19/Test-7/" class="article-date">
  <time class="dt-published" datetime="2022-12-19T12:14:51.000Z" itemprop="datePublished">2022-12-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/12/19/Test-7/">Test 7</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>This is the 7th week.</p>
<h3 id="NOIP2005-普及组-采药"><a href="#NOIP2005-普及组-采药" class="headerlink" title="[NOIP2005 普及组] 采药"></a>[NOIP2005 普及组] 采药</h3><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>辰辰是个天资聪颖的孩子，他的梦想是成为世界上最伟大的医师。为此，他想拜附近最有威望的医师为师。医师为了判断他的资质，给他出了一个难题。医师把他带到一个到处都是草药的山洞里对他说：“孩子，这个山洞里有一些不同的草药，采每一株都需要一些时间，每一株也有它自身的价值。我会给你一段时间，在这段时间里，你可以采到一些草药。如果你是一个聪明的孩子，你应该可以让采到的草药的总价值最大。”</p>
<p>如果你是辰辰，你能完成这个任务吗？</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行有 $2$ 个整数 $T$（$1 \le T \le 1000$）和 $M$（$1 \le  M \le 100$），用一个空格隔开，$T$ 代表总共能够用来采药的时间，$M$ 代表山洞里的草药的数目。</p>
<p>接下来的 $M$ 行每行包括两个在 $1$ 到 $100$ 之间（包括 $1$ 和 $100$）的整数，分别表示采摘某株草药的时间和这株草药的价值。</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出在规定的时间内可以采到的草药的最大总价值。</p>
<h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">70 3</span><br><span class="line">71 100</span><br><span class="line">69 1</span><br><span class="line">1 2</span><br></pre></td></tr></table></figure>

<h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>

<h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p><strong>【数据范围】</strong></p>
<ul>
<li>对于 $30%$ 的数据，$M \le 10$；</li>
<li>对于全部的数据，$M \le 100$。</li>
</ul>
<p><strong>【题目来源】</strong></p>
<p>NOIP 2005 普及组第三题</p>
<h3 id="Analyse："><a href="#Analyse：" class="headerlink" title="Analyse："></a>Analyse：</h3><p>所以我们就可以不用记下草药的序号，只需要留下采药所需的时间就行，至于该不该采药，在自己的基础上进行判断就行。</p>
<p>则建立一个数组dp[1000];</p>
<p>递推公式同二维数组非常相似，只是删掉了表示序号的那维数组</p>
<h3 id="My-Code"><a href="#My-Code" class="headerlink" title="My Code:"></a>My Code:</h3><pre><code>#include&lt;iostream&gt;
using namespace std;
int A[1001],w[1001],C[1001];
int main()&#123;
    int t,m;
    cin&gt;&gt;t&gt;&gt;m;
    for(int i=1;i&lt;=m;i++)&#123;
        cin&gt;&gt;w[i]&gt;&gt;C[i];
    &#125; 
    for(int i=1;i&lt;=m;i++)
    for(int j=t;j&gt;=0;j--)&#123;
        if(j&gt;=w[i])&#123;
            A[j]=max(A[j-w[i]]+C[i],A[j]);
        &#125;
    &#125;
    cout&lt;&lt;A[t];
&#125;
</code></pre>
<p>模拟与高精度</p>
<p>This is the 4th week.</p>
<h2 id="最长上升子序列"><a href="#最长上升子序列" class="headerlink" title="# 最长上升子序列"></a># 最长上升子序列</h2><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>这是一个简单的动规板子题。</p>
<p>给出一个由 $n(n\le 5000)$ 个不超过 $10^6$ 的正整数组成的序列。请输出这个序列的<strong>最长上升子序列</strong>的长度。</p>
<p>最长上升子序列是指，从原序列中<strong>按顺序</strong>取出一些数字排在一起，这些数字是<strong>逐渐增大</strong>的。</p>
<h2 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行，一个整数 $n$，表示序列长度。</p>
<p>第二行有 $n$ 个整数，表示这个序列。</p>
<h2 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h2><p>一个整数表示答案。</p>
<h2 id="样例-1-1"><a href="#样例-1-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-1"><a href="#样例输入-1-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">6</span><br><span class="line">1 2 4 1 3 4</span><br></pre></td></tr></table></figure>

<h3 id="样例输出-1-1"><a href="#样例输出-1-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure>

<h2 id="提示-1"><a href="#提示-1" class="headerlink" title="提示"></a>提示</h2><p>分别取出 $1$、$2$、$3$、$4$ 即可。](<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1605">https://www.luogu.com.cn/problem/P1605</a>)</p>
<h3 id="Analyse：-1"><a href="#Analyse：-1" class="headerlink" title="Analyse："></a>Analyse：</h3><ol>
<li><p>算法实现</p>
<p>通过构造q[]，求出最长严格单调递增子序列的长度len：</p>
<ol>
<li><p>遍历序列中的每个数a[i]</p>
</li>
<li><p>如果a[i]&gt;q[len]，q[++len]&#x3D;a[i]</p>
</li>
<li><p>否则在q[]数组中找到第一个大于等于a[i]的数，将其更新为a[i]</p>
</li>
</ol>
</li>
</ol>
<h3 id="My-Code-1"><a href="#My-Code-1" class="headerlink" title="My Code:"></a>My Code:</h3><pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long ll;
const ll mmax=1e6+10;
ll a[mmax],lis[mmax];
ll len; 
ll find(ll x)
&#123;
     ll l=0,r=len;
     while(l&lt;r)
     &#123;
          ll mid=(l+r)&gt;&gt;1;
          if(lis[mid]&gt;=x)
          	 r=mid;
          else
           	l=mid+1;
    &#125;
     return l;
&#125;
int main()
&#123;
     ll n;
     memset(a,0,sizeof(a));
     memset(lis,0,sizeof(lis));
     cin&gt;&gt;n;
     for(int i=0;i&lt;n;i++)
      	cin&gt;&gt;a[i]; 
     lis[0]=a[0];
     len=0;
     for(int i=1;i&lt;n;i++)
     &#123;
          if(a[i]&gt;lis[len])
          &#123;
           	lis[++len]=a[i]; 
          &#125;
          else
          &#123;
           	ll k=find(a[i]);
           	lis[k]=a[i];
          &#125; 
    &#125; 
    cout&lt;&lt;len+1&lt;&lt;endl;
     return 0;
&#125; 
</code></pre>
<h1 id="最大子段和"><a href="#最大子段和" class="headerlink" title="最大子段和"></a>最大子段和</h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>给出一个长度为 $n$ 的序列 $a$，选出其中连续且非空的一段使得这段和最大。</p>
<h2 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行是一个整数，表示序列的长度 $n$。</p>
<p>第二行有 $n$ 个整数，第 $i$ 个整数表示序列的第 $i$ 个数字 $a_i$。</p>
<h2 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一行一个整数表示答案。</p>
<h2 id="样例-1-2"><a href="#样例-1-2" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-2"><a href="#样例输入-1-2" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">7</span><br><span class="line">2 -4 3 -1 2 -4 3</span><br></pre></td></tr></table></figure>

<h3 id="样例输出-1-2"><a href="#样例输出-1-2" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure>

<h2 id="提示-2"><a href="#提示-2" class="headerlink" title="提示"></a>提示</h2><h4 id="样例-1-解释"><a href="#样例-1-解释" class="headerlink" title="样例 1 解释"></a>样例 1 解释</h4><p>选取 $[3, 5]$ 子段 ${3, -1, 2}$，其和为 $4$。</p>
<h4 id="数据规模与约定"><a href="#数据规模与约定" class="headerlink" title="数据规模与约定"></a>数据规模与约定</h4><ul>
<li>对于 $40%$ 的数据，保证 $n \leq 2 \times 10^3$。</li>
<li>对于 $100%$ 的数据，保证 $1 \leq n \leq 2 \times 10^5$，$-10^4 \leq a_i \leq 10^4$。</li>
</ul>
<h3 id="Analyse：-2"><a href="#Analyse：-2" class="headerlink" title="Analyse："></a>Analyse：</h3><p>然后想到用<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E8%B4%AA%E5%BF%83&spm=1001.2101.3001.7020">贪心</a>的思想（我并没有学，但是了解一点点）</p>
<p>首先考虑第一种情况，全是负数，则只要选出最大的就行；</p>
<p>其它情况：就是用一个 x记录当前前缀和，一路累积过去，如果前缀和  x变成了负数，那么下一个数就不需要前面的数了（因为还不如只选它一个），这时把 x置为0，再继续累加</p>
<h3 id="My-Code-2"><a href="#My-Code-2" class="headerlink" title="My Code:"></a>My Code:</h3><pre><code>#include &lt;iostream&gt;
using namespace std;
int a[200001];
int main()
&#123;
    int n ;
    cin &gt;&gt; n;
    for(int i = 0;i &lt; n;i++)
    &#123;
        scanf(&quot;%d&quot; ,&amp;a[i]);
    &#125;
    int x = 0,max = a[0];
    for(int i = 0;i &lt; n;i++)
    &#123;
        x += a[i];
        if(x &gt;= max)
            max = x;
        if(x &lt;= 0)
            x = 0;
    &#125;
   cout &lt;&lt; max;
    return 0;
&#125;
</code></pre>
<p>模拟与高精度</p>
<p>This is the 4th week.</p>
<h3 id="LCS"><a href="#LCS" class="headerlink" title="LCS"></a>LCS</h3><h2 id="题面翻译"><a href="#题面翻译" class="headerlink" title="题面翻译"></a>题面翻译</h2><p>题目描述：</p>
<p>给定一个字符串 $s$ 和一个字符串 $t$ ，输出 $s$ 和 $t$ 的最长公共子序列。</p>
<p>输入格式：</p>
<p>两行，第一行输入 $s$ ，第二行输入 $t$ 。</p>
<p>输出格式：</p>
<p>输出 $s$ 和 $t$ 的最长公共子序列。如果有多种答案，输出任何一个都可以。</p>
<p>说明&#x2F;提示：</p>
<p>数据保证 $s$ 和 $t$ 仅含英文小写字母，并且 $s$ 和 $t$ 的长度小于等于3000。</p>
<h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p>文字列 $ s $ および $ t $ が与えられます。 $ s $ の部分列かつ $ t $ の部分列であるような文字列のうち、最長のものをひとつ求めてください。</p>
<h2 id="输入格式-3"><a href="#输入格式-3" class="headerlink" title="输入格式"></a>输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p>
<blockquote>
<p>$ s $ $ t $</p>
</blockquote>
<h2 id="输出格式-3"><a href="#输出格式-3" class="headerlink" title="输出格式"></a>输出格式</h2><p>$ s $ の部分列かつ $ t $ の部分列であるような文字列のうち、最長のものをひとつ出力せよ。 答えが複数ある場合、どれを出力してもよい。</p>
<h2 id="样例-1-3"><a href="#样例-1-3" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-3"><a href="#样例输入-1-3" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">axyb</span><br><span class="line">abyxb</span><br></pre></td></tr></table></figure>

<h3 id="样例输出-1-3"><a href="#样例输出-1-3" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">axb</span><br></pre></td></tr></table></figure>

<h2 id="样例-2"><a href="#样例-2" class="headerlink" title="样例 #2"></a>样例 #2</h2><h3 id="样例输入-2"><a href="#样例输入-2" class="headerlink" title="样例输入 #2"></a>样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">aa</span><br><span class="line">xayaz</span><br></pre></td></tr></table></figure>

<h3 id="样例输出-2"><a href="#样例输出-2" class="headerlink" title="样例输出 #2"></a>样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aa</span><br></pre></td></tr></table></figure>

<h2 id="样例-3"><a href="#样例-3" class="headerlink" title="样例 #3"></a>样例 #3</h2><h3 id="样例输入-3"><a href="#样例输入-3" class="headerlink" title="样例输入 #3"></a>样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a</span><br><span class="line">z</span><br></pre></td></tr></table></figure>

<h3 id="样例输出-3"><a href="#样例输出-3" class="headerlink" title="样例输出 #3"></a>样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="样例-4"><a href="#样例-4" class="headerlink" title="样例 #4"></a>样例 #4</h2><h3 id="样例输入-4"><a href="#样例输入-4" class="headerlink" title="样例输入 #4"></a>样例输入 #4</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">abracadabra</span><br><span class="line">avadakedavra</span><br></pre></td></tr></table></figure>

<h3 id="样例输出-4"><a href="#样例输出-4" class="headerlink" title="样例输出 #4"></a>样例输出 #4</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aaadara</span><br></pre></td></tr></table></figure>

<h2 id="提示-3"><a href="#提示-3" class="headerlink" title="提示"></a>提示</h2><h3 id="注釈"><a href="#注釈" class="headerlink" title="注釈"></a>注釈</h3><p>文字列 $ x $ の<em>部分列</em>とは、$ x $ から $ 0 $ 個以上の文字を取り除いた後、残りの文字を元の順序で連結して得られる文字列のことです。</p>
<h3 id="制約"><a href="#制約" class="headerlink" title="制約"></a>制約</h3><ul>
<li>$ s $ および $ t $ は英小文字からなる文字列である。</li>
<li>$ 1\ \leq\ |s|,\ |t|\ \leq\ 3000 $</li>
</ul>
<h3 id="Sample-Explanation-1"><a href="#Sample-Explanation-1" class="headerlink" title="Sample Explanation 1"></a>Sample Explanation 1</h3><p>答えは <code>axb</code> または <code>ayb</code> です。 どちらを出力しても正解となります。</p>
<h3 id="Sample-Explanation-3"><a href="#Sample-Explanation-3" class="headerlink" title="Sample Explanation 3"></a>Sample Explanation 3</h3><p>答えは &#96;&#96; (空文字列) です。</p>
<h3 id="Analyse：-3"><a href="#Analyse：-3" class="headerlink" title="Analyse："></a>Analyse：</h3><ol>
<li>由于每次调用至少向上或向左（或向上向左同时）移动一步，故最多调用(m + n)次就会遇到i &#x3D; 0或j &#x3D; 0的情况，此时开始返回。返回时与递归调用时方向相反，步数相同，故算法时间复杂度为Θ(m + n)。</li>
</ol>
<h3 id="My-Code-3"><a href="#My-Code-3" class="headerlink" title="My Code:"></a>My Code:</h3><pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#define MAXLEN 100

void LCSLength(char *x, char *y, int m, int n, int c[][MAXLEN], int b[][MAXLEN])
&#123;
    int i, j;
    for (i = 0; i &lt;= m; i++)
        c[i][0] = 0;
    for (j = 1; j &lt;= n; j++)
        c[0][j] = 0;
    for (i = 1; i &lt;= m; i++)
    &#123;
        for (j = 1; j &lt;= n; j++)
        &#123;
            if (x[i - 1] == y[j - 1])
            &#123;
                c[i][j] = c[i - 1][j - 1] + 1;
                b[i][j] = 0;
            &#125;
            else if (c[i - 1][j] &gt;= c[i][j - 1])
            &#123;
                c[i][j] = c[i - 1][j];
                b[i][j] = 1;
            &#125;
            else
            &#123;
                c[i][j] = c[i][j - 1];
                b[i][j] = -1;
            &#125;
        &#125;
    &#125;
&#125;

void PrintLCS(int b[][MAXLEN], char *x, int i, int j)
&#123;
    if (i == 0 || j == 0)
        return;
    if (b[i][j] == 0)
    &#123;
        PrintLCS(b, x, i - 1, j - 1);
        printf(&quot;%c &quot;, x[i - 1]);
    &#125;
    else if (b[i][j] == 1)
        PrintLCS(b, x, i - 1, j);
    else
        PrintLCS(b, x, i, j - 1);
&#125;

int main(int argc, char **argv)
&#123;
    char x[MAXLEN] = &#123; &quot;ABCBDAB&quot; &#125;;
    char y[MAXLEN] = &#123; &quot;BDCABA&quot; &#125;;
    int b[MAXLEN][MAXLEN];
    int c[MAXLEN][MAXLEN];
    int m, n;

    m = strlen(x);
    n = strlen(y);

    LCSLength(x, y, m, n, c, b);
    PrintLCS(b, x, m, n);

    return 0;
&#125;
</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/12/19/Test-7/" data-id="clhle1vkf0004fgw17zpk1fzp" data-title="Test 7" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Sixth" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/12/05/Sixth/" class="article-date">
  <time class="dt-published" datetime="2022-12-05T12:22:18.839Z" itemprop="datePublished">2022-12-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>###求最小值，就找出所有向两边的距离的小的一个的最大值  </p>
<hr>
<p>title: Sixth<br>date: 2022-12-05 20:22:18<br>tags:</p>
<hr>
<p>This is the 5th week.</p>
<h4 id="NOIP2010-普及组-三国游戏"><a href="#NOIP2010-普及组-三国游戏" class="headerlink" title="[NOIP2010 普及组] 三国游戏"></a>[NOIP2010 普及组] 三国游戏</h4><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>小涵很喜欢电脑游戏，这些天他正在玩一个叫做《三国》的游戏。</p>
<p>在游戏中，小涵和计算机各执一方，组建各自的军队进行对战。游戏中共有 $N$ 位武将（$N$为偶数且不小于$4$），任意两个武将之间有一个“默契值”，表示若此两位武将作为一对组合作战时，该组合的威力有多大。游戏开始前，所有武将都是自由的（称为自由武将，一旦某个自由武将被选中作为某方军队的一员，那么他就不再是自由武将了），换句话说，所谓的自由武将不属于任何一方。</p>
<p>游戏开始，小涵和计算机要从自由武将中挑选武将组成自己的军队，规则如下：小涵先从自由武将中选出一个加入自己的军队，然后计算机也从自由武将中选出一个加入计算机方的军队。接下来一直按照“小涵→计算机→小涵→……”的顺序选择武将，直到所有的武将被双方均分完。然后，程序自动从双方军队中各挑出一对默契值最高的武将组合代表自己的军队进行二对二比武，拥有更高默契值的一对武将组合获胜，表示两军交战，拥有获胜武将组合的一方获胜。</p>
<p>已知计算机一方选择武将的原则是尽量破坏对手下一步将形成的最强组合，它采取的具体策略如下：任何时刻，轮到计算机挑选时，它会尝试将对手军队中的每个武将与当前每个自由武将进行一一配对，找出所有配对中默契值最高的那对武将组合，并将该组合中的自由武将选入自己的军队。 下面举例说明计算机的选将策略，例如，游戏中一共有$6$个武将，他们相互之间的默契值如下表所示：</p>
<p> <img src="https://cdn.luogu.com.cn/upload/pic/54.png"> </p>
<p>双方选将过程如下所示：</p>
<p> <img src="https://cdn.luogu.com.cn/upload/pic/55.png"> </p>
<p>小涵想知道，如果计算机在一局游戏中始终坚持上面这个策略，那么自己有没有可能必胜？如果有，在所有可能的胜利结局中，自己那对用于比武的武将组合的默契值最大是多少？  </p>
<p>假设整个游戏过程中，对战双方任何时候均能看到自由武将队中的武将和对方军队的武将。为了简化问题，保证对于不同的武将组合，其默契值均不相同。</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>共 N 行。</p>
<p>第一行为一个偶数 $N$，表示武将的个数。</p>
<p>第 $2 $行到第 $N $行里，第$i+1$行有$N_i$个非负整数，每两个数之间用一个空格隔开，表示$ i $号武将和$ i+1,i+2,…,N $号武将之间的默契值（$0≤$默契值$≤1,000,000,000$）。</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>共 $1$ 或 $2 $行。</p>
<p>若对于给定的游戏输入，存在可以让小涵获胜的选将顺序，则输出$ 1$，并另起一行输出所有获胜的情况中，小涵最终选出的武将组合的最大默契值。如果不存在可以让小涵获胜的选将顺序，则输出 $0$。</p>
<h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">6 </span><br><span class="line">5 28 16 29 27 </span><br><span class="line">23 3 20 1 </span><br><span class="line">8 32 26 </span><br><span class="line">33 11 </span><br><span class="line">12</span><br></pre></td></tr></table></figure>

<h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">32</span><br></pre></td></tr></table></figure>

<h2 id="样例-2"><a href="#样例-2" class="headerlink" title="样例 #2"></a>样例 #2</h2><h3 id="样例输入-2"><a href="#样例输入-2" class="headerlink" title="样例输入 #2"></a>样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">8 </span><br><span class="line">42 24 10 29 27 12 58 </span><br><span class="line">31 8 16 26 80 6 </span><br><span class="line">25 3 36 11 5 </span><br><span class="line">33 20 17 13 </span><br><span class="line">15 77 9 </span><br><span class="line">4 50 </span><br><span class="line">19</span><br></pre></td></tr></table></figure>

<h3 id="样例输出-2"><a href="#样例输出-2" class="headerlink" title="样例输出 #2"></a>样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">77</span><br></pre></td></tr></table></figure>

<h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p>【数据范围】</p>
<p>对于$ 40%$的数据有 $N≤10$。</p>
<p>对于$ 70%$的数据有$ N≤18$。</p>
<p>对于 $100%$的数据有 $N≤500$。</p>
<h3 id="Analyse："><a href="#Analyse：" class="headerlink" title="Analyse："></a>Analyse：</h3><p>&#x2F;&#x2F;本题是博弈论 拿到所有组合中的最大第二大 必赢 人不可能拿到最大的 &#x2F;&#x2F;博弈论的特点 就是 &#x2F;<em>1、博弈模型为两人轮流决策的非合作博弈。即两人轮流进行决策，并且两人都使用最优策略来获取胜利。2、博弈是有限的。即无论两人怎样决策，都会在有限步后决出胜负。3、公平博弈。即两人进行决策所遵循的规则相同。</em></p>
<h3 id="My-Code"><a href="#My-Code" class="headerlink" title="My Code:"></a>My Code:</h3><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
const int maxm = 5005;
int n, m, ans;
struct farmer 
&#123;
    int p, a;
&#125; f[maxm];
bool cmp (farmer a, farmer b) 
&#123;
    return a.p &lt; b.p;
&#125;
int main ()
&#123;
    scanf (&quot;%d %d&quot;, &amp;n, &amp;m);
    for (int i = 1; i &lt;= m; i++) 
    &#123;
        scanf (&quot;%d %d&quot;, &amp;f[i].p, &amp;f[i].a);
    &#125;
    sort (f + 1, f + m + 1, cmp);
    int p = 1;
    while (n &gt; 0) 
    &#123;
        if (n &gt;= f[p].a) 
        &#123;
            n -= f[p].a;
            ans += (f[p].a * f[p].p);
        &#125;
        else 
        &#123;
            ans += (n * f[p].p);
            n = 0;
        &#125;
        p ++;
    &#125;
    printf (&quot;%d&quot;, ans);
    return 0;
&#125;
</code></pre>
<p>his is the 4th week.</p>
<h2 id="独木桥"><a href="#独木桥" class="headerlink" title="# 独木桥"></a># 独木桥</h2><h2 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h2><p>战争已经进入到紧要时间。你是运输小队长，正在率领运输部队向前线运送物资。运输任务像做题一样的无聊。你希望找些刺激，于是命令你的士兵们到前方的一座独木桥上欣赏风景，而你留在桥下欣赏士兵们。士兵们十分愤怒，因为这座独木桥十分狭窄，只能容纳 $1$ 个人通过。假如有 $2$ 个人相向而行在桥上相遇，那么他们 $2$ 个人将无法绕过对方，只能有 $1$ 个人回头下桥，让另一个人先通过。但是，可以有多个人同时呆在同一个位置。</p>
<h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>突然，你收到从指挥部发来的信息，敌军的轰炸机正朝着你所在的独木桥飞来！为了安全，你的部队必须撤下独木桥。独木桥的长度为 $L$，士兵们只能呆在坐标为整数的地方。所有士兵的速度都为 $1$，但一个士兵某一时刻来到了坐标为 $0$ 或 $L+1$ 的位置，他就离开了独木桥。</p>
<p>每个士兵都有一个初始面对的方向，他们会以匀速朝着这个方向行走，中途不会自己改变方向。但是，如果两个士兵面对面相遇，他们无法彼此通过对方，于是就分别转身，继续行走。转身不需要任何的时间。</p>
<p>由于先前的愤怒，你已不能控制你的士兵。甚至，你连每个士兵初始面对的方向都不知道。因此，你想要知道你的部队最少需要多少时间就可能全部撤离独木桥。另外，总部也在安排阻拦敌人的进攻，因此你还需要知道你的部队最多需要多少时间才能全部撤离独木桥。</p>
<h2 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行共一个整数 $L$，表示独木桥的长度。桥上的坐标为 $1, 2, \cdots, L$。</p>
<p>第二行共一个整数 $N$，表示初始时留在桥上的士兵数目。</p>
<p>第三行共有 $N$ 个整数，分别表示每个士兵的初始坐标。</p>
<h2 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h2><p>共一行，输出 $2$ 个整数，分别表示部队撤离独木桥的最小时间和最大时间。$2$ 个整数由一个空格符分开。</p>
<h2 id="样例-1-1"><a href="#样例-1-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-1"><a href="#样例输入-1-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">2</span><br><span class="line">1 3</span><br></pre></td></tr></table></figure>

<h3 id="样例输出-1-1"><a href="#样例输出-1-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2 4</span><br></pre></td></tr></table></figure>

<h2 id="提示-1"><a href="#提示-1" class="headerlink" title="提示"></a>提示</h2><p>对于 $100%$ 的数据，满足初始时，没有两个士兵同在一个坐标，$1\le  L\le5\times 10^3$，$0\le N\le5\times10^3$，且数据保证 $N\le L$。</p>
<h3 id="Analyse：-1"><a href="#Analyse：-1" class="headerlink" title="Analyse："></a>Analyse：</h3><h3 id="求最小值，就找出所有向两边的距离的小的一个的最大值"><a href="#求最小值，就找出所有向两边的距离的小的一个的最大值" class="headerlink" title="求最小值，就找出所有向两边的距离的小的一个的最大值"></a>求最小值，就找出所有向两边的距离的小的一个的最大值</h3><h3 id="My-Code-1"><a href="#My-Code-1" class="headerlink" title="My Code:"></a>My Code:</h3><pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
int n,m,minx,maxx;
int max(const int &amp;a,const int &amp;b)&#123;
    return a&gt;b?a:b;
&#125;
int min(const int &amp;a,const int &amp;b)&#123;
    return a&lt;b?a:b;
&#125;
int main()&#123;
    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
    int x;
    maxx=0;
    minx=0;
    for(int i=1;i&lt;=m;i++)&#123;
        scanf(&quot;%d&quot;,&amp;x);
        maxx=max(maxx,max(x,n-x+1));
        minx=max(minx,min(x,n-x+1));
    &#125;
    cout&lt;&lt;minx&lt;&lt;&quot; &quot;&lt;&lt;maxx;
    return 0;
&#125;
</code></pre>
<h1 id="NOIP2004-提高组-合并果子-x2F-USACO06NOV-Fence-Repair-G"><a href="#NOIP2004-提高组-合并果子-x2F-USACO06NOV-Fence-Repair-G" class="headerlink" title="[NOIP2004 提高组] 合并果子 &#x2F; [USACO06NOV] Fence Repair G"></a>[NOIP2004 提高组] 合并果子 &#x2F; [USACO06NOV] Fence Repair G</h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>在一个果园里，多多已经将所有的果子打了下来，而且按果子的不同种类分成了不同的堆。多多决定把所有的果子合成一堆。</p>
<p>每一次合并，多多可以把两堆果子合并到一起，消耗的体力等于两堆果子的重量之和。可以看出，所有的果子经过 $n-1$ 次合并之后， 就只剩下一堆了。多多在合并果子时总共消耗的体力等于每次合并所耗体力之和。</p>
<p>因为还要花大力气把这些果子搬回家，所以多多在合并果子时要尽可能地节省体力。假定每个果子重量都为 $1$ ，并且已知果子的种类 数和每种果子的数目，你的任务是设计出合并的次序方案，使多多耗费的体力最少，并输出这个最小的体力耗费值。</p>
<p>例如有 $3$ 种果子，数目依次为 $1$ ， $2$ ， $9$ 。可以先将 $1$ 、 $2$ 堆合并，新堆数目为 $3$ ，耗费体力为 $3$ 。接着，将新堆与原先的第三堆合并，又得到新的堆，数目为 $12$ ，耗费体力为 $12$ 。所以多多总共耗费体力 $&#x3D;3+12&#x3D;15$ 。可以证明 $15$ 为最小的体力耗费值。</p>
<h2 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式"></a>输入格式</h2><p>共两行。<br>第一行是一个整数 $n(1\leq n\leq 10000)$ ，表示果子的种类数。  </p>
<p>第二行包含 $n$ 个整数，用空格分隔，第 $i$ 个整数 $a_i(1\leq a_i\leq 20000)$ 是第 $i$ 种果子的数目。</p>
<h2 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式"></a>输出格式</h2><p>一个整数，也就是最小的体力耗费值。输入数据保证这个值小于 $2^{31}$ 。</p>
<h2 id="样例-1-2"><a href="#样例-1-2" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-2"><a href="#样例输入-1-2" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3 </span><br><span class="line">1 2 9</span><br></pre></td></tr></table></figure>

<h3 id="样例输出-1-2"><a href="#样例输出-1-2" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">15</span><br></pre></td></tr></table></figure>

<h2 id="提示-2"><a href="#提示-2" class="headerlink" title="提示"></a>提示</h2><p>对于 $30%$ 的数据，保证有 $n \le 1000$：</p>
<p>对于 $50%$ 的数据，保证有 $n \le 5000$；</p>
<p>对于全部的数据，保证有 $n \le 10000$。</p>
<h3 id="Analyse：-2"><a href="#Analyse：-2" class="headerlink" title="Analyse："></a>Analyse：</h3><p>使用优先队列，很简单。需要注意的是，因为要求搬放重量最小的果子，所以往优先队列里放入果子的重量x时，输入-x。这样重量最小的成为了最优先的。</p>
<h3 id="My-Code-2"><a href="#My-Code-2" class="headerlink" title="My Code:"></a>My Code:</h3><pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
priority_queue&lt;int&gt; que;
int main()
&#123;
    int n,ans=0;
    cin&gt;&gt;n;
    int x;
    for(int i=0;i&lt;n;i++)
    &#123;
        cin&gt;&gt;x;
        que.push(-x);//放入负数是为了让最小的数在最前，达到优先的效果 （也可以自定义优先级，重载默认的 &lt; 符号）
    &#125;
    int tmp;
    for(int i=1;i&lt;n;i++)
    &#123;
        tmp=que.top();
        ans-=que.top();//减去负值即为正值
        que.pop();
        tmp+=que.top();
        ans-=que.top();
        que.pop();
        que.push(tmp);
    &#125;
    cout&lt;&lt;ans&lt;&lt;endl;
    return 0;
&#125;
</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/12/05/Sixth/" data-id="clhle1vkc0001fgw18ivu7v22" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-双周1" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/11/28/%E5%8F%8C%E5%91%A81/" class="article-date">
  <time class="dt-published" datetime="2022-11-28T13:35:31.000Z" itemprop="datePublished">2022-11-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/11/28/%E5%8F%8C%E5%91%A81/">双周1</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>7-1 Lily</p>
<p>分数 300</p>
<p>全屏浏览题目</p>
<p>切换布局</p>
<p>作者 neuqAcmClub</p>
<p>单位 东北大学秦皇岛分校</p>
<p>百合花（Lily）是一种美丽的花。她通常一年只开一次花，所以如果你看到百合花盛开，它会非常珍贵。然而，她对猫有剧毒，所以你必须注意让好奇的猫远离可爱的百合花。</p>
<p>你有n个网格的土壤土地排成一行，从1到n，其中一些是百合花。我们不想伤害百合，也不想伤害猫。你可以在网格上放一些猫粮，但对于任何有猫粮的网格i，在区域[i−1,i+1]不得含有百合花。你喜欢猫和百合，所以你想最大限度地增加有猫粮的格子。</p>
<p>设计满足上述要求的计划。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>有一个整数n（1≤n≤1000）表示网格的数量。</p>
<p>第二行包含仅由“L”和“.”组成的字符串R，表示有和没有百合花的格子。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>输出包含一行，字符串R′仅由“L”、“”组成和“C”，其中“C”表示在满足上述要求的同时分配给R中空网格的猫粮。</p>
<h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><p>在这里给出一组输入。例如：</p>
<pre><code>5
..L..
</code></pre>
<h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><p>在这里给出相应的输出。例如：</p>
<pre><code>C.L.C
</code></pre>
<p>输出样例:</p>
<p>在这里给出相应的输出。例如：</p>
<pre><code>C.L.C
</code></pre>
<p>Analyse：</p>
<p>先读入格子的状态</p>
<p>再遍历每一个格子检测其相邻格子中是否有有百合&#96;</p>
<ul>
<li><p>Code:</p>
<p> #include<iostream><br> using namespace std;<br> int main(){</p>
<pre><code> int n,m=1;
 int A[1005]=&#123;0&#125;;  
 char a[1005]=&#123;0&#125;;
 cin&gt;&gt;n;
 for(int i=1;i&lt;=n;i++)&#123;
     cin&gt;&gt;a[i]; 
 &#125;
 while(m&lt;=n)&#123;
     if(a[m]==&#39;L&#39;)&#123;
         A[i]=1;
         A[i+1]=1;
         A[i-1]=1;   
     &#125;
     m++;
 &#125;

 for(int i=1;i&lt;=n;i++)&#123;
     if(A[i]!=1)&#123;
         a[i]=&#39;C&#39;;  
     &#125;
 &#125;
 for(int i=1;i&lt;=n;i++)&#123;
     cout&lt;&lt;a[i];  
 &#125;

 return 0;
</code></pre>
<p> }</p>
</li>
</ul>
<p>7-2 a * b</p>
<p>分数 300</p>
<p>全屏浏览题目</p>
<p>切换布局</p>
<p>作者 neuqAcmClub</p>
<p>单位 东北大学秦皇岛分校</p>
<p>给出两个不超过1000位的十六进制数a,b。<br>求a∗b的值</p>
<h3 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>输入共两行，两个十六进制的数</p>
<h3 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>输出一行，表示a∗b</p>
<h3 id="输入样例-1"><a href="#输入样例-1" class="headerlink" title="输入样例:"></a>输入样例:</h3><p>在这里给出一组输入。例如：</p>
<pre><code>1BF52
1D4B42
</code></pre>
<h3 id="Analyse："><a href="#Analyse：" class="headerlink" title="Analyse："></a>Analyse：</h3><p>存储每个位置的数字时,我们要注意字母与数字的转化.同样,在输出时也要注意输出数字若大于等于10,就要转化成字母.</p>
<h3 id="My-Code"><a href="#My-Code" class="headerlink" title="My Code:"></a>My Code:</h3><ul>
<li>}a[N];</li>
</ul>
<h3 id="My-Code-1"><a href="#My-Code-1" class="headerlink" title="My Code:"></a>My Code:</h3><pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
map&lt;int,int&gt;a1[100001];
int n,q;
int main()
&#123;
    cin&gt;&gt;n&gt;&gt;q;
    for(int i=0;i&lt;q;i++)
    &#123;
        int a,b,c,d;
        cin&gt;&gt;a;
        if(a==1)
        &#123;
            cin&gt;&gt;b&gt;&gt;c&gt;&gt;d;
            a1[b][c]=d;  //用map数组记录k
        &#125;
        else
        &#123;
            cin&gt;&gt;b&gt;&gt;c;
            cout&lt;&lt;a1[b][c]&lt;&lt;endl;  //输出aij

        &#125;
    &#125;
    return 0;
&#125;
</code></pre>
<p>7-3 山头狙击战</p>
<p>分数 300</p>
<p>全屏浏览题目</p>
<p>切换布局</p>
<p>作者 neuqAcmClub</p>
<p>单位 东北大学秦皇岛分校</p>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>小明为了掩护大部队，单枪匹马同敌人周旋，后来被敌人包围在某山头……等等，为什么怎么听怎么像狼牙山五壮士！不过不用着急，这次小明携带了足够的弹药，完全可以将涌上来的敌人一个一个干掉。小明是个神枪手，只要他的枪膛中有子弹，他就能将在他射程m（用从敌人位置到山头的直线距离算）以内的一个敌人瞬间射杀。但如果在射程内没有敌人，出于节约子弹考虑和面子问题，小明会等待敌人靠近然后射击。<br>正当小明为自己的强大而自我膨胀时，他忽然发现了一个致命的失误：他携带的枪是单发枪，每射出一发子弹都必须花k秒钟的时间装子弹。而凶残的敌人才不会花时间等你换子弹呢。他们始终在以1m&#x2F;s的速度接近山头。而如果在一个敌人到达山头时小明无法将他击毙，那么我们可怜的小明就将牺牲在敌人的刺刀下。现在小明用心灵感应向你发出求助：要保住自己的性命并且歼灭所有敌人，小明最多只能用多少时间给枪装上一发子弹？<br>说明：假设一开始小明的枪中就有一发子弹，并且一旦确定一个装弹时间，小明始终会用这个时间完成子弹的装卸。希望你能帮助小明脱离险境。</p>
<h3 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式"></a>输入格式</h3><p>每组输入数据，第一行有两个整数n和m，（2≤n≤100,000; 1≤m≤10,000,000）n代表敌人个数，m代表小明的射程。<br>接下来有n行，每行一个整数mi,（1≤mi≤10,000,000），代表每个敌人一开始相对山头的距离（单位为米）。</p>
<h3 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式"></a>输出格式</h3><p>每组输出数据仅有一个整数，代表小明的换弹时间（单位为秒）。</p>
<p>样例输入</p>
<pre><code>6 100
236
120
120
120
120
120
</code></pre>
<p>样例输出</p>
<pre><code>25
</code></pre>
<p>Analyse：</p>
<p>敌人到射程才能开始开枪.</p>
<p>需要一个一个的来进行模拟</p>
<p>二分</p>
<h3 id="My-Code-2"><a href="#My-Code-2" class="headerlink" title="My Code:"></a>My Code:</h3><pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
map&lt;int,int&gt;a1[100001];
int n,q;
int main()
&#123;
    cin&gt;&gt;n&gt;&gt;q;
    for(int i=0;i&lt;q;i++)
    &#123;
        int a,b,c,d;
        cin&gt;&gt;a;
        if(a==1)
        &#123;
            cin&gt;&gt;b&gt;&gt;c&gt;&gt;d;
            a1[b][c]=d;  //用map数组记录k
        &#125;
        else
        &#123;
            cin&gt;&gt;b&gt;&gt;c;
            cout&lt;&lt;a1[b][c]&lt;&lt;endl;  //输出aij

        &#125;
    &#125;
    return 0;
&#125;
</code></pre>
<p>7-4 Reversing Linked List</p>
<p>分数 300</p>
<p>全屏浏览题目</p>
<p>切换布局</p>
<p>作者 陈越</p>
<p>单位 浙江大学</p>
<p>Given a constant K and a singly linked list L, you are supposed to reverse the links of every K elements on L. For example, given L being 1→2→3→4→5→6, if K&#x3D;3, then you must output 3→2→1→6→5→4; if K&#x3D;4, you must output 4→3→2→1→5→6.</p>
<h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line contains the address of the first node, a positive N (≤105) which is the total number of nodes, and a positive K (≤N) which is the length of the sublist to be reversed. The address of a node is a 5-digit nonnegative integer, and NULL is represented by -1.</p>
<p>Then N lines follow, each describes a node in the format:</p>
<pre><code>Address Data Next
</code></pre>
<p>where <code>Address</code> is the position of the node, <code>Data</code> is an integer, and <code>Next</code> is the position of the next node.</p>
<h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each case, output the resulting ordered linked list. Each node occupies a line, and is printed in the same format as in the input.</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><pre><code>00100 6 4
00000 4 99999
00100 1 12309
68237 6 -1
33218 3 00000
99999 5 68237
12309 2 33218
</code></pre>
<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><pre><code>00000 4 33218
33218 3 12309
12309 2 00100
00100 1 99999
99999 5 68237
68237 6 -1
</code></pre>
<p>Analyse：</p>
<p>就是用一个<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84&spm=1001.2101.3001.7020">二维数组</a>存储第i个柜子和第j个格子。个人认为用二维数组过于浪费空间，所以用STL中的map来存储。</p>
<ul>
<li><h3 id="My-Code-3"><a href="#My-Code-3" class="headerlink" title="My Code:"></a>My Code:</h3><p>  #include&lt;bits&#x2F;stdc++.h&gt;<br>  using namespace std;<br>  map&lt;int,int&gt;a1[100001];<br>  int n,q;<br>  int main()<br>  {</p>
<pre><code>  cin&gt;&gt;n&gt;&gt;q;
  for(int i=0;i&lt;q;i++)
  &#123;
      int a,b,c,d;
      cin&gt;&gt;a;
      if(a==1)
      &#123;
          cin&gt;&gt;b&gt;&gt;c&gt;&gt;d;
          a1[b][c]=d;  //用map数组记录k
      &#125;
      else
      &#123;
          cin&gt;&gt;b&gt;&gt;c;
          cout&lt;&lt;a1[b][c]&lt;&lt;endl;  //输出aij

      &#125;
  &#125;
  return 0;
</code></pre>
<p>  }</p>
</li>
</ul>
<p>7-5 一元三次方程</p>
<p>分数 300</p>
<p>全屏浏览题目</p>
<p>切换布局</p>
<p>作者 neuqAcmClub</p>
<p>单位 东北大学秦皇岛分校</p>
<p>给定一个形如ax3+bx2+cx+d&#x3D;0的一元三次方程。</p>
<p>已知该方程有三个不同的实数根（根与根之差的绝对值≥10−6），且根范围均在[p,q]之间，你需要解出这个方程的三个根。</p>
<h3 id="输入格式-3"><a href="#输入格式-3" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>第一行一个整数T(1≤T≤1000)，表示有T组数据</p>
<p>接下来T行，每行6个实数，分别表示a,b,c,d,p,q</p>
<p>数据保证：−102≤p,q≤102，且对于∀x∈[p,q],−106≤f(x)≤106</p>
<h3 id="输出格式-3"><a href="#输出格式-3" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>输出三个实数，表示方程的三个解。</p>
<p>你的答案可以以任意顺序输出。</p>
<p>一个答案被认为是正确的，当且仅当其与标准答案的绝对误差不超过10−6</p>
<h3 id="输入样例-2"><a href="#输入样例-2" class="headerlink" title="输入样例:"></a>输入样例:</h3><p>在这里给出一组输入。例如：</p>
<pre><code>1
1.000000 -5.000000 -4.000000 20.000000 -10.000000 10.000000
</code></pre>
<h3 id="输出样例-1"><a href="#输出样例-1" class="headerlink" title="输出样例:"></a>输出样例:</h3><p>在这里给出相应的输出。例如：</p>
<pre><code>-2.000000 2.000000 5.000000
</code></pre>
<h3 id="提示1："><a href="#提示1：" class="headerlink" title="提示1："></a>提示1：</h3><p>样例所给方程的图像如下：</p>
<p><img src="https://images.ptausercontent.com/0600ddcf-0496-4697-a16c-5f7ceccf042f.png" alt="T4.png"></p>
<h3 id="分析：必定在p和q的区间里有极大值点a和极小值点b-则方程的解也就是在-p-min-a-b-min-a-b-max-a-b-max-a-b-q-这三个区间内"><a href="#分析：必定在p和q的区间里有极大值点a和极小值点b-则方程的解也就是在-p-min-a-b-min-a-b-max-a-b-max-a-b-q-这三个区间内" class="headerlink" title="分析：必定在p和q的区间里有极大值点a和极小值点b,                                                                       则方程的解也就是在(p,min{a,b})(min{a,b},max{a,b})(max{a,b},q)这三个区间内,"></a>分析：必定在p和q的区间里有极大值点a和极小值点b,                                                                       则方程的解也就是在(p,min{a,b})(min{a,b},max{a,b})(max{a,b},q)这三个区间内,</h3><h3 id="My-Code-4"><a href="#My-Code-4" class="headerlink" title="My Code:"></a>My Code:</h3><pre><code>#include&lt;iostream&gt;
#include&lt;cmath&gt;
#include&lt;iomanip&gt;
using namespace std;   
double f(double x,double a,double b,double c,double d)&#123;  //求函数值
    double f;
    f=a*pow(x,3.0)+b*pow(x,2.0)+c*x+d;
    return f;
&#125;
double findx(double l,double r,double a,double b,double c,double d)&#123;  //二分搜索
    double mid;
    while(abs(l-r)&gt;pow(10.0,-7.0))&#123;  //控制精度
        mid=(l+r)/2.0;
        if(f(mid,a,b,c,d)*f(l,a,b,c,d)&gt;0)&#123;
            l=mid;
        &#125;
        else&#123;
            r=mid;
        &#125;
    &#125;
    return mid;
&#125;
void findm(double a,double b,double c,double d,double p,double q)&#123;
    double x1,x2;
    double ret1,ret2,ret3;
    x1=((-2)*b+pow(4*b*b-12*a*c,0.5))/(6*a);
    x2=((-2)*b-pow(4*b*b-12*a*c,0.5))/(6*a);   //求极值点的横坐标
    if(x1&gt;x2)&#123;
        ret3=findx(x1,q,a,b,c,d);
        ret1=findx(p,x2,a,b,c,d);
        ret2=findx(x2,x1,a,b,c,d);        //在x1&gt;x2状态下进行二分搜索
    &#125;       
    else&#123;
        ret3=findx(x2,q,a,b,c,d);
        ret1=findx(p,x1,a,b,c,d);
        ret2=findx(x1,x2,a,b,c,d);      //在x2&gt;x1状态下进行二分搜索
    &#125;
    cout&lt;&lt;ret1&lt;&lt;&quot; &quot;&lt;&lt;ret2&lt;&lt;&quot; &quot;&lt;&lt;ret3&lt;&lt;endl;  //输出结果
&#125;
int main()&#123;
    double arr[1005][6];  //用于存放每组输入的数据
    cout&lt;&lt;fixed&lt;&lt;setprecision(9);  
    int n;
    cin&gt;&gt;n;
    for(int i=0;i&lt;n;i++)&#123;
        for(int j=0;j&lt;6;j++)&#123;
            cin&gt;&gt;arr[i][j];  
        &#125;
    &#125;
    for(int i=0;i&lt;n;i++)&#123;
        findm(arr[i][0],arr[i][1],arr[i][2],arr[i][3],arr[i][4],arr[i][5]);  //进行计算
    &#125;
    system(&quot;pause&quot;);
    return 0;
&#125;
</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/11/28/%E5%8F%8C%E5%91%A81/" data-id="clhle1vkp000lfgw19b9yh6wu" data-title="双周1" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/05/">May 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/04/">April 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/03/">March 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/02/">February 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/01/">January 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/12/">December 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/11/">November 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/05/13/week17/">week17</a>
          </li>
        
          <li>
            <a href="/2023/05/13/week16/">week16</a>
          </li>
        
          <li>
            <a href="/2023/05/13/week15/">week15</a>
          </li>
        
          <li>
            <a href="/2023/04/01/%E5%8F%8C%E5%91%A8%E8%B5%9B%E4%B8%80/">双周赛一</a>
          </li>
        
          <li>
            <a href="/2023/04/01/%E7%AC%AC%E4%B8%89%E5%91%A8/">第三周</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>