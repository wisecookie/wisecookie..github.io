<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-week8" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/09/week8/" class="article-date">
  <time class="dt-published" datetime="2023-01-09T15:06:05.000Z" itemprop="datePublished">2023-01-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/01/09/week8/">week8</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <pre><code>title: Test 7
date: 2022-12-19 20:14:51
tags:
</code></pre>
<p>This is the 8th week.</p>
<h3 id="樱花"><a href="#樱花" class="headerlink" title="# 樱花"></a># 樱花</h3><h2 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h2><p>《爱与愁的故事第四弹·plant》第一章。</p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>爱与愁大神后院里种了 $n$ 棵樱花树，每棵都有美学值 $C_i(0 \le C_i \le 200)$。爱与愁大神在每天上学前都会来赏花。爱与愁大神可是生物学霸，他懂得如何欣赏樱花：一种樱花树看一遍过，一种樱花树最多看 $A_i(0 \le A_i \le 100)$ 遍，一种樱花树可以看无数遍。但是看每棵樱花树都有一定的时间 $T_i(0 \le T_i \le 100)$。爱与愁大神离去上学的时间只剩下一小会儿了。求解看哪几棵樱花树能使美学值最高且爱与愁大神能准时（或提早）去上学。</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>共 $n+1$行：</p>
<p>第 $1$ 行：现在时间 $T_s$（几时：几分），去上学的时间 $T_e$（几时：几分），爱与愁大神院子里有几棵樱花树 $n$。这里的 $T_s$，$T_e$ 格式为：<code>hh:mm</code>，其中 $0 \leq hh \leq 23$，$0 \leq mm \leq 59$，且 $hh,mm,n$ 均为正整数。</p>
<p>第 $2$ 行到第 $n+1$ 行，每行三个正整数：看完第 $i$ 棵树的耗费时间 $T_i$，第 $i$ 棵树的美学值 $C_i$，看第 $i$ 棵树的次数 $P_i$（$P_i&#x3D;0$ 表示无数次，$P_i$ 是其他数字表示最多可看的次数 $P_i$）。</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>只有一个整数，表示最大美学值。</p>
<h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">6:50 7:00 3</span><br><span class="line">2 1 0</span><br><span class="line">3 3 1</span><br><span class="line">4 5 4</span><br></pre></td></tr></table></figure>

<h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">11</span><br></pre></td></tr></table></figure>

<h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p>$100%$ 数据：$T_e-T_s \leq 1000$（即开始时间距离结束时间不超过 $1000$ 分钟），$n \leq 10000$。保证 $T_e,T_s$ 为同一天内的时间。</p>
<p>样例解释：赏第一棵樱花树一次，赏第三棵樱花树 $2$ 次。</p>
<h3 id="Analyse："><a href="#Analyse：" class="headerlink" title="Analyse："></a>Analyse：</h3><p><a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98&spm=1001.2101.3001.7020">背包问题</a></p>
<p><strong>很清晰看到樱花树可以看得次数有三种，一次，多次，无数次，很显然这是一道混合背包的裸题，要用到二进制优化。</strong></p>
<p>这是一道混合背包板子题。使用二进制对数量有限且不为1的物品进行分割，化归为数量为1的物品。然后依据物品数为1或无限，分别按照0&#x2F;1背包、完全背包进行处理。0&#x2F;1背包、完全背包具体步骤</p>
<pre><code>#include &lt;iostream&gt;
using namespace std;
int main()
&#123;
    const int A = 1e4 + 5;
    int a[A], b[A], c[A], e[1005];
    int x1, x2, x3, x4, n, m;
    char a1, a2;
    cin &gt;&gt; x1 &gt;&gt; a1 &gt;&gt; x2 &gt;&gt; x3 &gt;&gt; a2 &gt;&gt; x4 &gt;&gt; n;
    m = (x3 - x1) * 60 + x4 - x2;
    for (int i = 1; i &lt;= n; i++)
    &#123;
        cin &gt;&gt; a[i] &gt;&gt; b[i] &gt;&gt; c[i];
        if (c[i] == 0)
            c[i] = 1e9;
    &#125;

    for(int i=1;i&lt;=n;i++)
        for (int j = m; j &gt;= a[i]; j--)
        &#123;
            if (a[i] == 0)
            &#123;
                for (int p = 1; p &lt;= m; p++)
                    e[p] += b[i] * c[i];
                break;
            &#125;
            else
            &#123;
                for (int t = 1; t &lt;= c[i] &amp;&amp; j &gt;= a[i] * t; t++)
                    e[j] = max(e[j], e[j - a[i] * t] + b[i] * t);
            &#125;
        &#125;
    cout &lt;&lt; e[m];
    return 0;
&#125;
</code></pre>
<h1 id="疯狂的采药"><a href="#疯狂的采药" class="headerlink" title="疯狂的采药"></a>疯狂的采药</h1><h2 id="题目背景-1"><a href="#题目背景-1" class="headerlink" title="题目背景"></a>题目背景</h2><p>此题为纪念 LiYuxiang 而生。</p>
<h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>LiYuxiang 是个天资聪颖的孩子，他的梦想是成为世界上最伟大的医师。为此，他想拜附近最有威望的医师为师。医师为了判断他的资质，给他出了一个难题。医师把他带到一个到处都是草药的山洞里对他说：“孩子，这个山洞里有一些不同种类的草药，采每一种都需要一些时间，每一种也有它自身的价值。我会给你一段时间，在这段时间里，你可以采到一些草药。如果你是一个聪明的孩子，你应该可以让采到的草药的总价值最大。”</p>
<p>如果你是 LiYuxiang，你能完成这个任务吗？</p>
<p>此题和原题的不同点：</p>
<p>$1$. 每种草药可以无限制地疯狂采摘。</p>
<p>$2$. 药的种类眼花缭乱，采药时间好长好长啊！师傅等得菊花都谢了！</p>
<h2 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入第一行有两个整数，分别代表总共能够用来采药的时间 $t$ 和代表山洞里的草药的数目 $m$。</p>
<p>第 $2$ 到第 $(m + 1)$ 行，每行两个整数，第 $(i + 1)$ 行的整数 $a_i, b_i$ 分别表示采摘第 $i$ 种草药的时间和该草药的价值。</p>
<h2 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一行，这一行只包含一个整数，表示在规定的时间内，可以采到的草药的最大总价值。</p>
<h2 id="样例-1-1"><a href="#样例-1-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-1"><a href="#样例输入-1-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">70 3</span><br><span class="line">71 100</span><br><span class="line">69 1</span><br><span class="line">1 2</span><br></pre></td></tr></table></figure>

<h3 id="样例输出-1-1"><a href="#样例输出-1-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">140</span><br></pre></td></tr></table></figure>

<h2 id="提示-1"><a href="#提示-1" class="headerlink" title="提示"></a>提示</h2><h4 id="数据规模与约定"><a href="#数据规模与约定" class="headerlink" title="数据规模与约定"></a>数据规模与约定</h4><ul>
<li>对于 $30%$ 的数据，保证 $m \le 10^3$ 。</li>
<li>对于 $100%$ 的数据，保证 $1 \leq m \le 10^4$，$1 \leq t \leq 10^7$，且 $1 \leq m \times t \leq 10^7$，$1 \leq a_i, b_i \leq 10^4$。</li>
</ul>
<h3 id="Analyse：-1"><a href="#Analyse：-1" class="headerlink" title="Analyse："></a>Analyse：</h3><ol>
<li><p>假设只有一惟 fi​，如果是倒序推那么当前 f1​ ~ fi−1​ 都是上一个草药遗留下来的状态，显然不符合要求。</p>
<p>正序推的话 f1​ ~ fi−1​ 均为当前草药已经推过的状态，符合要求。</p>
<p>所以完全背包和 01 背包的区别就在于对时间大小枚举的顺序不同。</p>
<p>本题最多有 107 时间，每种草药的价值最大是 104，所以极限情况下价值总和是 107×104&#x3D;1011，会爆 int，所以要开 long long</p>
</li>
</ol>
<h3 id="My-Code"><a href="#My-Code" class="headerlink" title="My Code:"></a>My Code:</h3><pre><code>#include &lt;iostream&gt;
using namespace std;
const int a1 = 1e7 + 10, a2 = 1e4 + 10;
int main() &#123;
    int a[a2], b[a2],n, m;
    long c[a1];
    scanf(&quot;%d%d&quot;, &amp;m, &amp;n);
    for (int i = 1; i &lt;= n; i++)
        cin&gt;&gt;a[i]&gt;&gt;b[i];

    for (int i = 1; i &lt;= n; i++)
        for (int j = a[i]; j &lt;= m; j++)
            c[j] = max(c[j], c[j - a[i]] + b[i]);

    cout&lt;&lt;c[m];

    return 0;
&#125;
</code></pre>
<h1 id="NOIP2012-普及组-摆花"><a href="#NOIP2012-普及组-摆花" class="headerlink" title="# [NOIP2012 普及组] 摆花"></a># [NOIP2012 普及组] 摆花</h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>小明的花店新开张，为了吸引顾客，他想在花店的门口摆上一排花，共 $m$ 盆。通过调查顾客的喜好，小明列出了顾客最喜欢的 $n$ 种花，从 $1$ 到 $n$ 标号。为了在门口展出更多种花，规定第 $i$ 种花不能超过 $a_i$ 盆，摆花时同一种花放在一起，且不同种类的花需按标号的从小到大的顺序依次摆列。</p>
<p>试编程计算，一共有多少种不同的摆花方案。</p>
<h2 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行包含两个正整数 $n$ 和 $m$，中间用一个空格隔开。</p>
<p>第二行有 $n$ 个整数，每两个整数之间用一个空格隔开，依次表示 $a_1,a_2, \cdots ,a_n$。</p>
<h2 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式"></a>输出格式</h2><p>一个整数，表示有多少种方案。注意：因为方案数可能很多，请输出方案数对 $10^6+7$ 取模的结果。</p>
<h2 id="样例-1-2"><a href="#样例-1-2" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-2"><a href="#样例输入-1-2" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2 4</span><br><span class="line">3 2</span><br></pre></td></tr></table></figure>

<h3 id="样例输出-1-2"><a href="#样例输出-1-2" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure>

<h2 id="提示-2"><a href="#提示-2" class="headerlink" title="提示"></a>提示</h2><p>【数据范围】</p>
<p>对于 $20%$ 数据，有 $0&lt;n \le 8,0&lt;m \le 8,0 \le a_i \le 8$。</p>
<p>对于 $50%$ 数据，有 $0&lt;n \le 20,0&lt;m \le 20,0 \le a_i \le 20$。</p>
<p>对于 $100%$ 数据，有 $0&lt;n \le 100,0&lt;m \le 100,0 \le a_i \le 100$。</p>
<p>NOIP 2012 普及组 第三题</p>
<h3 id="Analyse：-2"><a href="#Analyse：-2" class="headerlink" title="Analyse："></a>Analyse：</h3><p>这道题的价值在于，它既可以从简单的动态规划开始，一路优化，也可以从生成函数的视角观察，继续优化。</p>
<p>从这个题我才知道DP并不是全都有max,min函数的啊，DP的核心其实是从上一层的最优解推下一层的最优解，但这个题的最优即所有方案加起来的和，所以这个题没有取max,min。</p>
<h3 id="My-Code-1"><a href="#My-Code-1" class="headerlink" title="My Code:"></a>My Code:</h3><pre><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
#define B 1000007;
int n,m;            
int A[10010];
int a[1100][1100]; 
int main()
&#123;
    cin&gt;&gt;n&gt;&gt;m;
    for(int i=1;i&lt;=n;i++) cin&gt;&gt;A[i];
    for(int i=0;i&lt;=A[1];i++) a[1][i] = 1;
    
    for(int i=1;i&lt;=n;i++) a[i][0] = 1;
    
    for(int i=2;i&lt;=n;i++)
        for(int j=1;j&lt;=m;j++)
            for(int k=0;k&lt;=A[i] &amp;&amp; k&lt;=j;k++)
                a[i][j] = (a[i][j]+a[i-1][j-k])%B;
                
    cout&lt;&lt;a[n][m];
    return 0;			
                 
&#125; 
</code></pre>
<h1 id="NOIP2006-提高组-金明的预算方案"><a href="#NOIP2006-提高组-金明的预算方案" class="headerlink" title="[NOIP2006 提高组] 金明的预算方案"></a>[NOIP2006 提高组] 金明的预算方案</h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p>金明今天很开心，家里购置的新房就要领钥匙了，新房里有一间金明自己专用的很宽敞的房间。更让他高兴的是，妈妈昨天对他说：“你的房间需要购买哪些物品，怎么布置，你说了算，只要不超过 $n$ 元钱就行”。今天一早，金明就开始做预算了，他把想买的物品分为两类：主件与附件，附件是从属于某个主件的，下表就是一些主件与附件的例子：</p>
<table>
<thead>
<tr>
<th align="center">主件</th>
<th align="center">附件</th>
</tr>
</thead>
<tbody><tr>
<td align="center">电脑</td>
<td align="center">打印机，扫描仪</td>
</tr>
<tr>
<td align="center">书柜</td>
<td align="center">图书</td>
</tr>
<tr>
<td align="center">书桌</td>
<td align="center">台灯，文具</td>
</tr>
<tr>
<td align="center">工作椅</td>
<td align="center">无</td>
</tr>
</tbody></table>
<p>如果要买归类为附件的物品，必须先买该附件所属的主件。每个主件可以有 $0$ 个、$1$ 个或 $2$ 个附件。每个附件对应一个主件，附件不再有从属于自己的附件。金明想买的东西很多，肯定会超过妈妈限定的 $n$ 元。于是，他把每件物品规定了一个重要度，分为 $5$ 等：用整数 $1 \sim 5$ 表示，第 $5$ 等最重要。他还从因特网上查到了每件物品的价格（都是 $10$ 元的整数倍）。他希望在不超过 $n$ 元的前提下，使每件物品的价格与重要度的乘积的总和最大。</p>
<p>设第 $j$ 件物品的价格为 $v_j$，重要度为$w_j$，共选中了 $k$ 件物品，编号依次为 $j_1,j_2,\dots,j_k$，则所求的总和为：</p>
<p>$v_{j_1} \times w_{j_1}+v_{j_2} \times w_{j_2}+ \dots +v_{j_k} \times w_{j_k}$。</p>
<p>请你帮助金明设计一个满足要求的购物单。</p>
<h2 id="输入格式-3"><a href="#输入格式-3" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行有两个整数，分别表示总钱数 $n$ 和希望购买的物品个数 $m$。</p>
<p>第 $2$ 到第 $(m + 1)$ 行，每行三个整数，第 $(i + 1)$ 行的整数 $v_i$，$p_i$，$q_i$ 分别表示第 $i$ 件物品的价格、重要度以及它对应的的主件。如果 $q_i&#x3D;0$，表示该物品本身是主件。</p>
<h2 id="输出格式-3"><a href="#输出格式-3" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一行一个整数表示答案。</p>
<h2 id="样例-1-3"><a href="#样例-1-3" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-3"><a href="#样例输入-1-3" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1000 5</span><br><span class="line">800 2 0</span><br><span class="line">400 5 1</span><br><span class="line">300 5 1</span><br><span class="line">400 3 0</span><br><span class="line">500 2 0</span><br></pre></td></tr></table></figure>

<h3 id="样例输出-1-3"><a href="#样例输出-1-3" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2200</span><br></pre></td></tr></table></figure>

<h2 id="提示-3"><a href="#提示-3" class="headerlink" title="提示"></a>提示</h2><h4 id="数据规模与约定-1"><a href="#数据规模与约定-1" class="headerlink" title="数据规模与约定"></a>数据规模与约定</h4><p>对于全部的测试点，保证 $1 \leq n \leq 3.2 \times 10^4$，$1 \leq m \leq 60$，$0 \leq v_i \leq 10^4$，$1 \leq p_i \leq 5$，$0 \leq q_i \leq m$，答案不超过 $2 \times 10^5$。</p>
<h3 id="Analyse：-3"><a href="#Analyse：-3" class="headerlink" title="Analyse："></a>Analyse：</h3><ol>
<li><ul>
<li><p>我们可以对主件i的“附件集合”先进行一次01背包，得到费用依次为0..V-c[i]。所有这些值时相应的最大价值f’[0..V-c[i]]。</p>
</li>
<li><p>那么这个主件及它的附件集合相当于V-c[i]+1个物品的物品组，其中费用为c[i]+k的物品的价值为f’[k]+w[i]。也就是说原来指数级的策略中有很多策略都是冗余的，通过一次01背包后，将主件i转化为V-c[i]+1个物品的物品组，就可以直接解决问题了。</p>
</li>
</ul>
</li>
</ol>
<h3 id="My-Code-2"><a href="#My-Code-2" class="headerlink" title="My Code:"></a>My Code:</h3><pre><code>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
using namespace std;
int n,m,x,y,id,f2[60][3201],num[60],t1;
struct node&#123;
    int v,c,d1,d2,c1,c2;
&#125;a[51];
int re()
&#123;
    int a=0,f=1;
    char ch=getchar();
    while(ch&lt;&#39;0&#39; || ch&gt;&#39;9&#39;) &#123;
        if(ch==&#39;-&#39;) f=-1;ch=getchar();
        &#125;
    while(ch&gt;=&#39;0&#39; &amp;&amp; ch&lt;=&#39;9&#39;) &#123;
        a=(a&lt;&lt;1)+(a&lt;&lt;3)+ch-&#39;0&#39;;ch=getchar();
        &#125;
    return a*f;
&#125;
int main()
&#123;
    n=re()/10;m=re();
    for(int i=1;i&lt;=m;i++)
    &#123;
        x=re()/10;
        y=re()*x;
        id=re();
        if(id)
        &#123;
            id=num[id];
            if(a[id].d1) a[id].d2=y,a[id].c2=x;
            else a[id].d1=y,a[id].c1=x;
        &#125;
        else a[++t1].c=x,a[t1].v=y,num[i]=t1;
    &#125;
    m=t1;
    for(int i=1;i&lt;=m;i++)
      for(int j=n;j;j--)
      &#123;
      	f2[i][j]=f2[i-1][j];
      	if(j&gt;=a[i].c) f2[i][j]=max(f2[i][j],f2[i-1][j-a[i].c]+a[i].v);
      	if(j&gt;=a[i].c+a[i].c1) f2[i][j]=max(f2[i][j],f2[i-1][j-a[i].c-a[i].c1]+a[i].v+a[i].d1);
      	if(j&gt;=a[i].c+a[i].c2) f2[i][j]=max(f2[i][j],f2[i-1][j-a[i].c-a[i].c2]+a[i].v+a[i].d2);
      	if(j&gt;=a[i].c+a[i].c1+a[i].c2) f2[i][j]=max(f2[i][j],f2[i-1][j-a[i].c-a[i].c1-a[i].c2]+a[i].v+a[i].d1+a[i].d2);
      &#125;
    cout&lt;&lt;f2[m][n]*10;
    
    return 0;
&#125;
</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/01/09/week8/" data-id="clfi3u93h000bgcw1b52j3uo2" data-title="week8" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Test-7" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/12/19/Test-7/" class="article-date">
  <time class="dt-published" datetime="2022-12-19T12:14:51.000Z" itemprop="datePublished">2022-12-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/12/19/Test-7/">Test 7</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>This is the 7th week.</p>
<h3 id="NOIP2005-普及组-采药"><a href="#NOIP2005-普及组-采药" class="headerlink" title="[NOIP2005 普及组] 采药"></a>[NOIP2005 普及组] 采药</h3><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>辰辰是个天资聪颖的孩子，他的梦想是成为世界上最伟大的医师。为此，他想拜附近最有威望的医师为师。医师为了判断他的资质，给他出了一个难题。医师把他带到一个到处都是草药的山洞里对他说：“孩子，这个山洞里有一些不同的草药，采每一株都需要一些时间，每一株也有它自身的价值。我会给你一段时间，在这段时间里，你可以采到一些草药。如果你是一个聪明的孩子，你应该可以让采到的草药的总价值最大。”</p>
<p>如果你是辰辰，你能完成这个任务吗？</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行有 $2$ 个整数 $T$（$1 \le T \le 1000$）和 $M$（$1 \le  M \le 100$），用一个空格隔开，$T$ 代表总共能够用来采药的时间，$M$ 代表山洞里的草药的数目。</p>
<p>接下来的 $M$ 行每行包括两个在 $1$ 到 $100$ 之间（包括 $1$ 和 $100$）的整数，分别表示采摘某株草药的时间和这株草药的价值。</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出在规定的时间内可以采到的草药的最大总价值。</p>
<h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">70 3</span><br><span class="line">71 100</span><br><span class="line">69 1</span><br><span class="line">1 2</span><br></pre></td></tr></table></figure>

<h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>

<h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p><strong>【数据范围】</strong></p>
<ul>
<li>对于 $30%$ 的数据，$M \le 10$；</li>
<li>对于全部的数据，$M \le 100$。</li>
</ul>
<p><strong>【题目来源】</strong></p>
<p>NOIP 2005 普及组第三题</p>
<h3 id="Analyse："><a href="#Analyse：" class="headerlink" title="Analyse："></a>Analyse：</h3><p>所以我们就可以不用记下草药的序号，只需要留下采药所需的时间就行，至于该不该采药，在自己的基础上进行判断就行。</p>
<p>则建立一个数组dp[1000];</p>
<p>递推公式同二维数组非常相似，只是删掉了表示序号的那维数组</p>
<h3 id="My-Code"><a href="#My-Code" class="headerlink" title="My Code:"></a>My Code:</h3><pre><code>#include&lt;iostream&gt;
using namespace std;
int A[1001],w[1001],C[1001];
int main()&#123;
    int t,m;
    cin&gt;&gt;t&gt;&gt;m;
    for(int i=1;i&lt;=m;i++)&#123;
        cin&gt;&gt;w[i]&gt;&gt;C[i];
    &#125; 
    for(int i=1;i&lt;=m;i++)
    for(int j=t;j&gt;=0;j--)&#123;
        if(j&gt;=w[i])&#123;
            A[j]=max(A[j-w[i]]+C[i],A[j]);
        &#125;
    &#125;
    cout&lt;&lt;A[t];
&#125;
</code></pre>
<p>模拟与高精度</p>
<p>This is the 4th week.</p>
<h2 id="最长上升子序列"><a href="#最长上升子序列" class="headerlink" title="# 最长上升子序列"></a># 最长上升子序列</h2><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>这是一个简单的动规板子题。</p>
<p>给出一个由 $n(n\le 5000)$ 个不超过 $10^6$ 的正整数组成的序列。请输出这个序列的<strong>最长上升子序列</strong>的长度。</p>
<p>最长上升子序列是指，从原序列中<strong>按顺序</strong>取出一些数字排在一起，这些数字是<strong>逐渐增大</strong>的。</p>
<h2 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行，一个整数 $n$，表示序列长度。</p>
<p>第二行有 $n$ 个整数，表示这个序列。</p>
<h2 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h2><p>一个整数表示答案。</p>
<h2 id="样例-1-1"><a href="#样例-1-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-1"><a href="#样例输入-1-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">6</span><br><span class="line">1 2 4 1 3 4</span><br></pre></td></tr></table></figure>

<h3 id="样例输出-1-1"><a href="#样例输出-1-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure>

<h2 id="提示-1"><a href="#提示-1" class="headerlink" title="提示"></a>提示</h2><p>分别取出 $1$、$2$、$3$、$4$ 即可。](<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1605">https://www.luogu.com.cn/problem/P1605</a>)</p>
<h3 id="Analyse：-1"><a href="#Analyse：-1" class="headerlink" title="Analyse："></a>Analyse：</h3><ol>
<li><p>算法实现</p>
<p>通过构造q[]，求出最长严格单调递增子序列的长度len：</p>
<ol>
<li><p>遍历序列中的每个数a[i]</p>
</li>
<li><p>如果a[i]&gt;q[len]，q[++len]&#x3D;a[i]</p>
</li>
<li><p>否则在q[]数组中找到第一个大于等于a[i]的数，将其更新为a[i]</p>
</li>
</ol>
</li>
</ol>
<h3 id="My-Code-1"><a href="#My-Code-1" class="headerlink" title="My Code:"></a>My Code:</h3><pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long ll;
const ll mmax=1e6+10;
ll a[mmax],lis[mmax];
ll len; 
ll find(ll x)
&#123;
     ll l=0,r=len;
     while(l&lt;r)
     &#123;
          ll mid=(l+r)&gt;&gt;1;
          if(lis[mid]&gt;=x)
          	 r=mid;
          else
           	l=mid+1;
    &#125;
     return l;
&#125;
int main()
&#123;
     ll n;
     memset(a,0,sizeof(a));
     memset(lis,0,sizeof(lis));
     cin&gt;&gt;n;
     for(int i=0;i&lt;n;i++)
      	cin&gt;&gt;a[i]; 
     lis[0]=a[0];
     len=0;
     for(int i=1;i&lt;n;i++)
     &#123;
          if(a[i]&gt;lis[len])
          &#123;
           	lis[++len]=a[i]; 
          &#125;
          else
          &#123;
           	ll k=find(a[i]);
           	lis[k]=a[i];
          &#125; 
    &#125; 
    cout&lt;&lt;len+1&lt;&lt;endl;
     return 0;
&#125; 
</code></pre>
<h1 id="最大子段和"><a href="#最大子段和" class="headerlink" title="最大子段和"></a>最大子段和</h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>给出一个长度为 $n$ 的序列 $a$，选出其中连续且非空的一段使得这段和最大。</p>
<h2 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行是一个整数，表示序列的长度 $n$。</p>
<p>第二行有 $n$ 个整数，第 $i$ 个整数表示序列的第 $i$ 个数字 $a_i$。</p>
<h2 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一行一个整数表示答案。</p>
<h2 id="样例-1-2"><a href="#样例-1-2" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-2"><a href="#样例输入-1-2" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">7</span><br><span class="line">2 -4 3 -1 2 -4 3</span><br></pre></td></tr></table></figure>

<h3 id="样例输出-1-2"><a href="#样例输出-1-2" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure>

<h2 id="提示-2"><a href="#提示-2" class="headerlink" title="提示"></a>提示</h2><h4 id="样例-1-解释"><a href="#样例-1-解释" class="headerlink" title="样例 1 解释"></a>样例 1 解释</h4><p>选取 $[3, 5]$ 子段 ${3, -1, 2}$，其和为 $4$。</p>
<h4 id="数据规模与约定"><a href="#数据规模与约定" class="headerlink" title="数据规模与约定"></a>数据规模与约定</h4><ul>
<li>对于 $40%$ 的数据，保证 $n \leq 2 \times 10^3$。</li>
<li>对于 $100%$ 的数据，保证 $1 \leq n \leq 2 \times 10^5$，$-10^4 \leq a_i \leq 10^4$。</li>
</ul>
<h3 id="Analyse：-2"><a href="#Analyse：-2" class="headerlink" title="Analyse："></a>Analyse：</h3><p>然后想到用<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E8%B4%AA%E5%BF%83&spm=1001.2101.3001.7020">贪心</a>的思想（我并没有学，但是了解一点点）</p>
<p>首先考虑第一种情况，全是负数，则只要选出最大的就行；</p>
<p>其它情况：就是用一个 x记录当前前缀和，一路累积过去，如果前缀和  x变成了负数，那么下一个数就不需要前面的数了（因为还不如只选它一个），这时把 x置为0，再继续累加</p>
<h3 id="My-Code-2"><a href="#My-Code-2" class="headerlink" title="My Code:"></a>My Code:</h3><pre><code>#include &lt;iostream&gt;
using namespace std;
int a[200001];
int main()
&#123;
    int n ;
    cin &gt;&gt; n;
    for(int i = 0;i &lt; n;i++)
    &#123;
        scanf(&quot;%d&quot; ,&amp;a[i]);
    &#125;
    int x = 0,max = a[0];
    for(int i = 0;i &lt; n;i++)
    &#123;
        x += a[i];
        if(x &gt;= max)
            max = x;
        if(x &lt;= 0)
            x = 0;
    &#125;
   cout &lt;&lt; max;
    return 0;
&#125;
</code></pre>
<p>模拟与高精度</p>
<p>This is the 4th week.</p>
<h3 id="LCS"><a href="#LCS" class="headerlink" title="LCS"></a>LCS</h3><h2 id="题面翻译"><a href="#题面翻译" class="headerlink" title="题面翻译"></a>题面翻译</h2><p>题目描述：</p>
<p>给定一个字符串 $s$ 和一个字符串 $t$ ，输出 $s$ 和 $t$ 的最长公共子序列。</p>
<p>输入格式：</p>
<p>两行，第一行输入 $s$ ，第二行输入 $t$ 。</p>
<p>输出格式：</p>
<p>输出 $s$ 和 $t$ 的最长公共子序列。如果有多种答案，输出任何一个都可以。</p>
<p>说明&#x2F;提示：</p>
<p>数据保证 $s$ 和 $t$ 仅含英文小写字母，并且 $s$ 和 $t$ 的长度小于等于3000。</p>
<h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p>文字列 $ s $ および $ t $ が与えられます。 $ s $ の部分列かつ $ t $ の部分列であるような文字列のうち、最長のものをひとつ求めてください。</p>
<h2 id="输入格式-3"><a href="#输入格式-3" class="headerlink" title="输入格式"></a>输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p>
<blockquote>
<p>$ s $ $ t $</p>
</blockquote>
<h2 id="输出格式-3"><a href="#输出格式-3" class="headerlink" title="输出格式"></a>输出格式</h2><p>$ s $ の部分列かつ $ t $ の部分列であるような文字列のうち、最長のものをひとつ出力せよ。 答えが複数ある場合、どれを出力してもよい。</p>
<h2 id="样例-1-3"><a href="#样例-1-3" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-3"><a href="#样例输入-1-3" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">axyb</span><br><span class="line">abyxb</span><br></pre></td></tr></table></figure>

<h3 id="样例输出-1-3"><a href="#样例输出-1-3" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">axb</span><br></pre></td></tr></table></figure>

<h2 id="样例-2"><a href="#样例-2" class="headerlink" title="样例 #2"></a>样例 #2</h2><h3 id="样例输入-2"><a href="#样例输入-2" class="headerlink" title="样例输入 #2"></a>样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">aa</span><br><span class="line">xayaz</span><br></pre></td></tr></table></figure>

<h3 id="样例输出-2"><a href="#样例输出-2" class="headerlink" title="样例输出 #2"></a>样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aa</span><br></pre></td></tr></table></figure>

<h2 id="样例-3"><a href="#样例-3" class="headerlink" title="样例 #3"></a>样例 #3</h2><h3 id="样例输入-3"><a href="#样例输入-3" class="headerlink" title="样例输入 #3"></a>样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a</span><br><span class="line">z</span><br></pre></td></tr></table></figure>

<h3 id="样例输出-3"><a href="#样例输出-3" class="headerlink" title="样例输出 #3"></a>样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="样例-4"><a href="#样例-4" class="headerlink" title="样例 #4"></a>样例 #4</h2><h3 id="样例输入-4"><a href="#样例输入-4" class="headerlink" title="样例输入 #4"></a>样例输入 #4</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">abracadabra</span><br><span class="line">avadakedavra</span><br></pre></td></tr></table></figure>

<h3 id="样例输出-4"><a href="#样例输出-4" class="headerlink" title="样例输出 #4"></a>样例输出 #4</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aaadara</span><br></pre></td></tr></table></figure>

<h2 id="提示-3"><a href="#提示-3" class="headerlink" title="提示"></a>提示</h2><h3 id="注釈"><a href="#注釈" class="headerlink" title="注釈"></a>注釈</h3><p>文字列 $ x $ の<em>部分列</em>とは、$ x $ から $ 0 $ 個以上の文字を取り除いた後、残りの文字を元の順序で連結して得られる文字列のことです。</p>
<h3 id="制約"><a href="#制約" class="headerlink" title="制約"></a>制約</h3><ul>
<li>$ s $ および $ t $ は英小文字からなる文字列である。</li>
<li>$ 1\ \leq\ |s|,\ |t|\ \leq\ 3000 $</li>
</ul>
<h3 id="Sample-Explanation-1"><a href="#Sample-Explanation-1" class="headerlink" title="Sample Explanation 1"></a>Sample Explanation 1</h3><p>答えは <code>axb</code> または <code>ayb</code> です。 どちらを出力しても正解となります。</p>
<h3 id="Sample-Explanation-3"><a href="#Sample-Explanation-3" class="headerlink" title="Sample Explanation 3"></a>Sample Explanation 3</h3><p>答えは &#96;&#96; (空文字列) です。</p>
<h3 id="Analyse：-3"><a href="#Analyse：-3" class="headerlink" title="Analyse："></a>Analyse：</h3><ol>
<li>由于每次调用至少向上或向左（或向上向左同时）移动一步，故最多调用(m + n)次就会遇到i &#x3D; 0或j &#x3D; 0的情况，此时开始返回。返回时与递归调用时方向相反，步数相同，故算法时间复杂度为Θ(m + n)。</li>
</ol>
<h3 id="My-Code-3"><a href="#My-Code-3" class="headerlink" title="My Code:"></a>My Code:</h3><pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#define MAXLEN 100

void LCSLength(char *x, char *y, int m, int n, int c[][MAXLEN], int b[][MAXLEN])
&#123;
    int i, j;
    for (i = 0; i &lt;= m; i++)
        c[i][0] = 0;
    for (j = 1; j &lt;= n; j++)
        c[0][j] = 0;
    for (i = 1; i &lt;= m; i++)
    &#123;
        for (j = 1; j &lt;= n; j++)
        &#123;
            if (x[i - 1] == y[j - 1])
            &#123;
                c[i][j] = c[i - 1][j - 1] + 1;
                b[i][j] = 0;
            &#125;
            else if (c[i - 1][j] &gt;= c[i][j - 1])
            &#123;
                c[i][j] = c[i - 1][j];
                b[i][j] = 1;
            &#125;
            else
            &#123;
                c[i][j] = c[i][j - 1];
                b[i][j] = -1;
            &#125;
        &#125;
    &#125;
&#125;

void PrintLCS(int b[][MAXLEN], char *x, int i, int j)
&#123;
    if (i == 0 || j == 0)
        return;
    if (b[i][j] == 0)
    &#123;
        PrintLCS(b, x, i - 1, j - 1);
        printf(&quot;%c &quot;, x[i - 1]);
    &#125;
    else if (b[i][j] == 1)
        PrintLCS(b, x, i - 1, j);
    else
        PrintLCS(b, x, i, j - 1);
&#125;

int main(int argc, char **argv)
&#123;
    char x[MAXLEN] = &#123; &quot;ABCBDAB&quot; &#125;;
    char y[MAXLEN] = &#123; &quot;BDCABA&quot; &#125;;
    int b[MAXLEN][MAXLEN];
    int c[MAXLEN][MAXLEN];
    int m, n;

    m = strlen(x);
    n = strlen(y);

    LCSLength(x, y, m, n, c, b);
    PrintLCS(b, x, m, n);

    return 0;
&#125;
</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/12/19/Test-7/" data-id="clfi3u93d0004gcw1gp5nc9f8" data-title="Test 7" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Sixth" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/12/05/Sixth/" class="article-date">
  <time class="dt-published" datetime="2022-12-05T12:22:18.839Z" itemprop="datePublished">2022-12-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>###求最小值，就找出所有向两边的距离的小的一个的最大值  </p>
<hr>
<p>title: Sixth<br>date: 2022-12-05 20:22:18<br>tags:</p>
<hr>
<p>This is the 5th week.</p>
<h4 id="NOIP2010-普及组-三国游戏"><a href="#NOIP2010-普及组-三国游戏" class="headerlink" title="[NOIP2010 普及组] 三国游戏"></a>[NOIP2010 普及组] 三国游戏</h4><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>小涵很喜欢电脑游戏，这些天他正在玩一个叫做《三国》的游戏。</p>
<p>在游戏中，小涵和计算机各执一方，组建各自的军队进行对战。游戏中共有 $N$ 位武将（$N$为偶数且不小于$4$），任意两个武将之间有一个“默契值”，表示若此两位武将作为一对组合作战时，该组合的威力有多大。游戏开始前，所有武将都是自由的（称为自由武将，一旦某个自由武将被选中作为某方军队的一员，那么他就不再是自由武将了），换句话说，所谓的自由武将不属于任何一方。</p>
<p>游戏开始，小涵和计算机要从自由武将中挑选武将组成自己的军队，规则如下：小涵先从自由武将中选出一个加入自己的军队，然后计算机也从自由武将中选出一个加入计算机方的军队。接下来一直按照“小涵→计算机→小涵→……”的顺序选择武将，直到所有的武将被双方均分完。然后，程序自动从双方军队中各挑出一对默契值最高的武将组合代表自己的军队进行二对二比武，拥有更高默契值的一对武将组合获胜，表示两军交战，拥有获胜武将组合的一方获胜。</p>
<p>已知计算机一方选择武将的原则是尽量破坏对手下一步将形成的最强组合，它采取的具体策略如下：任何时刻，轮到计算机挑选时，它会尝试将对手军队中的每个武将与当前每个自由武将进行一一配对，找出所有配对中默契值最高的那对武将组合，并将该组合中的自由武将选入自己的军队。 下面举例说明计算机的选将策略，例如，游戏中一共有$6$个武将，他们相互之间的默契值如下表所示：</p>
<p> <img src="https://cdn.luogu.com.cn/upload/pic/54.png"> </p>
<p>双方选将过程如下所示：</p>
<p> <img src="https://cdn.luogu.com.cn/upload/pic/55.png"> </p>
<p>小涵想知道，如果计算机在一局游戏中始终坚持上面这个策略，那么自己有没有可能必胜？如果有，在所有可能的胜利结局中，自己那对用于比武的武将组合的默契值最大是多少？  </p>
<p>假设整个游戏过程中，对战双方任何时候均能看到自由武将队中的武将和对方军队的武将。为了简化问题，保证对于不同的武将组合，其默契值均不相同。</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>共 N 行。</p>
<p>第一行为一个偶数 $N$，表示武将的个数。</p>
<p>第 $2 $行到第 $N $行里，第$i+1$行有$N_i$个非负整数，每两个数之间用一个空格隔开，表示$ i $号武将和$ i+1,i+2,…,N $号武将之间的默契值（$0≤$默契值$≤1,000,000,000$）。</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>共 $1$ 或 $2 $行。</p>
<p>若对于给定的游戏输入，存在可以让小涵获胜的选将顺序，则输出$ 1$，并另起一行输出所有获胜的情况中，小涵最终选出的武将组合的最大默契值。如果不存在可以让小涵获胜的选将顺序，则输出 $0$。</p>
<h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">6 </span><br><span class="line">5 28 16 29 27 </span><br><span class="line">23 3 20 1 </span><br><span class="line">8 32 26 </span><br><span class="line">33 11 </span><br><span class="line">12</span><br></pre></td></tr></table></figure>

<h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">32</span><br></pre></td></tr></table></figure>

<h2 id="样例-2"><a href="#样例-2" class="headerlink" title="样例 #2"></a>样例 #2</h2><h3 id="样例输入-2"><a href="#样例输入-2" class="headerlink" title="样例输入 #2"></a>样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">8 </span><br><span class="line">42 24 10 29 27 12 58 </span><br><span class="line">31 8 16 26 80 6 </span><br><span class="line">25 3 36 11 5 </span><br><span class="line">33 20 17 13 </span><br><span class="line">15 77 9 </span><br><span class="line">4 50 </span><br><span class="line">19</span><br></pre></td></tr></table></figure>

<h3 id="样例输出-2"><a href="#样例输出-2" class="headerlink" title="样例输出 #2"></a>样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">77</span><br></pre></td></tr></table></figure>

<h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p>【数据范围】</p>
<p>对于$ 40%$的数据有 $N≤10$。</p>
<p>对于$ 70%$的数据有$ N≤18$。</p>
<p>对于 $100%$的数据有 $N≤500$。</p>
<h3 id="Analyse："><a href="#Analyse：" class="headerlink" title="Analyse："></a>Analyse：</h3><p>&#x2F;&#x2F;本题是博弈论 拿到所有组合中的最大第二大 必赢 人不可能拿到最大的 &#x2F;&#x2F;博弈论的特点 就是 &#x2F;<em>1、博弈模型为两人轮流决策的非合作博弈。即两人轮流进行决策，并且两人都使用最优策略来获取胜利。2、博弈是有限的。即无论两人怎样决策，都会在有限步后决出胜负。3、公平博弈。即两人进行决策所遵循的规则相同。</em></p>
<h3 id="My-Code"><a href="#My-Code" class="headerlink" title="My Code:"></a>My Code:</h3><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
const int maxm = 5005;
int n, m, ans;
struct farmer 
&#123;
    int p, a;
&#125; f[maxm];
bool cmp (farmer a, farmer b) 
&#123;
    return a.p &lt; b.p;
&#125;
int main ()
&#123;
    scanf (&quot;%d %d&quot;, &amp;n, &amp;m);
    for (int i = 1; i &lt;= m; i++) 
    &#123;
        scanf (&quot;%d %d&quot;, &amp;f[i].p, &amp;f[i].a);
    &#125;
    sort (f + 1, f + m + 1, cmp);
    int p = 1;
    while (n &gt; 0) 
    &#123;
        if (n &gt;= f[p].a) 
        &#123;
            n -= f[p].a;
            ans += (f[p].a * f[p].p);
        &#125;
        else 
        &#123;
            ans += (n * f[p].p);
            n = 0;
        &#125;
        p ++;
    &#125;
    printf (&quot;%d&quot;, ans);
    return 0;
&#125;
</code></pre>
<p>his is the 4th week.</p>
<h2 id="独木桥"><a href="#独木桥" class="headerlink" title="# 独木桥"></a># 独木桥</h2><h2 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h2><p>战争已经进入到紧要时间。你是运输小队长，正在率领运输部队向前线运送物资。运输任务像做题一样的无聊。你希望找些刺激，于是命令你的士兵们到前方的一座独木桥上欣赏风景，而你留在桥下欣赏士兵们。士兵们十分愤怒，因为这座独木桥十分狭窄，只能容纳 $1$ 个人通过。假如有 $2$ 个人相向而行在桥上相遇，那么他们 $2$ 个人将无法绕过对方，只能有 $1$ 个人回头下桥，让另一个人先通过。但是，可以有多个人同时呆在同一个位置。</p>
<h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>突然，你收到从指挥部发来的信息，敌军的轰炸机正朝着你所在的独木桥飞来！为了安全，你的部队必须撤下独木桥。独木桥的长度为 $L$，士兵们只能呆在坐标为整数的地方。所有士兵的速度都为 $1$，但一个士兵某一时刻来到了坐标为 $0$ 或 $L+1$ 的位置，他就离开了独木桥。</p>
<p>每个士兵都有一个初始面对的方向，他们会以匀速朝着这个方向行走，中途不会自己改变方向。但是，如果两个士兵面对面相遇，他们无法彼此通过对方，于是就分别转身，继续行走。转身不需要任何的时间。</p>
<p>由于先前的愤怒，你已不能控制你的士兵。甚至，你连每个士兵初始面对的方向都不知道。因此，你想要知道你的部队最少需要多少时间就可能全部撤离独木桥。另外，总部也在安排阻拦敌人的进攻，因此你还需要知道你的部队最多需要多少时间才能全部撤离独木桥。</p>
<h2 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行共一个整数 $L$，表示独木桥的长度。桥上的坐标为 $1, 2, \cdots, L$。</p>
<p>第二行共一个整数 $N$，表示初始时留在桥上的士兵数目。</p>
<p>第三行共有 $N$ 个整数，分别表示每个士兵的初始坐标。</p>
<h2 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h2><p>共一行，输出 $2$ 个整数，分别表示部队撤离独木桥的最小时间和最大时间。$2$ 个整数由一个空格符分开。</p>
<h2 id="样例-1-1"><a href="#样例-1-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-1"><a href="#样例输入-1-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">2</span><br><span class="line">1 3</span><br></pre></td></tr></table></figure>

<h3 id="样例输出-1-1"><a href="#样例输出-1-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2 4</span><br></pre></td></tr></table></figure>

<h2 id="提示-1"><a href="#提示-1" class="headerlink" title="提示"></a>提示</h2><p>对于 $100%$ 的数据，满足初始时，没有两个士兵同在一个坐标，$1\le  L\le5\times 10^3$，$0\le N\le5\times10^3$，且数据保证 $N\le L$。</p>
<h3 id="Analyse：-1"><a href="#Analyse：-1" class="headerlink" title="Analyse："></a>Analyse：</h3><h3 id="求最小值，就找出所有向两边的距离的小的一个的最大值"><a href="#求最小值，就找出所有向两边的距离的小的一个的最大值" class="headerlink" title="求最小值，就找出所有向两边的距离的小的一个的最大值"></a>求最小值，就找出所有向两边的距离的小的一个的最大值</h3><h3 id="My-Code-1"><a href="#My-Code-1" class="headerlink" title="My Code:"></a>My Code:</h3><pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
int n,m,minx,maxx;
int max(const int &amp;a,const int &amp;b)&#123;
    return a&gt;b?a:b;
&#125;
int min(const int &amp;a,const int &amp;b)&#123;
    return a&lt;b?a:b;
&#125;
int main()&#123;
    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
    int x;
    maxx=0;
    minx=0;
    for(int i=1;i&lt;=m;i++)&#123;
        scanf(&quot;%d&quot;,&amp;x);
        maxx=max(maxx,max(x,n-x+1));
        minx=max(minx,min(x,n-x+1));
    &#125;
    cout&lt;&lt;minx&lt;&lt;&quot; &quot;&lt;&lt;maxx;
    return 0;
&#125;
</code></pre>
<h1 id="NOIP2004-提高组-合并果子-x2F-USACO06NOV-Fence-Repair-G"><a href="#NOIP2004-提高组-合并果子-x2F-USACO06NOV-Fence-Repair-G" class="headerlink" title="[NOIP2004 提高组] 合并果子 &#x2F; [USACO06NOV] Fence Repair G"></a>[NOIP2004 提高组] 合并果子 &#x2F; [USACO06NOV] Fence Repair G</h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>在一个果园里，多多已经将所有的果子打了下来，而且按果子的不同种类分成了不同的堆。多多决定把所有的果子合成一堆。</p>
<p>每一次合并，多多可以把两堆果子合并到一起，消耗的体力等于两堆果子的重量之和。可以看出，所有的果子经过 $n-1$ 次合并之后， 就只剩下一堆了。多多在合并果子时总共消耗的体力等于每次合并所耗体力之和。</p>
<p>因为还要花大力气把这些果子搬回家，所以多多在合并果子时要尽可能地节省体力。假定每个果子重量都为 $1$ ，并且已知果子的种类 数和每种果子的数目，你的任务是设计出合并的次序方案，使多多耗费的体力最少，并输出这个最小的体力耗费值。</p>
<p>例如有 $3$ 种果子，数目依次为 $1$ ， $2$ ， $9$ 。可以先将 $1$ 、 $2$ 堆合并，新堆数目为 $3$ ，耗费体力为 $3$ 。接着，将新堆与原先的第三堆合并，又得到新的堆，数目为 $12$ ，耗费体力为 $12$ 。所以多多总共耗费体力 $&#x3D;3+12&#x3D;15$ 。可以证明 $15$ 为最小的体力耗费值。</p>
<h2 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式"></a>输入格式</h2><p>共两行。<br>第一行是一个整数 $n(1\leq n\leq 10000)$ ，表示果子的种类数。  </p>
<p>第二行包含 $n$ 个整数，用空格分隔，第 $i$ 个整数 $a_i(1\leq a_i\leq 20000)$ 是第 $i$ 种果子的数目。</p>
<h2 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式"></a>输出格式</h2><p>一个整数，也就是最小的体力耗费值。输入数据保证这个值小于 $2^{31}$ 。</p>
<h2 id="样例-1-2"><a href="#样例-1-2" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-2"><a href="#样例输入-1-2" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3 </span><br><span class="line">1 2 9</span><br></pre></td></tr></table></figure>

<h3 id="样例输出-1-2"><a href="#样例输出-1-2" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">15</span><br></pre></td></tr></table></figure>

<h2 id="提示-2"><a href="#提示-2" class="headerlink" title="提示"></a>提示</h2><p>对于 $30%$ 的数据，保证有 $n \le 1000$：</p>
<p>对于 $50%$ 的数据，保证有 $n \le 5000$；</p>
<p>对于全部的数据，保证有 $n \le 10000$。</p>
<h3 id="Analyse：-2"><a href="#Analyse：-2" class="headerlink" title="Analyse："></a>Analyse：</h3><p>使用优先队列，很简单。需要注意的是，因为要求搬放重量最小的果子，所以往优先队列里放入果子的重量x时，输入-x。这样重量最小的成为了最优先的。</p>
<h3 id="My-Code-2"><a href="#My-Code-2" class="headerlink" title="My Code:"></a>My Code:</h3><pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
priority_queue&lt;int&gt; que;
int main()
&#123;
    int n,ans=0;
    cin&gt;&gt;n;
    int x;
    for(int i=0;i&lt;n;i++)
    &#123;
        cin&gt;&gt;x;
        que.push(-x);//放入负数是为了让最小的数在最前，达到优先的效果 （也可以自定义优先级，重载默认的 &lt; 符号）
    &#125;
    int tmp;
    for(int i=1;i&lt;n;i++)
    &#123;
        tmp=que.top();
        ans-=que.top();//减去负值即为正值
        que.pop();
        tmp+=que.top();
        ans-=que.top();
        que.pop();
        que.push(tmp);
    &#125;
    cout&lt;&lt;ans&lt;&lt;endl;
    return 0;
&#125;
</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/12/05/Sixth/" data-id="clfi3u93b0002gcw1hynk1074" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-双周1" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/11/28/%E5%8F%8C%E5%91%A81/" class="article-date">
  <time class="dt-published" datetime="2022-11-28T13:35:31.000Z" itemprop="datePublished">2022-11-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/11/28/%E5%8F%8C%E5%91%A81/">双周1</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>7-1 Lily</p>
<p>分数 300</p>
<p>全屏浏览题目</p>
<p>切换布局</p>
<p>作者 neuqAcmClub</p>
<p>单位 东北大学秦皇岛分校</p>
<p>百合花（Lily）是一种美丽的花。她通常一年只开一次花，所以如果你看到百合花盛开，它会非常珍贵。然而，她对猫有剧毒，所以你必须注意让好奇的猫远离可爱的百合花。</p>
<p>你有n个网格的土壤土地排成一行，从1到n，其中一些是百合花。我们不想伤害百合，也不想伤害猫。你可以在网格上放一些猫粮，但对于任何有猫粮的网格i，在区域[i−1,i+1]不得含有百合花。你喜欢猫和百合，所以你想最大限度地增加有猫粮的格子。</p>
<p>设计满足上述要求的计划。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>有一个整数n（1≤n≤1000）表示网格的数量。</p>
<p>第二行包含仅由“L”和“.”组成的字符串R，表示有和没有百合花的格子。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>输出包含一行，字符串R′仅由“L”、“”组成和“C”，其中“C”表示在满足上述要求的同时分配给R中空网格的猫粮。</p>
<h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><p>在这里给出一组输入。例如：</p>
<pre><code>5
..L..
</code></pre>
<h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><p>在这里给出相应的输出。例如：</p>
<pre><code>C.L.C
</code></pre>
<p>输出样例:</p>
<p>在这里给出相应的输出。例如：</p>
<pre><code>C.L.C
</code></pre>
<p>Analyse：</p>
<p>先读入格子的状态</p>
<p>再遍历每一个格子检测其相邻格子中是否有有百合&#96;</p>
<ul>
<li><p>Code:</p>
<p> #include<iostream><br> using namespace std;<br> int main(){</p>
<pre><code> int n,m=1;
 int A[1005]=&#123;0&#125;;  
 char a[1005]=&#123;0&#125;;
 cin&gt;&gt;n;
 for(int i=1;i&lt;=n;i++)&#123;
     cin&gt;&gt;a[i]; 
 &#125;
 while(m&lt;=n)&#123;
     if(a[m]==&#39;L&#39;)&#123;
         A[i]=1;
         A[i+1]=1;
         A[i-1]=1;   
     &#125;
     m++;
 &#125;

 for(int i=1;i&lt;=n;i++)&#123;
     if(A[i]!=1)&#123;
         a[i]=&#39;C&#39;;  
     &#125;
 &#125;
 for(int i=1;i&lt;=n;i++)&#123;
     cout&lt;&lt;a[i];  
 &#125;

 return 0;
</code></pre>
<p> }</p>
</li>
</ul>
<p>7-2 a * b</p>
<p>分数 300</p>
<p>全屏浏览题目</p>
<p>切换布局</p>
<p>作者 neuqAcmClub</p>
<p>单位 东北大学秦皇岛分校</p>
<p>给出两个不超过1000位的十六进制数a,b。<br>求a∗b的值</p>
<h3 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>输入共两行，两个十六进制的数</p>
<h3 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>输出一行，表示a∗b</p>
<h3 id="输入样例-1"><a href="#输入样例-1" class="headerlink" title="输入样例:"></a>输入样例:</h3><p>在这里给出一组输入。例如：</p>
<pre><code>1BF52
1D4B42
</code></pre>
<h3 id="Analyse："><a href="#Analyse：" class="headerlink" title="Analyse："></a>Analyse：</h3><p>存储每个位置的数字时,我们要注意字母与数字的转化.同样,在输出时也要注意输出数字若大于等于10,就要转化成字母.</p>
<h3 id="My-Code"><a href="#My-Code" class="headerlink" title="My Code:"></a>My Code:</h3><ul>
<li>}a[N];</li>
</ul>
<h3 id="My-Code-1"><a href="#My-Code-1" class="headerlink" title="My Code:"></a>My Code:</h3><pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
map&lt;int,int&gt;a1[100001];
int n,q;
int main()
&#123;
    cin&gt;&gt;n&gt;&gt;q;
    for(int i=0;i&lt;q;i++)
    &#123;
        int a,b,c,d;
        cin&gt;&gt;a;
        if(a==1)
        &#123;
            cin&gt;&gt;b&gt;&gt;c&gt;&gt;d;
            a1[b][c]=d;  //用map数组记录k
        &#125;
        else
        &#123;
            cin&gt;&gt;b&gt;&gt;c;
            cout&lt;&lt;a1[b][c]&lt;&lt;endl;  //输出aij

        &#125;
    &#125;
    return 0;
&#125;
</code></pre>
<p>7-3 山头狙击战</p>
<p>分数 300</p>
<p>全屏浏览题目</p>
<p>切换布局</p>
<p>作者 neuqAcmClub</p>
<p>单位 东北大学秦皇岛分校</p>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>小明为了掩护大部队，单枪匹马同敌人周旋，后来被敌人包围在某山头……等等，为什么怎么听怎么像狼牙山五壮士！不过不用着急，这次小明携带了足够的弹药，完全可以将涌上来的敌人一个一个干掉。小明是个神枪手，只要他的枪膛中有子弹，他就能将在他射程m（用从敌人位置到山头的直线距离算）以内的一个敌人瞬间射杀。但如果在射程内没有敌人，出于节约子弹考虑和面子问题，小明会等待敌人靠近然后射击。<br>正当小明为自己的强大而自我膨胀时，他忽然发现了一个致命的失误：他携带的枪是单发枪，每射出一发子弹都必须花k秒钟的时间装子弹。而凶残的敌人才不会花时间等你换子弹呢。他们始终在以1m&#x2F;s的速度接近山头。而如果在一个敌人到达山头时小明无法将他击毙，那么我们可怜的小明就将牺牲在敌人的刺刀下。现在小明用心灵感应向你发出求助：要保住自己的性命并且歼灭所有敌人，小明最多只能用多少时间给枪装上一发子弹？<br>说明：假设一开始小明的枪中就有一发子弹，并且一旦确定一个装弹时间，小明始终会用这个时间完成子弹的装卸。希望你能帮助小明脱离险境。</p>
<h3 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式"></a>输入格式</h3><p>每组输入数据，第一行有两个整数n和m，（2≤n≤100,000; 1≤m≤10,000,000）n代表敌人个数，m代表小明的射程。<br>接下来有n行，每行一个整数mi,（1≤mi≤10,000,000），代表每个敌人一开始相对山头的距离（单位为米）。</p>
<h3 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式"></a>输出格式</h3><p>每组输出数据仅有一个整数，代表小明的换弹时间（单位为秒）。</p>
<p>样例输入</p>
<pre><code>6 100
236
120
120
120
120
120
</code></pre>
<p>样例输出</p>
<pre><code>25
</code></pre>
<p>Analyse：</p>
<p>敌人到射程才能开始开枪.</p>
<p>需要一个一个的来进行模拟</p>
<p>二分</p>
<h3 id="My-Code-2"><a href="#My-Code-2" class="headerlink" title="My Code:"></a>My Code:</h3><pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
map&lt;int,int&gt;a1[100001];
int n,q;
int main()
&#123;
    cin&gt;&gt;n&gt;&gt;q;
    for(int i=0;i&lt;q;i++)
    &#123;
        int a,b,c,d;
        cin&gt;&gt;a;
        if(a==1)
        &#123;
            cin&gt;&gt;b&gt;&gt;c&gt;&gt;d;
            a1[b][c]=d;  //用map数组记录k
        &#125;
        else
        &#123;
            cin&gt;&gt;b&gt;&gt;c;
            cout&lt;&lt;a1[b][c]&lt;&lt;endl;  //输出aij

        &#125;
    &#125;
    return 0;
&#125;
</code></pre>
<p>7-4 Reversing Linked List</p>
<p>分数 300</p>
<p>全屏浏览题目</p>
<p>切换布局</p>
<p>作者 陈越</p>
<p>单位 浙江大学</p>
<p>Given a constant K and a singly linked list L, you are supposed to reverse the links of every K elements on L. For example, given L being 1→2→3→4→5→6, if K&#x3D;3, then you must output 3→2→1→6→5→4; if K&#x3D;4, you must output 4→3→2→1→5→6.</p>
<h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line contains the address of the first node, a positive N (≤105) which is the total number of nodes, and a positive K (≤N) which is the length of the sublist to be reversed. The address of a node is a 5-digit nonnegative integer, and NULL is represented by -1.</p>
<p>Then N lines follow, each describes a node in the format:</p>
<pre><code>Address Data Next
</code></pre>
<p>where <code>Address</code> is the position of the node, <code>Data</code> is an integer, and <code>Next</code> is the position of the next node.</p>
<h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each case, output the resulting ordered linked list. Each node occupies a line, and is printed in the same format as in the input.</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><pre><code>00100 6 4
00000 4 99999
00100 1 12309
68237 6 -1
33218 3 00000
99999 5 68237
12309 2 33218
</code></pre>
<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><pre><code>00000 4 33218
33218 3 12309
12309 2 00100
00100 1 99999
99999 5 68237
68237 6 -1
</code></pre>
<p>Analyse：</p>
<p>就是用一个<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84&spm=1001.2101.3001.7020">二维数组</a>存储第i个柜子和第j个格子。个人认为用二维数组过于浪费空间，所以用STL中的map来存储。</p>
<ul>
<li><h3 id="My-Code-3"><a href="#My-Code-3" class="headerlink" title="My Code:"></a>My Code:</h3><p>  #include&lt;bits&#x2F;stdc++.h&gt;<br>  using namespace std;<br>  map&lt;int,int&gt;a1[100001];<br>  int n,q;<br>  int main()<br>  {</p>
<pre><code>  cin&gt;&gt;n&gt;&gt;q;
  for(int i=0;i&lt;q;i++)
  &#123;
      int a,b,c,d;
      cin&gt;&gt;a;
      if(a==1)
      &#123;
          cin&gt;&gt;b&gt;&gt;c&gt;&gt;d;
          a1[b][c]=d;  //用map数组记录k
      &#125;
      else
      &#123;
          cin&gt;&gt;b&gt;&gt;c;
          cout&lt;&lt;a1[b][c]&lt;&lt;endl;  //输出aij

      &#125;
  &#125;
  return 0;
</code></pre>
<p>  }</p>
</li>
</ul>
<p>7-5 一元三次方程</p>
<p>分数 300</p>
<p>全屏浏览题目</p>
<p>切换布局</p>
<p>作者 neuqAcmClub</p>
<p>单位 东北大学秦皇岛分校</p>
<p>给定一个形如ax3+bx2+cx+d&#x3D;0的一元三次方程。</p>
<p>已知该方程有三个不同的实数根（根与根之差的绝对值≥10−6），且根范围均在[p,q]之间，你需要解出这个方程的三个根。</p>
<h3 id="输入格式-3"><a href="#输入格式-3" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>第一行一个整数T(1≤T≤1000)，表示有T组数据</p>
<p>接下来T行，每行6个实数，分别表示a,b,c,d,p,q</p>
<p>数据保证：−102≤p,q≤102，且对于∀x∈[p,q],−106≤f(x)≤106</p>
<h3 id="输出格式-3"><a href="#输出格式-3" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>输出三个实数，表示方程的三个解。</p>
<p>你的答案可以以任意顺序输出。</p>
<p>一个答案被认为是正确的，当且仅当其与标准答案的绝对误差不超过10−6</p>
<h3 id="输入样例-2"><a href="#输入样例-2" class="headerlink" title="输入样例:"></a>输入样例:</h3><p>在这里给出一组输入。例如：</p>
<pre><code>1
1.000000 -5.000000 -4.000000 20.000000 -10.000000 10.000000
</code></pre>
<h3 id="输出样例-1"><a href="#输出样例-1" class="headerlink" title="输出样例:"></a>输出样例:</h3><p>在这里给出相应的输出。例如：</p>
<pre><code>-2.000000 2.000000 5.000000
</code></pre>
<h3 id="提示1："><a href="#提示1：" class="headerlink" title="提示1："></a>提示1：</h3><p>样例所给方程的图像如下：</p>
<p><img src="https://images.ptausercontent.com/0600ddcf-0496-4697-a16c-5f7ceccf042f.png" alt="T4.png"></p>
<h3 id="分析：必定在p和q的区间里有极大值点a和极小值点b-则方程的解也就是在-p-min-a-b-min-a-b-max-a-b-max-a-b-q-这三个区间内"><a href="#分析：必定在p和q的区间里有极大值点a和极小值点b-则方程的解也就是在-p-min-a-b-min-a-b-max-a-b-max-a-b-q-这三个区间内" class="headerlink" title="分析：必定在p和q的区间里有极大值点a和极小值点b,                                                                       则方程的解也就是在(p,min{a,b})(min{a,b},max{a,b})(max{a,b},q)这三个区间内,"></a>分析：必定在p和q的区间里有极大值点a和极小值点b,                                                                       则方程的解也就是在(p,min{a,b})(min{a,b},max{a,b})(max{a,b},q)这三个区间内,</h3><h3 id="My-Code-4"><a href="#My-Code-4" class="headerlink" title="My Code:"></a>My Code:</h3><pre><code>#include&lt;iostream&gt;
#include&lt;cmath&gt;
#include&lt;iomanip&gt;
using namespace std;   
double f(double x,double a,double b,double c,double d)&#123;  //求函数值
    double f;
    f=a*pow(x,3.0)+b*pow(x,2.0)+c*x+d;
    return f;
&#125;
double findx(double l,double r,double a,double b,double c,double d)&#123;  //二分搜索
    double mid;
    while(abs(l-r)&gt;pow(10.0,-7.0))&#123;  //控制精度
        mid=(l+r)/2.0;
        if(f(mid,a,b,c,d)*f(l,a,b,c,d)&gt;0)&#123;
            l=mid;
        &#125;
        else&#123;
            r=mid;
        &#125;
    &#125;
    return mid;
&#125;
void findm(double a,double b,double c,double d,double p,double q)&#123;
    double x1,x2;
    double ret1,ret2,ret3;
    x1=((-2)*b+pow(4*b*b-12*a*c,0.5))/(6*a);
    x2=((-2)*b-pow(4*b*b-12*a*c,0.5))/(6*a);   //求极值点的横坐标
    if(x1&gt;x2)&#123;
        ret3=findx(x1,q,a,b,c,d);
        ret1=findx(p,x2,a,b,c,d);
        ret2=findx(x2,x1,a,b,c,d);        //在x1&gt;x2状态下进行二分搜索
    &#125;       
    else&#123;
        ret3=findx(x2,q,a,b,c,d);
        ret1=findx(p,x1,a,b,c,d);
        ret2=findx(x1,x2,a,b,c,d);      //在x2&gt;x1状态下进行二分搜索
    &#125;
    cout&lt;&lt;ret1&lt;&lt;&quot; &quot;&lt;&lt;ret2&lt;&lt;&quot; &quot;&lt;&lt;ret3&lt;&lt;endl;  //输出结果
&#125;
int main()&#123;
    double arr[1005][6];  //用于存放每组输入的数据
    cout&lt;&lt;fixed&lt;&lt;setprecision(9);  
    int n;
    cin&gt;&gt;n;
    for(int i=0;i&lt;n;i++)&#123;
        for(int j=0;j&lt;6;j++)&#123;
            cin&gt;&gt;arr[i][j];  
        &#125;
    &#125;
    for(int i=0;i&lt;n;i++)&#123;
        findm(arr[i][0],arr[i][1],arr[i][2],arr[i][3],arr[i][4],arr[i][5]);  //进行计算
    &#125;
    system(&quot;pause&quot;);
    return 0;
&#125;
</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/11/28/%E5%8F%8C%E5%91%A81/" data-id="clfi3u93j000fgcw156u5elqy" data-title="双周1" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-T1" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/11/28/T1/" class="article-date">
  <time class="dt-published" datetime="2022-11-28T13:29:09.000Z" itemprop="datePublished">2022-11-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/11/28/T1/">T1</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>his is the 5th week.</p>
<h3 id="蓝桥杯-2013-国-C-危险系数"><a href="#蓝桥杯-2013-国-C-危险系数" class="headerlink" title="[蓝桥杯 2013 国 C] 危险系数"></a>[蓝桥杯 2013 国 C] 危险系数</h3><h2 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h2><p>抗日战争时期，冀中平原的地道战曾发挥重要作用。</p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>地道的多个站点间有通道连接，形成了庞大的网络。但也有隐患，当敌人发现了某个站点后，其它站点间可能因此会失去联系。</p>
<p>我们来定义一个危险系数 $DF(x,y)$：</p>
<p>对于两个站点 $x$ 和 $y(x\neq y),$ 如果能找到一个站点 $z$，当 $z$ 被敌人破坏后，$x$ 和 $y$ 不连通，那么我们称 $z$ 为关于 $x,y$ 的关键点。相应的，对于任意一对站点 $x$ 和 $y$，危险系数 $DF(x,y)$ 就表示为这两点之间的关键点个数。</p>
<p>本题的任务是：已知网络结构，求两站点之间的危险系数。</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入数据第一行包含 $2$ 个整数 $n(2 \le n \le 1000)$，$m(0 \le m \le 2000)$，分别代表站点数，通道数。</p>
<p>接下来 $m$ 行，每行两个整数 $u,v(1 \le u,v \le n,u\neq v)$ 代表一条通道。</p>
<p>最后 $1$ 行，两个数 $u,v$，代表询问两点之间的危险系数 $DF(u,v)$。</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>一个整数，如果询问的两点不连通则输出 $-1$。</p>
<h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">7 6</span><br><span class="line">1 3</span><br><span class="line">2 3</span><br><span class="line">3 4</span><br><span class="line">3 5</span><br><span class="line">4 5</span><br><span class="line">5 6</span><br><span class="line">1 6</span><br></pre></td></tr></table></figure>

<h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure>

<h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p>时限 1 秒, 64M。蓝桥杯 2013 年第四届国赛</p>
<h3 id="Analyse："><a href="#Analyse：" class="headerlink" title="Analyse："></a>Analyse：</h3><p>定每次的速度而且要根据后面的敌人的距离不断的切换速度，</p>
<p>这样会影响到前面的时间，因为他的换弹速度是一定的，所以可以用二分来猜答案。</p>
<p>二分猜测换弹时间</p>
<h3 id="My-Code"><a href="#My-Code" class="headerlink" title="My Code:"></a>My Code:</h3><pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
using namespace std;
bool g[1001][1001];
int count[1001];
int m,n;
int u,v;
int sum=0;
bool vis[1001];

int dfs(int beg)
&#123;
if(beg==v)
&#123;
return 1;
&#125;
int flag=0;bool bo=1;
for(int i=1;i&lt;=n;i++)
&#123;
if(i!=beg&amp;&amp;vis[i]==false&amp;&amp;g[beg][i])
&#123;bo=0;
vis[i]=true;
flag+=dfs(i);
vis[i]=false;
&#125;
&#125;
if(bo==1)return 0;
count[beg]+=flag;
return flag;
&#125;
int main()
&#123;
memset(g,sizeof(g),0);
memset(vis,sizeof(vis),0);
for(int i=0;i&lt;1001;i++)count[i]=0;
cin&gt;&gt;n&gt;&gt;m;int i,j;
while(m--)
&#123;
cin&gt;&gt;i&gt;&gt;j;
g[i][j]=1;
g[j][i]=1;
&#125;
cin&gt;&gt;u&gt;&gt;v;
int sum=dfs(u);int k=0;
if(sum==0) cout&lt;&lt;-1&lt;&lt;endl;
else&#123;
for(int i=1;i&lt;=n;i++)if(count[i]==sum&amp;&amp;i!=u&amp;&amp;i!=v)k++;
cout&lt;&lt;k&lt;&lt;endl;
&#125;
return 0;
&#125;
</code></pre>
<p>his is the 4th week.</p>
<h2 id="图的遍历"><a href="#图的遍历" class="headerlink" title="# 图的遍历"></a># 图的遍历</h2><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>给出 $N$ 个点，$M$ 条边的有向图，对于每个点 $v$，求 $A(v)$ 表示从点 $v$ 出发，能到达的编号最大的点。</p>
<h2 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h2><p>第 $1$ 行 $2$ 个整数 $N,M$，表示点数和边数。</p>
<p>接下来 $M$ 行，每行 $2$ 个整数 $U_i,V_i$，表示边 $(U_i,V_i)$。点用 $1,2,\dots,N$ 编号。</p>
<h2 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h2><p>一行 $N$ 个整数 $A(1),A(2),\dots,A(N)$。</p>
<h2 id="样例-1-1"><a href="#样例-1-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-1"><a href="#样例输入-1-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">4 3</span><br><span class="line">1 2</span><br><span class="line">2 4</span><br><span class="line">4 3</span><br></pre></td></tr></table></figure>

<h3 id="样例输出-1-1"><a href="#样例输出-1-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4 4 3 4</span><br></pre></td></tr></table></figure>

<h2 id="提示-1"><a href="#提示-1" class="headerlink" title="提示"></a>提示</h2><ul>
<li>对于 $60%$ 的数据，$1 \leq N,M \leq 10^3$。</li>
<li>对于 $100%$ 的数据，$1 \leq N,M \leq 10^5$。</li>
</ul>
<h3 id="Analyse：-1"><a href="#Analyse：-1" class="headerlink" title="Analyse："></a>Analyse：</h3><h3 id="存储每个位置的数字时-我们要注意字母与数字的转化-同样-在输出时也要注意输出数字若大于等于10-就要转化成字母"><a href="#存储每个位置的数字时-我们要注意字母与数字的转化-同样-在输出时也要注意输出数字若大于等于10-就要转化成字母" class="headerlink" title="存储每个位置的数字时,我们要注意字母与数字的转化.同样,在输出时也要注意输出数字若大于等于10,就要转化成字母."></a>存储每个位置的数字时,我们要注意字母与数字的转化.同样,在输出时也要注意输出数字若大于等于10,就要转化成字母.</h3><h3 id="My-Code-1"><a href="#My-Code-1" class="headerlink" title="My Code:"></a>My Code:</h3><pre><code>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#define rg register
#define N 200010
using namespace std;
int n,m,tot,top,color,ans[N],last[N],col[N],mx[N],dfn[N],low[N],st[N],r[N][2];
bool vis[N];
struct edge&#123;int to,pre;&#125;e[N];
inline int read()&#123;
    int k=0,f=1;char c=getchar();
    while(c&lt;&#39;0&#39;||c&gt;&#39;9&#39;)c==&#39;-&#39;&amp;&amp;(f=-1),c=getchar();
    while(&#39;0&#39;&lt;=c&amp;&amp;c&lt;=&#39;9&#39;)k=k*10+c-&#39;0&#39;,c=getchar();
    return k*f;
&#125;
inline void add(int x,int y)&#123;e[++tot]=(edge)&#123;y,last[x]&#125;; last[x]=tot;&#125;
inline int max(int x,int y)&#123;return x&gt;y?x:y;&#125;
void tarjan(int x)&#123;
    dfn[st[++top]=x]=low[x]=++tot;
    for(rg int i=last[x],to;i;i=e[i].pre)
        if(!dfn[to=e[i].to]) tarjan(to),low[x]=min(low[x],low[to]);
        else if(!col[to]) low[x]=min(low[x],dfn[to]);
    if(dfn[x]==low[x]) 
        for(color++;st[top+1]!=x;top--) col[st[top]]=color,mx[color]=max(mx[color],st[top]);
&#125;
void dfs(int x)&#123;
    vis[x]=1;
    for(rg int i=last[x],to;i;i=e[i].pre)&#123;
        if(!vis[to=e[i].to]) dfs(to);
        mx[x]=max(mx[x],mx[to]);
    &#125;
&#125;
int main()&#123;
    n=read(); m=read();
    for(rg int i=1;i&lt;=m;i++) r[i][0]=read(),add(r[i][0],r[i][1]=read());
    tot=0;
    for(rg int i=1;i&lt;=n;i++) if(!dfn[i]) tarjan(i);
    tot=0; memset(last,0,sizeof(last));
    for(rg int i=1;i&lt;=m;i++)
        if(col[r[i][0]]!=col[r[i][1]]) add(col[r[i][0]],col[r[i][1]]);
    for(rg int i=1;i&lt;=color;i++) if(!vis[i]) dfs(i);
    for(rg int i=1;i&lt;=n;i++) printf(&quot;%d &quot;,mx[col[i]]);
    return 0;
&#125;
</code></pre>
<p>his is the 4th week.</p>
<h2 id="封锁阳光大学"><a href="#封锁阳光大学" class="headerlink" title="# 封锁阳光大学"></a># 封锁阳光大学</h2><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>曹是一只爱刷街的老曹，暑假期间，他每天都欢快地在阳光大学的校园里刷街。河蟹看到欢快的曹，感到不爽。河蟹决定封锁阳光大学，不让曹刷街。</p>
<p>阳光大学的校园是一张由 $n$ 个点构成的无向图，$n$ 个点之间由 $m$ 条道路连接。每只河蟹可以对一个点进行封锁，当某个点被封锁后，与这个点相连的道路就被封锁了，曹就无法在这些道路上刷街了。非常悲剧的一点是，河蟹是一种不和谐的生物，当两只河蟹封锁了相邻的两个点时，他们会发生冲突。</p>
<p>询问：最少需要多少只河蟹，可以封锁所有道路并且不发生冲突。</p>
<h2 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行两个正整数，表示节点数和边数。<br>接下来 $m$ 行，每行两个整数 $u,v$，表示点 $u$ 到点 $v$ 之间有道路相连。</p>
<h2 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式"></a>输出格式</h2><p>仅一行如果河蟹无法封锁所有道路，则输出 <code>Impossible</code>，否则输出一个整数，表示最少需要多少只河蟹。</p>
<h2 id="样例-1-2"><a href="#样例-1-2" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-2"><a href="#样例输入-1-2" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3 3</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">2 3</span><br></pre></td></tr></table></figure>

<h3 id="样例输出-1-2"><a href="#样例输出-1-2" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Impossible</span><br></pre></td></tr></table></figure>

<h2 id="样例-2"><a href="#样例-2" class="headerlink" title="样例 #2"></a>样例 #2</h2><h3 id="样例输入-2"><a href="#样例输入-2" class="headerlink" title="样例输入 #2"></a>样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3 2</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br></pre></td></tr></table></figure>

<h3 id="样例输出-2"><a href="#样例输出-2" class="headerlink" title="样例输出 #2"></a>样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure>

<h2 id="提示-2"><a href="#提示-2" class="headerlink" title="提示"></a>提示</h2><p>【数据规模】<br>对于 $100%$ 的数据，$1\le n \le 10^4$，$1\le m \le 10^5$，保证没有重边。</p>
<h3 id="Analyse：-2"><a href="#Analyse：-2" class="headerlink" title="Analyse："></a>Analyse：</h3><p>敌人到射程才能开始开枪.</p>
<p>需要一个一个的来进行模拟</p>
<h3 id="My-Code-2"><a href="#My-Code-2" class="headerlink" title="My Code:"></a>My Code:</h3><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
int n,m,sum;
bool flag=1;//最大的判断条件，判断染色是否已经无法进行
int col[100010];//记录点的颜色
int cnt[2];//记录在每一张图上两种颜色的点分别有多少个
bool judge[100010];//记录该点是否已经使用
vector&lt;int&gt; house[100010];//用来存图的动态数组

void dfs(int i,int f)
&#123;
    judge[i]=1;
    if(col[i]==-1)
    &#123;
        col[i]=f,cnt[f]++;
        for(int j=0;j&lt;house[i].size();j++)
        &#123;
            judge[house[i][j]]=1;
            dfs(house[i][j],!f);//染上与原来点相反的颜色（1 and 0）
        &#125;
        return;
    &#125;
    else 
    &#123;
        if(f!=col[i])flag=0;//如果产生冲突说明染色无法进行，已经无解了
        return;
    &#125;

&#125;

int main()
&#123;
    int u,v;
    cin&gt;&gt;n&gt;&gt;m;
    for(int i=1;i&lt;=m;i++)
    &#123;
        cin&gt;&gt;u&gt;&gt;v;
        house[u].push_back(v);
        house[v].push_back(u);
    &#125;
    memset(col,-1,sizeof col);//颜色数组赋-1
    for(int i=1;i&lt;=n;i++)
    &#123;
        if(judge[i]==0)
        &#123;
            cnt[0]=0,cnt[1]=0;//每张单独的图都要重新记录颜色的数量
            dfs(i,0);//没颜色的统一染上0
            if(cnt[0]&gt;cnt[1])sum+=cnt[1];//取两种颜色中更少的来累加
            else sum+=cnt[0];
        &#125;
    &#125;
    if(flag)
    &#123;
        cout&lt;&lt;sum;
    &#125;
    else cout&lt;&lt;&quot;Impossible&quot;;

    return 0;
&#125;
</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/11/28/T1/" data-id="clfi3u93c0003gcw1c3h68aed" data-title="T1" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-马的" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/11/21/%E9%A9%AC%E7%9A%84/" class="article-date">
  <time class="dt-published" datetime="2022-11-21T12:52:17.000Z" itemprop="datePublished">2022-11-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/11/21/%E9%A9%AC%E7%9A%84/">搜索</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>This is the 4th week.</p>
<h2 id="P1443-马的遍历"><a href="#P1443-马的遍历" class="headerlink" title="P1443 马的遍历"></a>P1443 马的遍历</h2><h4 id="马的遍历"><a href="#马的遍历" class="headerlink" title="# 马的遍历"></a># 马的遍历</h4><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>有一个 $n \times m$ 的棋盘，在某个点 $(x, y)$ 上有一个马，要求你计算出马到达棋盘上任意一个点最少要走几步。</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入只有一行四个整数，分别为 $n, m, x, y$。</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>一个 $n \times m$ 的矩阵，代表马到达某个点最少要走几步（不能到达则输出 $-1$）。</p>
<h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 3 1 1</span><br></pre></td></tr></table></figure>

<h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0    3    2    </span><br><span class="line">3    -1   1    </span><br><span class="line">2    1    4</span><br></pre></td></tr></table></figure>

<h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><h3 id="数据规模与约定"><a href="#数据规模与约定" class="headerlink" title="数据规模与约定"></a>数据规模与约定</h3><p>对于全部的测试点，保证 $1 \leq x \leq n \leq 400$，$1 \leq y \leq m \leq 400$。</p>
<p>More info:<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1443">P1443 马的遍历 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a>](<a target="_blank" rel="noopener" href="https://pintia.cn/problem-sets/1584759265956864000/exam/problems/1584759731948232704">https://pintia.cn/problem-sets/1584759265956864000/exam/problems/1584759731948232704</a>)</p>
<h3 id="Analyse："><a href="#Analyse：" class="headerlink" title="Analyse："></a>Analyse：</h3><p>题目中，马走的是<strong>日字形</strong>。有八个方向</p>
<p>用了queue:</p>
<ol>
<li><p><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/queue/4511093">queue</a>：先进先出的线性表。</p>
<p>需要<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%A4%B4%E6%96%87%E4%BB%B6&spm=1001.2101.3001.7020">头文件</a> <code>#include&lt;queue&gt;</code></p>
<p>定义 <code>queue &lt;int&gt; q;</code></p>
<p>入队 <code>q.push(x);</code></p>
<p>出队 <code>q.pop();</code></p>
<p>查询队列中元素个数 <code>q.size()</code></p>
</li>
</ol>
<h3 id="My-Code"><a href="#My-Code" class="headerlink" title="My Code:"></a>My Code:</h3><pre><code>#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;queue&gt;
#include &lt;algorithm&gt;

using namespace std;

const int dx[10] = &#123;-2, -2, 2, 2, 1, -1, 1, -1&#125;;
const int dy[10] = &#123;-1, 1, -1, 1, 2, -2, -2, 2&#125;;

const int N = 500;

typedef pair&lt;int, int&gt; PII;

int n, m, x, y;
int d[N][N];  // 是否走过
PII q[N * N]; // 存储数据队列

void bfs(int x, int y)
&#123;

    memset(d, -1, sizeof d); 
    d[x][y] = 0;           

    queue&lt;pair&lt;int, int&gt;&gt; q;
    q.push(&#123;x, y&#125;); // 起始点入队

    while (q.size())
    &#123;
        PII t = q.front(); 
        q.pop();           


        for (int i = 0; i &lt; 8; i++)
        &#123;
            int A = t.first + dx[i], B = t.second + dy[i];                
            if (A &gt;= 1 &amp;&amp; A &lt;= n &amp;&amp; B &gt;= 1 &amp;&amp; B &lt;= m &amp;&amp; d[A][B] == -1) 
            &#123;
                d[A][B] = d[t.first][t.second] + 1; 
                q.push(&#123;A, B&#125;);                     
            &#125;
        &#125;
    &#125;
&#125;

int main()
&#123;
    cin &gt;&gt; n &gt;&gt; m &gt;&gt; x &gt;&gt; y;

    bfs(x, y);

    for (int i = 1; i &lt;= n; i++)
    &#123;
        for (int j = 1; j &lt;= m; j++)
            printf(&quot;%-5d&quot;, d[i][j]);
        puts(&quot;&quot;);
    &#125;


    return 0;
&#125;
</code></pre>
<p>模拟与高精度</p>
<p>This is the 4th week.</p>
<h2 id="P1443-马的遍历-1"><a href="#P1443-马的遍历-1" class="headerlink" title="P1443 马的遍历"></a>P1443 马的遍历</h2><h4 id="迷宫"><a href="#迷宫" class="headerlink" title="# 迷宫"></a># 迷宫</h4><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个 $N \times M$ 方格的迷宫，迷宫里有 $T$ 处障碍，障碍处不可通过。</p>
<p>在迷宫中移动有上下左右四种方式，每次只能移动一个方格。数据保证起点上没有障碍。</p>
<p>给定起点坐标和终点坐标，每个方格最多经过一次，问有多少种从起点坐标到终点坐标的方案。</p>
<h2 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行为三个正整数 $N,M,T$，分别表示迷宫的长宽和障碍总数。</p>
<p>第二行为四个正整数 $SX,SY,FX,FY$，$SX,SY$ 代表起点坐标，$FX,FY$ 代表终点坐标。</p>
<p>接下来 $T$ 行，每行两个正整数，表示障碍点的坐标。</p>
<h2 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出从起点坐标到终点坐标的方案总数。</p>
<h2 id="样例-1-1"><a href="#样例-1-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-1"><a href="#样例输入-1-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2 2 1</span><br><span class="line">1 1 2 2</span><br><span class="line">1 2</span><br></pre></td></tr></table></figure>

<h3 id="样例输出-1-1"><a href="#样例输出-1-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure>

<h2 id="提示-1"><a href="#提示-1" class="headerlink" title="提示"></a>提示</h2><p>对于 $100%$ 的数据，$1 \le N,M \le 5$，$1 \le T \le 10$，$1 \le SX,FX \le n$，$1 \le SY,FY \le m$。</p>
<h2 id="提示-2"><a href="#提示-2" class="headerlink" title="提示"></a>提示</h2><h3 id="数据规模与约定-1"><a href="#数据规模与约定-1" class="headerlink" title="数据规模与约定"></a>数据规模与约定</h3><p>对于全部的测试点，保证 $1 \leq x \leq n \leq 400$，$1 \leq y \leq m \leq 400$。</p>
<p>More info:[<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1605">P1605 迷宫 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
<h3 id="Analyse：-1"><a href="#Analyse：-1" class="headerlink" title="Analyse："></a>Analyse：</h3><ol>
<li><p>查询队列中元素个数 <code>q.size()</code>使用自动选择方向来代替4个if判断（<del>使代码更加简洁</del>长度变短）；</p>
<p>如果没有障碍并且不是自己走过的，就进一步搜索，把自己走过的路打上标记，返回时，再将标记还原；</p>
<p>###注意：有些同学可能觉得就在地图map数组上打标记（自己走过的路）比较简单，走过的路和障碍可能引起混淆，</p>
<p>这一题一看就知道一定要用<strong>dfs回溯</strong>。因为我们要枚举走的步数，以及走错路时抑制住自己的愤怒回来换下一条路。</p>
</li>
</ol>
<h3 id="My-Code-1"><a href="#My-Code-1" class="headerlink" title="My Code:"></a>My Code:</h3><pre><code>#include &lt;iostream&gt;
#include &lt;cstring&gt;
using namespace std;
int n, m, t;//n，m为行列，t障碍的数目
int A, B, ex, ey;
const int N = 15;
//表示迷宫能不能走
int  M[N][N];
//表示有没有走过这个点
bool st[N][N];
int ans = 0;
int dx[4] = &#123; -1,0,1,0 &#125;;
int dy[4] = &#123; 0,1,0,-1 &#125;;
void dfs(int A, int B) &#123;
    if (A== ex &amp;&amp; B == ey) &#123;
        ans++;
        return;
    &#125;
    for (int i = 0; i &lt; 4; i++) &#123;
        int hang = A + dx[i], lie = B + dy[i];
        if (hang &gt;= 1 &amp;&amp; hang &lt;= n &amp;&amp; lie &gt;= 1 &amp;&amp; lie &lt;= m &amp;&amp; M[hang][lie] ==-1 &amp;&amp; st[hang][lie] == false) &#123;
            st[hang][lie] = true;
            dfs(hang, lie);
            st[hang][lie] = false;
        &#125;
    &#125;
&#125;
int main() &#123;
    cin &gt;&gt; n &gt;&gt; m &gt;&gt; t;
    cin &gt;&gt; A &gt;&gt;B &gt;&gt;ex &gt;&gt; ey;
    memset(M, -1, sizeof M);

    M[A][B] = 0;
    for (int i = 0; i &lt; t; i++) &#123;
        int x, y;
        cin &gt;&gt; x &gt;&gt; y;
        M[x][y] = 0;
    &#125;
    dfs(A, B);
    cout &lt;&lt; ans;
    return 0;
&#125;
</code></pre>
<p>sousuo</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/11/21/%E9%A9%AC%E7%9A%84/" data-id="clfi3u93m000lgcw10ifp5p2c" data-title="搜索" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-0" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/11/14/0/" class="article-date">
  <time class="dt-published" datetime="2022-11-14T11:58:35.000Z" itemprop="datePublished">2022-11-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/11/14/0/">0</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>hexo n “”</p>
<p>hexo clean</p>
<p>hexo g</p>
<p>hexo d</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/11/14/0/" data-id="clfi3u9330000gcw1bbh59sl5" data-title="0" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-排队" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/11/14/%E6%8E%92%E9%98%9F/" class="article-date">
  <time class="dt-published" datetime="2022-11-14T11:40:16.000Z" itemprop="datePublished">2022-11-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/11/14/%E6%8E%92%E9%98%9F/">排队</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>This is the third week.</p>
<h2 id="排队"><a href="#排队" class="headerlink" title="排队"></a>排队</h2><h1 id="P3613-【深基15-例2】寄包柜"><a href="#P3613-【深基15-例2】寄包柜" class="headerlink" title="P3613 【深基15.例2】寄包柜"></a>P3613 【深基15.例2】寄包柜</h1><h6 id="【深基15-例2】寄包柜"><a href="#【深基15-例2】寄包柜" class="headerlink" title="# 【深基15.例2】寄包柜"></a># 【深基15.例2】寄包柜</h6><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>超市里有 $n(1\le n\le10^5)$ 个寄包柜。每个寄包柜格子数量不一，第 $i$ 个寄包柜有 $a_i(1\le a_i\le10^5)$ 个格子，不过我们并不知道各个 $a_i$ 的值。对于每个寄包柜，格子编号从 1 开始，一直到 $a_i$。现在有 $q(1 \le q\le10^5)$ 次操作：</p>
<ul>
<li><code>1 i j k</code>：在第 $i$ 个柜子的第 $j$ 个格子存入物品 $k(0\le k\le 10^9)$。当 $k&#x3D;0$ 时说明清空该格子。</li>
<li><code>2 i j</code>：查询第 $i$ 个柜子的第 $j$ 个格子中的物品是什么，保证查询的柜子有存过东西。</li>
</ul>
<p>已知超市里共计不会超过 $10^7$ 个寄包格子，$a_i$ 是确定然而未知的，但是保证一定不小于该柜子存物品请求的格子编号的最大值。当然也有可能某些寄包柜中一个格子都没有。</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行 2 个整数 $n$ 和 $q$，寄包柜个数和询问次数。</p>
<p>接下来 $q$ 个整数，表示一次操作。</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>对于查询操作时，输出答案，以换行隔开。</p>
<h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">5 4</span><br><span class="line">1 3 10000 118014</span><br><span class="line">1 1 1 1</span><br><span class="line">2 3 10000</span><br><span class="line">2 1 1</span><br></pre></td></tr></table></figure>

<h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">118014</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p>$\text{upd 2022.7.26}$：新增加一组 Hack 数据。</p>
<p>More info: <a target="_blank" rel="noopener" href="https://pintia.cn/problem-sets/1584759265956864000/exam/problems/1584759731948232704"><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3613">P3613 【深基15.例2】寄包柜 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></a></p>
<h3 id="Analyse："><a href="#Analyse：" class="headerlink" title="Analyse："></a>Analyse：</h3><p>就是用一个<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84&spm=1001.2101.3001.7020">二维数组</a>存储第i个柜子和第j个格子。个人认为用二维数组过于浪费空间，所以用STL中的map来存储。</p>
<ul>
<li><p>构造一个结构体，分别存储i，j，k</p>
<p>  struct Node<br>  {</p>
<pre><code>  int s = 0;//柜子使用的次数，一个柜子可能使用很多次
  vector&lt;int&gt; v;//一个柜子的格子数
  vector&lt;int&gt; num;//v格子存放的物品
</code></pre>
<p>  }a[N];</p>
</li>
</ul>
<h3 id="My-Code"><a href="#My-Code" class="headerlink" title="My Code:"></a>My Code:</h3><pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
map&lt;int,int&gt;a1[100001];
int n,q;
int main()
&#123;
    cin&gt;&gt;n&gt;&gt;q;
    for(int i=0;i&lt;q;i++)
    &#123;
        int a,b,c,d;
        cin&gt;&gt;a;
        if(a==1)
        &#123;
            cin&gt;&gt;b&gt;&gt;c&gt;&gt;d;
            a1[b][c]=d;  //用map数组记录k
        &#125;
        else
        &#123;
            cin&gt;&gt;b&gt;&gt;c;
            cout&lt;&lt;a1[b][c]&lt;&lt;endl;  //输出aij

        &#125;
    &#125;
    return 0;
&#125;
</code></pre>
<h4 id="排队问题"><a href="#排队问题" class="headerlink" title="排队问题"></a>排队问题</h4><h1 id="P1241-括号序列"><a href="#P1241-括号序列" class="headerlink" title="P1241 括号序列"></a>P1241 括号序列</h1><h6 id="括号序列"><a href="#括号序列" class="headerlink" title="# 括号序列"></a># 括号序列</h6><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>定义如下规则：</p>
<ol>
<li>空串是「平衡括号序列」</li>
<li>若字符串 $S$ 是「平衡括号序列」，那么 $\texttt{[}S\texttt]$ 和 $\texttt{(}S\texttt)$ 也都是「平衡括号序列」</li>
<li>若字符串 $A$ 和 $B$ 都是「平衡括号序列」，那么 $AB$（两字符串拼接起来）也是「平衡括号序列」。</li>
</ol>
<p>例如，下面的字符串都是平衡括号序列：</p>
<p><code>()</code>，<code>[]</code>，<code>(())</code>，<code>([])</code>，<code>()[]</code>，<code>()[()]</code></p>
<p>而以下几个则不是：</p>
<p><code>(</code>，<code>[</code>，<code>]</code>，<code>)(</code>，<code>())</code>，<code>([()</code></p>
<p>现在，给定一个仅由 <code>(</code>，<code>)</code>，<code>[</code>，<code>]</code>构成的字符串 $s$，请你按照如下的方式给字符串中每个字符配对：</p>
<ol>
<li>从左到右扫描整个字符串。</li>
<li>对于当前的字符，如果它是一个右括号，考察它与它左侧离它<strong>最近</strong>的<strong>未匹配</strong>的的左括号。如果该括号与之对应（即小括号匹配小括号，中括号匹配中括号），则将二者配对。如果左侧未匹配的左括号不存在或与之不对应，则其配对失败。</li>
</ol>
<p>配对结束后，对于 $s$ 中全部未配对的括号，请你在其旁边添加一个字符，使得该括号和新加的括号匹配。</p>
<h2 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入只有一行一个字符串，表示 $s$。</p>
<h2 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一行一个字符串表示你的答案。</p>
<h2 id="样例-1-1"><a href="#样例-1-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-1"><a href="#样例输入-1-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">([()</span><br></pre></td></tr></table></figure>

<h3 id="样例输出-1-1"><a href="#样例输出-1-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">()[]()</span><br></pre></td></tr></table></figure>

<h2 id="样例-2"><a href="#样例-2" class="headerlink" title="样例 #2"></a>样例 #2</h2><h3 id="样例输入-2"><a href="#样例输入-2" class="headerlink" title="样例输入 #2"></a>样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">([)</span><br></pre></td></tr></table></figure>

<h3 id="样例输出-2"><a href="#样例输出-2" class="headerlink" title="样例输出 #2"></a>样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">()[]()</span><br></pre></td></tr></table></figure>

<h2 id="提示-1"><a href="#提示-1" class="headerlink" title="提示"></a>提示</h2><h3 id="数据规模与约定"><a href="#数据规模与约定" class="headerlink" title="数据规模与约定"></a>数据规模与约定</h3><p>对于全部的测试点，保证 $s$ 的长度不超过 100，且只含  <code>(</code>，<code>)</code>，<code>[</code>，<code>]</code> 四个字符。</p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1241">P1241 括号序列 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
<h3 id="Analyse"><a href="#Analyse" class="headerlink" title="Analyse:"></a>Analyse:</h3><p>①关于括号序列合法性：对于一段括号序列，从左往右起，对于每一段小的括号序列 –‘(’– 数量 大于等于 –‘)’– 数量，那么整个括号序列就合法。</p>
<p>②关于 –‘(’– 和 –’)’– 的添加可以分开来讨论：括号是被添加到原序列的括号与括号之间的空隙里的，假如左括号和右括号加入的是不同的空隙，如果加入的是同一个空隙，那么右括号的添加必然在左括号之前，否则括号配对，添加无意义</p>
<p>&#x2F;我们需要的就是长度为len添加括号的合法情况，而从前往后遍历出现的第一个有可能的情况就是需要括号数最少的情况，因为左括号可以加很多个，我们仅需添加最少的情况</p>
<h3 id="My-Code-1"><a href="#My-Code-1" class="headerlink" title="My Code:"></a>My Code:</h3><pre><code>#include &lt;iostream&gt;
#include &lt;string.h&gt;
#include &lt;algorithm&gt;
using  namespace std;
int a[10000];

int main()&#123;
    string s;
    cin&gt;&gt;s;
    int l=s.length();
    for(int i=0;i&lt;l;i++)&#123;
        if(s[i]==&#39;)&#39;&amp;&amp;a[i]==0)&#123;
            for(int j=i-1;j&gt;=0;j--)&#123;
                if(s[j]==&#39;(&#39;&amp;&amp;a[j]==0)&#123;
                    a[j]=a[i]=1;
                    break;
                &#125;
                else if(s[j]==&#39;[&#39;&amp;&amp;a[j]==0)&#123;
                    break;
                &#125;

            &#125;
        &#125;
        if(s[i]==&#39;]&#39;&amp;&amp;a[i]==0)&#123;
            for(int j=i-1;j&gt;=0;j--)&#123;
                if(s[j]==&#39;[&#39;&amp;&amp;a[j]==0)&#123;
                    a[j]=a[i]=1;
                    break;
                &#125;
                else if(s[j]==&#39;(&#39;&amp;&amp;a[j]==0)&#123;
                    break;
                &#125;

            &#125;
        &#125;





    &#125;
    for(int i=0;i&lt;l;i++)&#123;
        if(a[i]==0)&#123;
            if(s[i]==&#39;(&#39;||s[i]==&#39;)&#39;)cout&lt;&lt;&quot;()&quot;;
            else cout&lt;&lt;&quot;[]&quot;;
        &#125;
        else cout&lt;&lt;s[i];

    &#125;



&#125;
</code></pre>
<h4 id="排队问题-1"><a href="#排队问题-1" class="headerlink" title="排队问题"></a>排队问题</h4><h1 id="P1449-后缀表达式"><a href="#P1449-后缀表达式" class="headerlink" title="P1449 后缀表达式"></a>P1449 后缀表达式</h1><h6 id="后缀表达式"><a href="#后缀表达式" class="headerlink" title="# 后缀表达式"></a># 后缀表达式</h6><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>所谓后缀表达式是指这样的一个表达式：式中不再引用括号，运算符号放在两个运算对象之后，所有计算按运算符号出现的顺序，严格地由左而右新进行（不用考虑运算符的优先级）。</p>
<p>如：$\texttt{3*(5-2)+7}$ 对应的后缀表达式为：$\texttt{3.5.2.-*7.+@}$。在该式中，<code>@</code> 为表达式的结束符号。<code>.</code> 为操作数的结束符号。</p>
<h2 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入一行一个字符串 $s$，表示后缀表达式。</p>
<h2 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一个整数，表示表达式的值。</p>
<h2 id="样例-1-2"><a href="#样例-1-2" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-2"><a href="#样例输入-1-2" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3.5.2.-*7.+@</span><br></pre></td></tr></table></figure>

<h3 id="样例输出-1-2"><a href="#样例输出-1-2" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">16</span><br></pre></td></tr></table></figure>

<h2 id="提示-2"><a href="#提示-2" class="headerlink" title="提示"></a>提示</h2><p>数据保证，$1 \leq |s| \leq 50$，答案和计算过程中的每一个值的绝对值不超过 $10^9$。</p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1241"><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1449">P1449 后缀表达式 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></a></p>
<h3 id="Anlyse"><a href="#Anlyse" class="headerlink" title="Anlyse"></a>Anlyse</h3><h5 id="后缀表达式从左到右遍历"><a href="#后缀表达式从左到右遍历" class="headerlink" title="后缀表达式从左到右遍历"></a>后缀表达式从左到右遍历</h5><p><strong>1，是数字直接写上</strong></p>
<p><strong>2，是任何运算符号</strong></p>
<p><strong>①右括号—-） 和优先级 不高于 栈顶元素 则 栈顶元素依次输出 并当前符号进栈（括号直接消失）</strong></p>
<h3 id="My-Code-2"><a href="#My-Code-2" class="headerlink" title="My Code:"></a>My Code:</h3><pre><code>#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;cstdio&gt;
#include &lt;stack&gt;
using namespace std;
int go(int a,int b,char c)
&#123;
    if(c==&#39;*&#39;)
      return a*b;
    if(c==&#39;/&#39;)
      return a/b;
    if(c==&#39;+&#39;)
      return a+b;
    if(c==&#39;-&#39;)
      return a-b;
&#125;
int main()
&#123;
    stack&lt;int&gt; sk;
    char c;
    while(1)
      &#123;
          cin&gt;&gt;c;
          if(c==&#39;@&#39;)
            break;
          if(c&gt;=&#39;0&#39;&amp;&amp;c&lt;=&#39;9&#39;)//是数字还是符号
            &#123;
                int v=c-&#39;0&#39;;
                while(1)
                  &#123;
                      cin&gt;&gt;c;
                      if(c==&#39;.&#39;)
                        break;
                      else
                        v=10*v+c-&#39;0&#39;;//几位数
                  &#125;
                sk.push(v);
            &#125;
          else
            &#123;
                int a,b,x;
                b=sk.top();
                sk.pop();
                a=sk.top();
                sk.pop();
                x=go(a,b,c);
                sk.push(x);
            &#125;
      &#125;
    int ans=sk.top();
    cout&lt;&lt;ans;
    return 0;
&#125;
</code></pre>
<h1 id="P1160-队列安排"><a href="#P1160-队列安排" class="headerlink" title="P1160 队列安排"></a>P1160 队列安排</h1><h6 id="队列安排"><a href="#队列安排" class="headerlink" title="# 队列安排"></a># 队列安排</h6><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p>一个学校里老师要将班上 $N$ 个同学排成一列，同学被编号为 $1\sim N$，他采取如下的方法：</p>
<ol>
<li><p>先将 $1$ 号同学安排进队列，这时队列中只有他一个人；</p>
</li>
<li><p>$2-N$ 号同学依次入列，编号为 $i$ 的同学入列方式为：老师指定编号为 $i$ 的同学站在编号为 $1\sim(i-1)$ 中某位同学（即之前已经入列的同学）的左边或右边；</p>
</li>
<li><p>从队列中去掉 $M(M&lt;N)$ 个同学，其他同学位置顺序不变。</p>
</li>
</ol>
<p>在所有同学按照上述方法队列排列完毕后，老师想知道从左到右所有同学的编号。</p>
<h2 id="输入格式-3"><a href="#输入格式-3" class="headerlink" title="输入格式"></a>输入格式</h2><p>第 $1$ 行为一个正整数 $N$，表示了有 $N$ 个同学。</p>
<p>第 $2\sim N$行，第 $i$ 行包含两个整数 $k,p$，其中 $k$ 为小于 $i$ 的正整数，$p$ 为 $0$ 或者 $1$。若 $p$ 为$ 0$，则表示将 $i$ 号同学插入到 $k$ 号同学的左边，$p$ 为 $1$ 则表示插入到右边。</p>
<p>第 $N+1$ 行为一个正整数 $M$，表示去掉的同学数目。</p>
<p>接下来 $M$ 行，每行一个正整数 $x$，表示将 $x$ 号同学从队列中移去，如果 $x$ 号同学已经不在队列中则忽略这一条指令。</p>
<h2 id="输出格式-3"><a href="#输出格式-3" class="headerlink" title="输出格式"></a>输出格式</h2><p>$1$ 行，包含最多 $N$ 个空格隔开的正整数，表示了队列从左到右所有同学的编号，行末换行且无空格。</p>
<h2 id="样例-1-3"><a href="#样例-1-3" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-3"><a href="#样例输入-1-3" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">1 0</span><br><span class="line">2 1</span><br><span class="line">1 0</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">3</span><br></pre></td></tr></table></figure>

<h3 id="样例输出-1-3"><a href="#样例输出-1-3" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2 4 1 </span><br></pre></td></tr></table></figure>

<p>数据范围</p>
<p>对于 $20%$ 的数据，有 $1\leq N\leq 10$；</p>
<p>对于 $40%$ 的数据，有 $1\leq N\leq 1000$；</p>
<p>对于 $100%$ 的数据，有 $1\leq N,M\leq100000$。</p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1160">P1160 队列安排 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
<h2 id="Analyse-1"><a href="#Analyse-1" class="headerlink" title="Analyse:"></a>Analyse:</h2><p>将同学2插入至同学1左边，此时队列为：</p>
<p>2 1</p>
<p>将同学3插入至同学2右边，此时队列为：</p>
<p>2 3 1</p>
<p>将同学4插入至同学1左边，此时队列为：</p>
<p>2 3 4 1</p>
<p>将同学3从队列中移出，此时队列为：</p>
<p>2 4 1</p>
<p>同学3已经不在队列中，忽略最后一条指令</p>
<p>最终队列：</p>
<p>2 4 1</p>
<ul>
<li>初始化第一个同学前后都没有人</li>
<li>插入时，将当前人物的前后分别指向要插入k的前后，再将k前的人的next改到当前人数i,将k后的人pre指向i，右操作类似；</li>
</ul>
<h2 id="Code："><a href="#Code：" class="headerlink" title="Code："></a>Code：</h2><pre><code>#include&lt;cstdio&gt;
struct node&#123;
    int n;//保存节点的值
    node *left,*right;//左边右边各一个
    node(int t)&#123;//构造函数
        left=right=NULL;
        n=t;
    &#125;
&#125;*p[100010],*q;
int main()&#123;
    int m,n,i,j,k,u=1,v;
    p[1]=new node(1);
    scanf(&quot;%d&quot;,&amp;n);
    for(i=2;i&lt;=n;i++)&#123;
        scanf(&quot;%d%d&quot;,&amp;j,&amp;k);
        p[i]=new node(i);
        if(k)&#123;//插入过程
            if(p[j]-&gt;right)&#123;
                p[j]-&gt;right-&gt;left=p[i];
                p[i]-&gt;right=p[j]-&gt;right;    
            &#125;
            p[j]-&gt;right=p[i];
            p[i]-&gt;left=p[j];
        &#125;
        else&#123;
            if(p[j]-&gt;left)&#123;
                p[j]-&gt;left-&gt;right=p[i];
                p[i]-&gt;left=p[j]-&gt;left;    
            &#125;
            p[j]-&gt;left=p[i];
            p[i]-&gt;right=p[j];
            if(j==u)u=i;//用u来记录链表开端
        &#125;
    &#125;
    scanf(&quot;%d&quot;,&amp;m);
    for(i=1;i&lt;=m;i++)&#123;//删除过程
        scanf(&quot;%d&quot;,&amp;k);
        if(p[k]-&gt;left)
            p[k]-&gt;left-&gt;right=p[k]-&gt;right;
        if(p[k]-&gt;right)&#123;
            p[k]-&gt;right-&gt;left=p[k]-&gt;left;
            if(k==u)
                u=p[k]-&gt;right-&gt;n;
        &#125;
        p[k]-&gt;left=p[k]-&gt;right=NULL;
    &#125;
    q=p[u];
    while(q)&#123;//循环直到q为空
        printf(&quot;%d &quot;,q-&gt;n);
        q=q-&gt;right;
    &#125;
    return 0;
&#125;
</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/11/14/%E6%8E%92%E9%98%9F/" data-id="clfi3u93l000jgcw158gvcnu3" data-title="排队" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-二分查找与二分答案" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/11/11/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E4%B8%8E%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88/" class="article-date">
  <time class="dt-published" datetime="2022-11-11T07:56:03.000Z" itemprop="datePublished">2022-11-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/11/11/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E4%B8%8E%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88/">二分查找与二分答案</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>This is the second week.</p>
<h2 id="二分查找与二分答案"><a href="#二分查找与二分答案" class="headerlink" title="二分查找与二分答案"></a>二分查找与二分答案</h2><h4 id="P2249-【深基13-例1】查找"><a href="#P2249-【深基13-例1】查找" class="headerlink" title="P2249 【深基13.例1】查找"></a>P2249 【深基13.例1】查找</h4><h6 id="【深基13-例1】查找"><a href="#【深基13-例1】查找" class="headerlink" title="# 【深基13.例1】查找"></a># 【深基13.例1】查找</h6><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入 $n$ 个不超过 $10^9$ 的单调不减的（就是后面的数字不小于前面的数字）非负整数 $a_1,a_2,\dots,a_{n}$，然后进行 $m$ 次询问。对于每次询问，给出一个整数 $q$，要求输出这个数字在序列中第一次出现的编号，如果没有找到的话输出 $-1$ 。</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行 $2$ 个整数 $n$ 和 $m$，表示数字个数和询问次数。</p>
<p>第二行 $n$ 个整数，表示这些待查询的数字。</p>
<p>第三行 $m$ 个整数，表示询问这些数字的编号，从 $1$ 开始编号。</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一行，$m$ 个整数，以空格隔开，表示答案。</p>
<h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">11 3</span><br><span class="line">1 3 3 3 5 7 9 11 13 15 15</span><br><span class="line">1 3 6</span><br></pre></td></tr></table></figure>

<h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 2 -1</span><br></pre></td></tr></table></figure>

<h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p>数据保证，$1 \leq n \leq 10^6$，$0 \leq a_i,q \leq 10^9$，$1 \leq m \leq 10^5$</p>
<p>本题输入输出量较大，请使用较快的 IO 方式。</p>
<p>More info: <a target="_blank" rel="noopener" href="https://pintia.cn/problem-sets/1584759265956864000/exam/problems/1584759731948232704"><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2249">P2249 【深基13.例1】查找 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></a></p>
<h3 id="Analyse："><a href="#Analyse：" class="headerlink" title="Analyse："></a>Analyse：</h3><p>二分答案应该是在一个单调闭区间上进行的。也就是说，二分答案最后得到的答案应该是一个确定值，而不是像搜索那样会出现多解。二分一般用来解决最优解问题。刚才我们说单调性，那么这个单调性应该体现在哪里呢？</p>
<p>可以这样想，在一个区间上，有很多数，这些数可能是我们这些问题的解，换句话说，这里有很多不合法的解，也有很多合法的解。我们只考虑合法解，并称之为可行解。考虑所有可行解，我们肯定是要从这些可行解中找到一个最好的作为我们的答案， 这个答案我们称之为最优解。</p>
<h3 id="My-Code"><a href="#My-Code" class="headerlink" title="My Code:"></a>My Code:</h3><pre><code>include &lt;iostream&gt;
#include &lt;iomanip&gt;

using namespace std;

int a[1000010];
int n, m;

int find(int t) &#123;
    int res = -1;
    int l = 1, r = n, mid;
    while (l &lt;= r) &#123;
        //mid=(l+r)/2;
        mid = l + (r - l) / 2;
        if (a[mid] == t) &#123;
            res = mid;
            r = mid - 1;
        &#125; else if (a[mid] &gt; t) &#123;
            r = mid - 1;
        &#125; else &#123;
            l = mid + 1;
        &#125;
    &#125;
    return res;
&#125;

int main() &#123;
    cin &gt;&gt; n &gt;&gt; m;
    for (int i = 1; i &lt;= n; ++i) &#123;
        scanf(&quot;%d&quot;, &amp;a[i]);
    &#125;
    while (m--) &#123;
        int t;
        scanf(&quot;%d&quot;, &amp;t);
        cout &lt;&lt; find(t) &lt;&lt; &quot; &quot;;
    &#125;
    return 0;
&#125;
</code></pre>
<p>二分查找与二分答案</p>
<h4 id="P1824-进击的奶牛"><a href="#P1824-进击的奶牛" class="headerlink" title="P1824 进击的奶牛"></a>P1824 进击的奶牛</h4><h6 id="进击的奶牛"><a href="#进击的奶牛" class="headerlink" title="# 进击的奶牛"></a># 进击的奶牛</h6><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>Farmer John 建造了一个有 $N$($2$ $\le$ $N$ $\le$ $100000$) 个隔间的牛棚，这些隔间分布在一条直线上，坐标是 $x_1$ ,…,$x_N$<br> (0 $\le$ $x_i$ $\le$ $1000000000$)。</p>
<p>他的 $C$($2$ $\le$ $C$ $\le$ $N$) 头牛不满于隔间的位置分布，它们为牛棚里其他的牛的存在而愤怒。为了防止牛之间的互相打斗，Farmer John 想把这些牛安置在指定的隔间，所有牛中相邻两头的最近距离越大越好。那么，这个最大的最近距离是多少呢？</p>
<h2 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h2><p>第 $1$ 行：两个用空格隔开的数字 $N$ 和 $C$。</p>
<p>第 $2$ ~ $N+1$ 行：每行一个整数，表示每个隔间的坐标。</p>
<h2 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出只有一行，即相邻两头牛最大的最近距离。</p>
<h2 id="样例-1-1"><a href="#样例-1-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-1"><a href="#样例输入-1-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5 3</span><br><span class="line">1 </span><br><span class="line">2 </span><br><span class="line">8 </span><br><span class="line">4 </span><br><span class="line">9</span><br></pre></td></tr></table></figure>

<h3 id="样例输出-1-1"><a href="#样例输出-1-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://pintia.cn/problem-sets/1584759265956864000/exam/problems/1584759731948232704"><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1824">P1824 进击的奶牛 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></a></p>
<h3 id="Analyse：-1"><a href="#Analyse：-1" class="headerlink" title="Analyse："></a>Analyse：</h3><p>与第一题同样的思路，二分即可</p>
<h3 id="My-Code-1"><a href="#My-Code-1" class="headerlink" title="My Code:"></a>My Code:</h3><pre><code>#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;
int n,c,a[1000000],l,m,r;
bool check(int m)
&#123;
    int cnt=0;
    int d;
    int last=a[1];
    for(int i=2;i&lt;=n;i++)
    &#123;
        d=a[i]-last;
        if(d&gt;=m)
        &#123;
            cnt++;
            last=a[i];
        &#125;
    &#125;
    if(cnt+1&lt;c)return true;
    else return false;
&#125;
int main()
&#123;
    cin&gt;&gt;n&gt;&gt;c;
    for(int i=1;i&lt;=n;i++)
    &#123;
        cin&gt;&gt;a[i];
    &#125;
    sort(a+1,a+n+1);
    l=1;
    r=a[n]-a[1];
    while(l&lt;=r)
    &#123;
        m=(r+l)/2;
        if(check(m))
            r=m-1;
        else
            l=m+1;
    &#125;
    cout&lt;&lt;r&lt;&lt;endl;
    return 0;
&#125;
</code></pre>
<p>二分查找与二分答案</p>
<h4 id="P2678-NOIP2015-提高组-跳石头"><a href="#P2678-NOIP2015-提高组-跳石头" class="headerlink" title="P2678 [NOIP2015 提高组] 跳石头"></a>P2678 [NOIP2015 提高组] 跳石头</h4><h6 id="NOIP2015-提高组-跳石头"><a href="#NOIP2015-提高组-跳石头" class="headerlink" title="# [NOIP2015 提高组] 跳石头"></a># [NOIP2015 提高组] 跳石头</h6><h2 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h2><p>一年一度的“跳石头”比赛又要开始了!</p>
<h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>这项比赛将在一条笔直的河道中进行，河道中分布着一些巨大岩石。组委会已经选择好了两块岩石作为比赛起点和终点。在起点和终点之间，有 $N$ 块岩石（不含起点和终点的岩石）。在比赛过程中，选手们将从起点出发，每一步跳向相邻的岩石，直至到达终点。</p>
<p>为了提高比赛难度，组委会计划移走一些岩石，使得选手们在比赛过程中的最短跳跃距离尽可能长。由于预算限制，组委会至多从起点和终点之间移走 $M$ 块岩石（不能移走起点和终点的岩石）。</p>
<h2 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行包含三个整数 $L,N,M$，分别表示起点到终点的距离，起点和终点之间的岩石数，以及组委会至多移走的岩石数。保证 $L \geq 1$ 且 $N \geq M \geq 0$。</p>
<p>接下来 $N$ 行，每行一个整数，第 $i$ 行的整数 $D_i( 0 &lt; D_i &lt; L)$， 表示第 $i$ 块岩石与起点的距离。这些岩石按与起点距离从小到大的顺序给出，且不会有两个岩石出现在同一个位置。</p>
<h2 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式"></a>输出格式</h2><p>一个整数，即最短跳跃距离的最大值。</p>
<h2 id="样例-1-2"><a href="#样例-1-2" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-2"><a href="#样例输入-1-2" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">25 5 2 </span><br><span class="line">2</span><br><span class="line">11</span><br><span class="line">14</span><br><span class="line">17 </span><br><span class="line">21</span><br></pre></td></tr></table></figure>

<h3 id="样例输出-1-2"><a href="#样例输出-1-2" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure>

<h2 id="提示-1"><a href="#提示-1" class="headerlink" title="提示"></a>提示</h2><h3 id="输入输出样例-1-说明"><a href="#输入输出样例-1-说明" class="headerlink" title="输入输出样例 1 说明"></a>输入输出样例 1 说明</h3><p>将与起点距离为 $2$和 $14$ 的两个岩石移走后,最短的跳跃距离为 $4$(从与起点距离 $17$ 的岩石跳到距离 $21$ 的岩石,或者从距离 $21$ 的岩石跳到终点)。</p>
<h3 id="数据规模与约定"><a href="#数据规模与约定" class="headerlink" title="数据规模与约定"></a>数据规模与约定</h3><p>对于 $20%$的数据，$0 \le M \le N \le 10$。<br>对于 $50%$ 的数据，$0 \le M \le N \le 100$。<br>对于 $100%$的数据，$0 \le M \le N \le 50000,1 \le L<br> \le 10^9$。</p>
<p>More info:<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2678">P2678 [NOIP2015 提高组] 跳石头 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
<h3 id="Analyse"><a href="#Analyse" class="headerlink" title="Analyse:"></a>Analyse:</h3><p>从位置的小到大扫遍所有石头，用一个变量存储上一个跳到的点。第一个与这上一个点的距离大于等于x的石头即是下一个跳到的点。这里用了一点贪心的思想：因为如果不跳到第一个符合条件的点上，那么整个队列的稀疏度就会提高，最终需要删除的石头也会更多。因为我们要取最优状态，所以要保证跳过的石头数最少</p>
<h3 id="My-Code-2"><a href="#My-Code-2" class="headerlink" title="My Code:"></a>My Code:</h3><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long ll;
const int maxn = 5e4+5;
int far, n, m; 
int len[maxn];

bool check(int mid)&#123;
    int c = 0; 
    int num = 0; 
    for(int i=1; i&lt;=n; i++)&#123;
        if(len[i]-c &lt; mid) num++;
        else c = len[i];
    &#125;
    if(far-c &lt; mid) num++; 
    return num &lt;= m;
&#125;
int main()&#123;
    cin &gt;&gt; far &gt;&gt; n &gt;&gt; m;
    for(int i=1; i&lt;=n; i++)&#123;
        cin &gt;&gt; len[i];
    &#125;
    int left = 1, right = far;
    while(left &lt; right)&#123;
        int mid = left + (right-left+1)/2; 
        if(check(mid)) left = mid;
        else right = mid-1;
    &#125;
    cout &lt;&lt; left &lt;&lt; endl;
&#125;
</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/11/11/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E4%B8%8E%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88/" data-id="clfi3u93i000dgcw1fx6g60c4" data-title="二分查找与二分答案" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-模拟与高精度" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/11/11/%E6%A8%A1%E6%8B%9F%E4%B8%8E%E9%AB%98%E7%B2%BE%E5%BA%A6/" class="article-date">
  <time class="dt-published" datetime="2022-11-11T07:55:33.000Z" itemprop="datePublished">2022-11-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/11/11/%E6%A8%A1%E6%8B%9F%E4%B8%8E%E9%AB%98%E7%B2%BE%E5%BA%A6/">模拟与高精度</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <hr>
<p>This is the first week.</p>
<h2 id="模拟与高精度"><a href="#模拟与高精度" class="headerlink" title="模拟与高精度"></a>模拟与高精度</h2><h4 id="7-1-h0094-乒乓球"><a href="#7-1-h0094-乒乓球" class="headerlink" title="7-1 h0094. 乒乓球"></a>7-1 h0094. 乒乓球</h4><h6 id="国际乒联现在主席沙拉拉自从上任以来就立志于推行一系列改革，以推动乒乓球运动在全球的普及。"><a href="#国际乒联现在主席沙拉拉自从上任以来就立志于推行一系列改革，以推动乒乓球运动在全球的普及。" class="headerlink" title="国际乒联现在主席沙拉拉自从上任以来就立志于推行一系列改革，以推动乒乓球运动在全球的普及。"></a>国际乒联现在主席沙拉拉自从上任以来就立志于推行一系列改革，以推动乒乓球运动在全球的普及。</h6><p>其中11分制改革引起了很大的争议，有一部分球员因为无法适应新规则只能选择退役。</p>
<p>华华就是其中一位，他退役之后走上了乒乓球研究工作，意图弄明白11分制和21分制对选手的不同影响。</p>
<p>在开展他的研究之前，他首先需要对他多年比赛的统计数据进行一些分析，所以需要你的帮忙。</p>
<p>华华通过以下方式进行分析，首先将比赛每个球的胜负列成一张表，然后分别计算在11分制和21分制下，双方的比赛结果（截至记录末尾）。 </p>
<p>比如现在有这么一份记录，（其中W表示华华获得一分，L表示华华对手获得一分）： </p>
<p>WWWWWWWWWWWWWWWWWWWWWWLW </p>
<p>在11分制下，此时比赛的结果是华华第一局11比0获胜，第二局11比0获胜，正在进行第三局，当前比分1比1。</p>
<p>而在21分制下，此时比赛结果是华华第一局21比0获胜，正在进行第二局，比分2比1。</p>
<p>如果一局比赛刚开始，则此时比分为0比0。 </p>
<p>你的程序就是要对于一系列比赛信息的输入（WL形式），输出正确的结果。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>每个输入文件包含若干行字符串（每行至多20个字母），字符串由大写的W、L和E组成。</p>
<p>其中E表示比赛信息结束，程序应该忽略E之后的所有内容。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>输出由两部分组成，每部分有若干行，每一行对应一局比赛的比分（按比赛信息输入顺序）。</p>
<p>其中第一部分是11分制下的结果，第二部分是21分制下的结果，两部分之间由一个空行分隔。</p>
<h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><pre><code>WWWWWWWWWWWWWWWWWWWW
WWLWE
</code></pre>
<h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><pre><code>11:0
11:0
1:1

21:0
2:1
</code></pre>
<p>More info: <a target="_blank" rel="noopener" href="https://pintia.cn/problem-sets/1584759265956864000/exam/problems/1584759731948232704">题目详情 - 7-1 h0094. 乒乓球 (pintia.cn)</a></p>
<h3 id="Analyse："><a href="#Analyse：" class="headerlink" title="Analyse："></a>Analyse：</h3><p>在 11 分制下，与21分分别计算，直到分差大于或者等于 2，才一局结束。</p>
<h3 id="My-Code"><a href="#My-Code" class="headerlink" title="My Code:"></a>My Code:</h3><pre><code>#include &lt;iostream&gt;
#include &lt;math.h&gt;
using namespace std;
int main()&#123;
    int a[10000][2];
    int b[10000][2];
    char A;
    int i=0,j=0;
    int n1=0,n2=0,m1=0,m2=0;
    while(cin&gt;&gt;A)&#123;
        if(A==&#39;W&#39;)&#123;
            a[i][0]++;
            b[j][0]++;
            n1++;
            m1++;    
        &#125;
        else if(A==&#39;L&#39;)&#123;
            a[i][1]++;
            b[j][1]++;
            n2++;
            m2++;

        &#125;
        else if(A==&#39;E&#39;)&#123;
            break;

        &#125;
        if((n1&gt;=11||n2&gt;=11)&amp;&amp; (fabs(n1-n2)&gt;=2))&#123;
            i++;
            n1=0;
            n2=0;
        &#125;
        if((m1&gt;=21||m2&gt;=21)&amp;&amp;(fabs(m1-m2)&gt;=2))&#123;
            j++;
            m1=0;
            m2=0;
        &#125;
    &#125;

    for(int k=0;k&lt;=i;k++)&#123;
        cout&lt;&lt;a[k][0]&lt;&lt;&quot;:&quot;&lt;&lt;a[k][1]&lt;&lt;endl;
    &#125;
    cout&lt;&lt;endl;
    for(int k=0;k&lt;=j;k++)&#123;
        cout&lt;&lt;b[k][0]&lt;&lt;&quot;:&quot;&lt;&lt;b[k][1]&lt;&lt;endl;
    &#125;
    return 0;


&#125;
</code></pre>
<p>模拟与高精度</p>
<h2 id="7-2-高精度加法"><a href="#7-2-高精度加法" class="headerlink" title="7-2 高精度加法"></a>7-2 高精度加法</h2><h6 id="对于输入的两个不超过100位数字的非负整数，给出两数之和。"><a href="#对于输入的两个不超过100位数字的非负整数，给出两数之和。" class="headerlink" title="对于输入的两个不超过100位数字的非负整数，给出两数之和。"></a>对于输入的两个不超过100位数字的非负整数，给出两数之和。</h6><h3 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>在两行中分别给出两个不超过100位数字的非负整数</p>
<h3 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>在一行中输出两数之和</p>
<h3 id="输入样例-1"><a href="#输入样例-1" class="headerlink" title="输入样例:"></a>输入样例:</h3><pre><code>123
12
</code></pre>
<h3 id="输出样例-1"><a href="#输出样例-1" class="headerlink" title="输出样例:"></a>输出样例:</h3><pre><code>135
</code></pre>
<p>More info:<a target="_blank" rel="noopener" href="https://pintia.cn/problem-sets/1584759265956864000/exam/problems/1584759453123485696">题目详情 - 7-2 高精度加法 (pintia.cn)</a></p>
<h3 id="Analyse：-1"><a href="#Analyse：-1" class="headerlink" title="Analyse："></a>Analyse：</h3><p>高精度加法时用c[]数组来存，考虑进位的问题， 为什么要在a[i] + b[i] 再加上 c[i], 这是因为a[i] + b[i]可能会超过10，会有进位，进位我们都是往前面加的，所以就是加到c[i+1] 上，所以c[i] 上原来可能会有值</p>
<h3 id="My-Code-1"><a href="#My-Code-1" class="headerlink" title="My Code:"></a>My Code:</h3><pre><code>#include &lt;iostream&gt;
#include &lt;string.h&gt;
using namespace std;
int main()&#123;
    char a1[1000],b1[1000],c1[1000];
    int a[1000],b[1000],c[1000];
    cin&gt;&gt;a1;
    cin&gt;&gt;b1;
    int len1=strlen(a1);
    int len2=strlen(b1);
    if(len1&lt;len2)&#123;
        strcpy(c1,a1);
        strcpy(a1,b1);
        strcpy(b1,c1);
    &#125;
    len1=strlen(a1);
    len2=strlen(b1);
    for(int i=0;i&lt;len1;i++)&#123;
        a[i]=a1[i]-&#39;0&#39;;
    &#125;
    for(int i=0;i&lt;len2;i++)&#123;
        b[i]=b1[i]-&#39;0&#39;;
    &#125;
    int num,t=0;
    for(int i=0;i&lt;len1;i++)&#123;
        num=a[len1-1-i]+b[len2-1-i]+t;
        if(num&gt;=10)&#123;
            t=1;
            num=num-10;
        &#125;else&#123;
            t=0;
        &#125;
        c[len1-1-i]=num;
    &#125;
    if(t==1)&#123;
        for(int i=0;i&lt;len1-len2;i++)&#123;
            num=a[len1-1-len2-i]+t;
            if(num&gt;=10)&#123;
                t=1;
                num=num-10;
            &#125;else&#123;
                t=0;
            &#125;
            c[len1-1-len2-i]=num;
        &#125;
    &#125;
    if(t==1)cout&lt;&lt;&quot;1&quot;;
    for(int i=0;i&lt;len1;i++)&#123;
        cout&lt;&lt;c[i];
    &#125;


&#125;
</code></pre>
<p>模拟与高精度</p>
<h2 id="7-3-高精度求累加和"><a href="#7-3-高精度求累加和" class="headerlink" title="7-3 高精度求累加和"></a>7-3 高精度求累加和</h2><h6 id="使用求和公式求1到N的累加和大家都会，但是如果把N值变大呢，比如100位的整数，那该怎么求？"><a href="#使用求和公式求1到N的累加和大家都会，但是如果把N值变大呢，比如100位的整数，那该怎么求？" class="headerlink" title="使用求和公式求1到N的累加和大家都会，但是如果把N值变大呢，比如100位的整数，那该怎么求？"></a>使用求和公式求1到N的累加和大家都会，但是如果把N值变大呢，比如100位的整数，那该怎么求？</h6><h3 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>输入在一行中给出1个位数不超过100位的整数N。</p>
<h3 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>对每一组输入，在一行中输出1+2+3+……+N的值。</p>
<h3 id="输入样例-2"><a href="#输入样例-2" class="headerlink" title="输入样例:"></a>输入样例:</h3><p>在这里给出一组输入。例如：</p>
<pre><code>10
</code></pre>
<h3 id="输出样例-2"><a href="#输出样例-2" class="headerlink" title="输出样例:"></a>输出样例:</h3><p>在这里给出相应的输出。例如：</p>
<pre><code>55
</code></pre>
<p>More info:<a target="_blank" rel="noopener" href="https://pintia.cn/problem-sets/1584759265956864000/exam/problems/1584759453123485696"><a target="_blank" rel="noopener" href="https://pintia.cn/problem-sets/1584759265956864000/exam/problems/1584762843446525952">题目详情 - 7-3 高精度求累加和 (pintia.cn)</a></a></p>
<h3 id="Analyse：-2"><a href="#Analyse：-2" class="headerlink" title="Analyse："></a>Analyse：</h3><p>输入N，保存在a[]</p>
<p>&#x2F;&#x2F;计算N&#x2F;2，保存在b[]</p>
<p>&#x2F;计算N+1，保存在c[]</p>
<p> &#x2F;&#x2F;算最终的值    使用高精度乘法，交叉相乘，两个循环</p>
<h3 id="My-Code-2"><a href="#My-Code-2" class="headerlink" title="My Code:"></a>My Code:</h3><pre><code>#include &lt;iostream&gt;
#include &lt;string.h&gt;
int N=100000;
using namespace std;
int main()&#123;
    //输入N，保存在a[]
    string s;
    int a[N];
    cin&gt;&gt;s;
    int num=0,num1=0;
    num=s.size();
    memset(a,0,sizeof(a));
    for(int i=1;i&lt;num+1;i++)&#123;
        a[i]=s[num-i]-&#39;0&#39;;
    &#125;


    //计算N/2，保存在b[]
    int b[N];
    memset(b,0,sizeof(b));
    for(int i=0;i&lt;num;i++)&#123;
        b[num-i]=(a[num-i]+b[num-i])/2;
        b[num-i-1]=a[num-i]%2*10;
    &#125;
    b[0]/=2;
    //计算N+1，保存在c[]
    int c[N];
    memset(c,0,sizeof(c));
    c[1]=1;
    for(int i=1;i&lt;num+1;i++)&#123;
        c[i+1]=(a[i]+c[i])/10;
        c[i]=(a[i]+c[i])%10;

    &#125;
    if(c[num+1]==1)num1=num+1;
    else num1=num;

    //算最终的值
    int d[N];
    memset(d,0,sizeof(d));
    num=num+num1+1;
    for(int i=0;i&lt;num;i++)&#123;
        for(int j=0;j&lt;=i;j++)&#123;
            d[i]+=b[i-j]*c[j];
        &#125;
        if(d[i]&gt;=10)&#123;
            d[i+1]+=d[i]/10;
            d[i]=d[i]%10;
        &#125;

    &#125;
    for(int i=num;i&gt;=0;i--)&#123;
        if(d[i]==0)num--;
        else break;
    &#125;
    for(int i=num;i&gt;=2;i--)&#123;
        cout&lt;&lt;d[i];
    &#125;





&#125;
</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/11/11/%E6%A8%A1%E6%8B%9F%E4%B8%8E%E9%AB%98%E7%B2%BE%E5%BA%A6/" data-id="clfi3u93l000kgcw13xpp2wgl" data-title="模拟与高精度" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/03/">March 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/02/">February 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/01/">January 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/12/">December 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/11/">November 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/03/21/first/">first</a>
          </li>
        
          <li>
            <a href="/2023/02/13/%E5%BB%BA%E6%A0%88%E9%93%BE%E8%A1%A8/">建栈链表</a>
          </li>
        
          <li>
            <a href="/2023/01/10/%E5%8F%8C%E5%91%A8%E8%B5%9BThird/">双周赛Third</a>
          </li>
        
          <li>
            <a href="/2023/01/10/0x3f3f3f3f/">1061109567</a>
          </li>
        
          <li>
            <a href="/2023/01/10/pair%E7%9F%A5%E8%AF%86%E7%82%B9/">pair知识点</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>