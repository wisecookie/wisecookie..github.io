<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-week17" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/05/13/week17/" class="article-date">
  <time class="dt-published" datetime="2023-05-13T02:33:59.000Z" itemprop="datePublished">2023-05-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/05/13/week17/">week17</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <ol start="602">
<li>01序列2<br>原题链接：01序列2</li>
</ol>
<p>思路：用前缀和算出每一位的前面所有构造方法数量的和</p>
<p>代码：</p>
<p>#include &lt;bits&#x2F;stdc++.h&gt;<br>using namespace std;<br>int n, k, dp[1000005], sum[1000005];<br>const int mod &#x3D; 1e9 + 7;<br>int main(){<br>    cin &gt;&gt; n &gt;&gt; k;<br>    sum[0] &#x3D; 1;<br>    for(int i &#x3D; 1; i &lt;&#x3D; k + 1; i++){<br>        sum[i] &#x3D; (sum[i - 1] + 1) % mod;<br>    }<br>    for(int i &#x3D; k + 2; i &lt;&#x3D; n; i++){<br>        dp[i] &#x3D; (dp[i] + sum[i - k - 1]) % mod;<br>        sum[i] &#x3D; (dp[i] + sum[i - 1]) % mod;<br>    }<br>    cout &lt;&lt; sum[n];<br>    return 0;<br>}</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>603. 整除光棍<br>原题链接：整除光棍</p>
<p>思路：模拟</p>
<p>代码：</p>
<p>#include &lt;bits&#x2F;stdc++.h&gt;<br>using namespace std;<br>int x, sum, tmp, num[100005], indexx;<br>int main(){<br>    cin &gt;&gt; x;<br>    while(tmp &lt; x){<br>        tmp &#x3D; tmp * 10 + 1;<br>        sum++;<br>    }<br>    while(tmp % x !&#x3D; 0){<br>        num[indexx++] &#x3D; tmp &#x2F; x;<br>        tmp %&#x3D; x;<br>        tmp &#x3D; tmp * 10 + 1;<br>        sum++;<br>    }<br>    num[indexx++] &#x3D; tmp &#x2F; x;<br>    for(int i &#x3D; 0; i &lt; indexx; i++){<br>        cout &lt;&lt; num[i];<br>    }<br>    cout &lt;&lt; “ “ &lt;&lt; sum;<br>    return 0;<br>}</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>604. 碰撞2<br>原题链接：碰撞2</p>
<p>思路：用map储存点的位置和移动方向</p>
<p>代码：</p>
<p>#include &lt;bits&#x2F;stdc++.h&gt;<br>using namespace std;<br>int n;<br>string s;<br>bool flag;<br>struct point{<br>    int x, y;<br>    char dir;<br>} p[200005];<br>map&lt;int, set<point> &gt; mp;<br>bool operator&lt;(point a, point b){<br>    return a.x &lt; b.x;<br>}<br>int main(){<br>    cin &gt;&gt; n;<br>    for(int i &#x3D; 1; i &lt;&#x3D; n; i++){<br>        cin &gt;&gt; p[i].x &gt;&gt; p[i].y;<br>    }<br>    cin &gt;&gt; s;<br>    for(int i &#x3D; 0; i &lt; s.size(); i++){<br>        p[i + 1].dir &#x3D; s[i];<br>    }<br>    for(int i &#x3D; 1; i &lt;&#x3D; n; i++){<br>        mp[p[i].y].insert(p[i]);<br>    }<br>    for(auto i : mp){<br>        bool isR &#x3D; false;<br>        for(auto j : i.second){<br>            if(j.dir &#x3D;&#x3D; ‘L’ &amp;&amp; isR){<br>                flag &#x3D; true;<br>                break;<br>            }<br>            else{<br>                if(j.dir &#x3D;&#x3D; ‘L’) isR &#x3D; false;<br>                else isR &#x3D; true;<br>            }<br>        }<br>        if(flag) break;<br>    }<br>    if(flag) cout &lt;&lt; “Yes”;<br>    else cout &lt;&lt; “No”;<br>    return 0;<br>}</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>605. 优美！最长上升子序列<br>原题链接：优美！最长上升子序列</p>
<p>思路：直接依次遍历1~n的整数倍，判断是否是上升序列</p>
<p>代码：</p>
<p>#include &lt;bits&#x2F;stdc++.h&gt;<br>using namespace std;<br>int t, n, a[1000005], dp[1000005], maxx;<br>int main(){<br>    cin &gt;&gt; t;<br>    for(int k &#x3D; 0; k &lt; t; k++){<br>        maxx &#x3D; 1;<br>        cin &gt;&gt; n;<br>        for(int i &#x3D; 1; i &lt;&#x3D; n; i++) cin &gt;&gt; a[i], dp[i] &#x3D; 1;<br>        for(int i &#x3D; 1; i &lt;&#x3D; n; i++){<br>            for(int j &#x3D; i * 2; j &lt;&#x3D; n; j +&#x3D; i){<br>                if(a[j] &gt; a[i]) dp[j] &#x3D; max(dp[j], dp[i] + 1), maxx &#x3D; max(maxx, dp[j]);<br>            }<br>        }<br>        cout &lt;&lt; maxx &lt;&lt; endl;<br>    }<br>    return 0;<br>}</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>606. 巨大的牛棚<br>原题链接：巨大的牛棚</p>
<p>思路：动态规划</p>
<p>dp[i][j] &#x3D; min(dp[i - 1][j - 1], min(dp[i - 1][j], dp[i][j - 1])) + 1</p>
<p>找出最大的dp[i][j]即可。</p>
<p>代码：</p>
<p>#include &lt;bits&#x2F;stdc++.h&gt;<br>using namespace std;<br>int n, t, dp[1005][1005], v[1005][1005], maxx;<br>int main(){<br>    cin &gt;&gt; n &gt;&gt; t;<br>    for(int i &#x3D; 0; i &lt; t; i++){<br>        int x, y;<br>        cin &gt;&gt; x &gt;&gt; y;<br>        v[x][y] &#x3D; true;<br>    }<br>    for(int i &#x3D; 1; i &lt;&#x3D; n; i++){<br>        for(int j &#x3D; 1; j &lt;&#x3D; n; j++){<br>            if(!v[i][j]) dp[i][j] &#x3D; min(dp[i - 1][j - 1], min(dp[i - 1][j], dp[i][j - 1])) + 1, maxx &#x3D; max(maxx, dp[i][j]);<br>        }<br>    }<br>    cout &lt;&lt; maxx;<br>    return 0;<br>}</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>607. 高利贷<br>原题链接：高利贷</p>
<p>思路：二分查找p的值</p>
<p>代码：</p>
<p>#include &lt;bits&#x2F;stdc++.h&gt;<br>using namespace std;<br>double n, m, k, mid;<br>bool check(double p){<br>    double sum &#x3D; 0;<br>    for(int i &#x3D; 1; i &lt;&#x3D; k; i++){<br>        sum +&#x3D; m &#x2F; pow(1 + p, i);<br>    }<br>    if(sum &gt;&#x3D; n) return true;<br>    else return false;<br>}<br>int main(){<br>    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;<br>    double st &#x3D; 0, ed &#x3D; 10;<br>    while(st &lt; ed){<br>        mid &#x3D; (st + ed) &#x2F; 2;<br>        if(ed - st &lt; 1e-6) break;<br>        if(check(mid)) st &#x3D; mid;<br>        else ed &#x3D; mid;<br>    }<br>    cout &lt;&lt; fixed &lt;&lt; setprecision(6) &lt;&lt; mid;<br>    return 0;<br>}</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>701. 背包<br>原题链接：背包</p>
<p>思路：依次遍历每一个物品</p>
<p>代码：</p>
<p>#include &lt;bits&#x2F;stdc++.h&gt;<br>using namespace std;<br>long long t, n, w, a[200005];<br>int main(){<br>    cin &gt;&gt; t;<br>    for(int i &#x3D; 0; i &lt; t; i++){<br>        cin &gt;&gt; n &gt;&gt; w;<br>        for(int i &#x3D; 1; i &lt;&#x3D; n; i++){<br>            cin &gt;&gt; a[i];<br>        }<br>        long long sum &#x3D; 0;<br>        bool flag &#x3D; false;<br>        for(int i &#x3D; 1; i &lt;&#x3D; n; i++){<br>            if(2 * a[i] &gt;&#x3D; w &amp;&amp; a[i] &lt;&#x3D; w){<br>                cout &lt;&lt; “YES\n”;<br>                flag &#x3D; true;<br>                break;<br>            }<br>            else if(a[i] &lt; w){<br>                sum +&#x3D; a[i];<br>            }<br>            if(2 * sum &gt;&#x3D; w &amp;&amp; sum &lt;&#x3D; w){<br>                cout &lt;&lt; “YES\n”;<br>                flag &#x3D; true;<br>                break;<br>            }<br>            else if(sum &gt; w){<br>                sum &#x3D; 0;<br>            }<br>        }<br>        if(!flag) cout &lt;&lt; “NO\n”;<br>    }<br>    return 0;<br>}</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>702. 三回文序列<br>原题链接：三回文序列</p>
<p>代码：</p>
<p>#include &lt;bits&#x2F;stdc++.h&gt;<br>using namespace std;<br>int t, n, a[200005], sum[30], tmp[30], ans;<br>int main(){<br>    cin &gt;&gt; t;<br>    for(int k &#x3D; 0; k &lt; t; k++){<br>        cin &gt;&gt; n;<br>        ans &#x3D; 0;<br>        memset(sum, 0, sizeof(sum));<br>        for(int i &#x3D; 1; i &lt;&#x3D; n; i++) cin &gt;&gt; a[i], sum[a[i]]++;<br>        for(int i &#x3D; 1; i &lt;&#x3D; 26; i++){<br>            int cnt &#x3D; 0, maxlen &#x3D; sum[a[i]];<br>            for(int j &#x3D; 1; j &lt;&#x3D; 26; j++) tmp[j] &#x3D; sum[j];<br>            int l &#x3D; 1, r &#x3D; n;<br>            while(l &lt; r){<br>                while(a[l] !&#x3D; i &amp;&amp; l &lt; r){<br>                    tmp[a[l]]–;<br>                    l++;<br>                }<br>                while(a[r] !&#x3D; i &amp;&amp; l &lt; r){<br>                    tmp[a[r]]–;<br>                    r–;<br>                }<br>                cnt +&#x3D; min(2, tmp[i]);<br>                tmp[i] &#x3D; max(0, tmp[i] - 2);<br>                for(int j &#x3D; 1; j &lt;&#x3D; 26; j++) maxlen &#x3D; max(maxlen, cnt + tmp[j]);<br>                l++, r–;<br>            }<br>            ans &#x3D; max(ans, maxlen);<br>        }<br>        cout &lt;&lt; ans &lt;&lt; endl;<br>    }<br>    return 0;<br>}</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>703. 简单的异或问题<br>原题链接：简单的异或问题</p>
<p>代码：</p>
<p>#include &lt;bits&#x2F;stdc++.h&gt;<br>using namespace std;<br>long long n, m;<br>int main(){<br>    cin &gt;&gt; n &gt;&gt; m;<br>    if(m &#x3D;&#x3D; 1 &amp;&amp; n &#x3D;&#x3D; 0) cout &lt;&lt; 1;<br>    else if(m &#x3D;&#x3D; 1 &amp;&amp; n &#x3D;&#x3D; 1) cout &lt;&lt; 2;<br>    else if(n !&#x3D; 0) cout &lt;&lt; (long long)pow(2, m) - 1;<br>    else cout &lt;&lt; (long long)pow(2, m);<br>    return 0;<br>}<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>704. 子串的循环挪动<br>原题链接：子串的循环挪动</p>
<p>#include &lt;bits&#x2F;stdc++.h&gt;<br>using namespace std;<br>string s;<br>int m, l, r, k;<br>int main(){<br>    cin &gt;&gt; s &gt;&gt; m;<br>    s &#x3D; “ “ + s;<br>    for(int i &#x3D; 0; i &lt; m; i++){<br>        cin &gt;&gt; l &gt;&gt; r &gt;&gt; k;<br>        int dis &#x3D; k % (r - l + 1);<br>        while(dis–){<br>        char tmp &#x3D; s[r];<br>            for(int j &#x3D; r; j &gt; l; j–){<br>                s[j] &#x3D; s[j - 1];<br>            }<br>            s[l] &#x3D; tmp;<br>        }<br>    }<br>    s.erase(0, 1);<br>    cout &lt;&lt; s;<br>    return 0;<br>}</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/05/13/week17/" data-id="clhle0zpe0002a4w11izg5da9" data-title="week17" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-week16" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/05/13/week16/" class="article-date">
  <time class="dt-published" datetime="2023-05-13T02:33:55.000Z" itemprop="datePublished">2023-05-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/05/13/week16/">week16</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>1、数组操作</p>
<p>我们每次操作都是把最数组最后的相邻的x的个数乘2 。</p>
<p>例如：一个数组{1,2,3,4,5,6,7,8}<br>-&gt; {1,2,3,4,5,6,8,8}<br>-&gt;{1,2,3,4,8,8,8,8}<br>-&gt;{8,8,8,8,8,8,8,8}<br>8的个数依次为1-&gt;2-&gt;4-&gt;8</p>
<p>#include<iostream><br>using namespace std;<br>#include<vector></p>
<p>#pragma GCC optimize(1)<br>#pragma GCC optimize(2)<br>#pragma GCC optimize(3,”Ofast”,”inline”)</p>
<p>#define endl ‘\n’;<br>typedef long long ll;<br>const int N &#x3D; 110;</p>
<p>int main() {<br>    ios_base::sync_with_stdio(false);<br>    cin.tie(nullptr);<br>    cout.tie(nullptr);<br>    int t;<br>    cin &gt;&gt; t;<br>    while (t–)<br>    {<br>        int n;<br>        cin &gt;&gt; n;<br>        vector<int>v(n);<br>        for (int i &#x3D; n-1; i &gt;&#x3D;0 ; i–)<br>            cin &gt;&gt; v[i];<br>        int num &#x3D; v[0], res &#x3D; 0, ans &#x3D; 1;<br>        while (ans &lt; n)<br>        {<br>            if (v[ans] &#x3D;&#x3D; num)ans++;<br>            else<br>            {<br>                res++;<br>                ans *&#x3D; 2;<br>            }<br>        }<br>        cout &lt;&lt; res &lt;&lt; endl;<br>    }<br>    return 0;</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>2、A-B 数对</p>
<p>#include<iostream><br>#include<vector><br>#include<algorithm><br>#include<map><br>using namespace std;<br>int main()<br>{<br>    std::ios::sync_with_stdio(false);<br>    cin.tie(0);<br>    cout.tie(0);<br>    int n,c;<br>    int ans&#x3D;0;<br>    vector<int>v;<br>    map&lt;int,int&gt;mymap;<br>    cin&gt;&gt;n&gt;&gt;c;<br>    for(int i&#x3D;1;i&lt;&#x3D;n;i++)<br>    {<br>        int x;<br>        cin&gt;&gt;x;<br>        mymap[x]++;<br>        v.push_back(x);<br>    }<br>    sort(v.begin(),v.end());<br>    for(int i&#x3D;0;i&lt;n;i++)<br>    {<br>        ans+&#x3D;mymap[v[i]+1];<br>    }<br>    cout&lt;&lt;ans;<br>    return 0;</p>
<p>}</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>数位计算</p>
<p>#include<iostream><br>#define ll long long<br>using namespace std;<br>int main()<br>{<br>    std::ios::sync_with_stdio(false);<br>    cin.tie(0);<br>    cout.tie(0);<br>    const int mod&#x3D;998244353;<br>    ll a;<br>    ll sum&#x3D;0;<br>    ll i&#x3D;1;<br>    cin&gt;&gt;a;<br>    if(a&lt;&#x3D;9)<br>    {<br>        cout&lt;&lt;(a+1)<em>a&#x2F;2;<br>        return 0;<br>    }<br>    while(a&gt;&#x3D;i)<br>    {<br>        ll x&#x3D;(1+i</em>10-i)%mod;<br>        ll y&#x3D;(i<em>10-i)%mod;<br>        ll xx&#x3D;(2+a-i)%mod;<br>        ll yy&#x3D;(a-i+1)%mod;<br>        if(a&gt;&#x3D;i</em>10)sum+&#x3D;(x<em>y&#x2F;2)%mod;<br>        else sum+&#x3D;(xx</em>yy&#x2F;2)%mod;<br>        i*&#x3D;10;<br>    }</p>
<pre><code>cout&lt;&lt;sum%mod;
return 0;
</code></pre>
<p>}</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>4、新国王游戏</p>
<p>#include<iostream><br>#include<vector><br>#include<algorithm><br>#define ll long long<br>using namespace std;<br>struct h<br>{<br>    ll a,b;<br>};<br>bool temp(h x,h y)<br>{<br>    return (x.a-1)<em>y.b&gt;(y.a-1)<em>x.b;<br>}<br>int main()<br>{<br>    std::ios::sync_with_stdio(false);<br>    cin.tie(0);<br>    cout.tie(0);<br>    const int mod&#x3D;1000000007;<br>    ll n;<br>    ll ans&#x3D;0,sum_a&#x3D;1;<br>    vector<h> v;<br>    cin&gt;&gt;n;<br>    for(int i&#x3D;0;i&lt;n;i++)<br>    {<br>        int x,y;<br>        cin&gt;&gt;x&gt;&gt;y;<br>        v.push_back((h){x,y});<br>    }<br>    sort(v.begin(),v.end(),temp);<br>    for(int i&#x3D;0;i&lt;n;i++)<br>    {<br>        ans+&#x3D;sum_a</em>v[i].b%mod;<br>        ans%&#x3D;mod;<br>        sum_a</em>&#x3D;v[i].a;<br>        sum_a%&#x3D;mod;<br>    }<br>    cout&lt;&lt;ans%mod;<br>    return 0;</p>
<p>}</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>5、完美数</p>
<p>#include<iostream><br>#define ll long long<br>using namespace std;<br>const int mod&#x3D;1e9+7;<br>const int N&#x3D;1e6+1;<br>int a,b;<br>ll fact[N];    &#x2F;&#x2F;fact[i]表示i的阶乘<br>ll infact[N];    &#x2F;&#x2F;infact[i]表示i的阶乘的逆元<br>bool check(ll x)<br>{<br>    while(x&gt;0)<br>    {<br>        if(x%10!&#x3D;a&amp;&amp;x%10!&#x3D;b)<br>        {<br>            return 0;<br>        }<br>        x&#x2F;&#x3D;10;<br>    }<br>    return 1;<br>}<br>int qmi(int a,int b)    &#x2F;&#x2F;求a的b次方对mod求模的结果<br>{<br>    ll res&#x3D;1;<br>    while(b)<br>    {<br>        if(b&amp;1)res&#x3D;res<em>a%mod;<br>        a&#x3D;a</em>(ll)a%mod;<br>        b&gt;&gt;&#x3D;1;<br>    }<br>    return res;<br>}<br>void rr()        &#x2F;&#x2F;求阶乘及阶乘的逆元<br>{<br>    fact[0]&#x3D;1;<br>    for(int i&#x3D;1;i&lt;N;i++)<br>    {<br>        fact[i]&#x3D;fact[i-1]<em>i%mod;<br>    }<br>    infact[N-1]&#x3D;qmi(fact[N-1],mod-2);<br>    for(int i&#x3D;N-2;i&gt;&#x3D;0;i–)<br>    {<br>        infact[i]&#x3D;infact[i+1]</em>(i+1)%mod;<br>    }</p>
<p>}</p>
<p>int main()<br>{<br>    std::ios::sync_with_stdio(false);<br>    cin.tie(0);<br>    cout.tie(0);<br>    ll m;<br>    ll res&#x3D;0;<br>    cin&gt;&gt;a&gt;&gt;b&gt;&gt;m;<br>    rr();<br>    if(a&#x3D;&#x3D;b)<br>    {<br>        cout&lt;&lt;0;<br>        return 0;<br>    }<br>    if(a&gt;b)swap(a,b);    &#x2F;&#x2F;a作为小一点的数<br>    for(ll i&#x3D;0;i&lt;&#x3D;m;i++)<br>    {<br>        ll s&#x3D;i*a+(m-i)*b;<br>        if(check(s))<br>        {    &#x2F;&#x2F;将i个a和(m-i)个b组合成一个好数即可<br>            ll i2&#x3D;min(i,m-i);        &#x2F;&#x2F;c(m)(i)&#x3D;&#x3D;c(m)(m-i)<br>            res&#x3D;(res+fact[m]<em>infact[i2]%mod</em>infact[m-i2]%mod)%mod;&#x2F;&#x2F;即排列组合，共有C(m)(i2)种组合<br>        }<br>    }<br>    cout&lt;&lt;res%mod;<br>    return 0;</p>
<p>}</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>50<br>51<br>52<br>53<br>54<br>55<br>56<br>57<br>58<br>59<br>60<br>61<br>62<br>63<br>64<br>65<br>66<br>67<br>68<br>69<br>70<br>71<br>72<br>73<br>74<br>75<br>76<br>77<br>6、Lusir的游戏</p>
<p>#include<iostream><br>#include<cmath><br>using namespace std;<br>int main()<br>{<br>    std::ios::sync_with_stdio(false);<br>    cin.tie(0);<br>    cout.tie(0);<br>    const int N&#x3D;1e5+1;<br>    int n;<br>    int a[N];<br>    double ans&#x3D;0;<br>    cin&gt;&gt;n;<br>    for(int i&#x3D;1;i&lt;&#x3D;n;i++)cin&gt;&gt;a[i];<br>    for(int i&#x3D;n;i&gt;&#x3D;1;i–)<br>    {<br>        ans&#x3D;(ans+a[i])&#x2F;2;<br>    }<br>    cout&lt;&lt;ceil(ans);<br>    return 0;</p>
<p>}</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>7、BFS练习1</p>
<p>#include<iostream><br>#include<queue><br>#include<cmath><br>using namespace std;<br>const int N&#x3D;1e5+55;<br>int a,q;<br>int b[N];<br>int ans[N]&#x3D;{0};<br>int js;<br>void bfs(int n)        &#x2F;&#x2F;把n变成x<br>{<br>    js&#x3D;0;<br>    bool vis[N]&#x3D;{0};<br>    queue<int>s;<br>    s.push(n);<br>    vis[n]&#x3D;1;<br>    while(!s.empty())<br>    {<br>        int len&#x3D;s.size();<br>        for(int i&#x3D;1;i&lt;&#x3D;len;i++)<br>        {<br>            int nn&#x3D;s.front();<br>            s.pop();<br>            if(ans[nn]&#x3D;&#x3D;-1)<br>            {<br>                ans[nn]&#x3D;js;<br>            }<br>            if(nn+1&lt;1e5+50&amp;&amp;vis[nn+1]&#x3D;&#x3D;0)<br>            {<br>                s.push(nn+1);<br>                vis[nn+1]&#x3D;1;<br>            }<br>            if(nn*2&lt;1e5+50&amp;&amp;vis[nn*2]&#x3D;&#x3D;0)<br>            {<br>                s.push(nn*2);<br>                vis[nn*2]&#x3D;1;<br>            }<br>            if(nn*3&lt;1e5+50&amp;&amp;vis[nn*3]&#x3D;&#x3D;0)<br>            {<br>                s.push(nn*3);<br>                vis[nn*3]&#x3D;1;<br>            }<br>            if(nn-1&gt;0&amp;&amp;vis[nn-1]&#x3D;&#x3D;0)<br>            {<br>                s.push(nn-1);<br>                vis[nn-1]&#x3D;1;<br>            }<br>        }<br>        js++;<br>    }</p>
<p>}<br>int main()<br>{<br>    std::ios::sync_with_stdio(false);<br>    cin.tie(0);<br>    cout.tie(0);<br>    cin&gt;&gt;a&gt;&gt;q;<br>    for(int i&#x3D;1;i&lt;&#x3D;q;i++)<br>    {<br>        cin&gt;&gt;b[i];<br>        ans[b[i]]&#x3D;-1;<br>    }<br>    bfs(a);<br>    for(int i&#x3D;1;i&lt;&#x3D;q;i++)<br>    {<br>        cout&lt;&lt;ans[b[i]]&lt;&lt;’ ‘;<br>    }<br>    return 0;</p>
<p>}</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>50<br>51<br>52<br>53<br>54<br>55<br>56<br>57<br>58<br>59<br>60<br>61<br>62<br>63<br>64<br>65<br>66<br>67<br>68<br>69<br>70<br>71<br>72<br>8、01序列2</p>
<p>dp[i]&#x3D;dp[1]+dp[2]+……+dp[i-k-1]+1<br>#include<iostream><br>#include<vector><br>#define ll long long<br>using namespace std;<br>int main()<br>{<br>    ios::sync_with_stdio(false);<br>    cin.tie(0);<br>    cout.tie(0);<br>    const int N&#x3D;1e6+5;<br>    const int mod&#x3D;1e9+7;<br>    int n,k;<br>    vector<ll> dp(N);<br>    vector<ll> sum(N,0);    &#x2F;&#x2F;sum[i]表示dp[1]+dp[2]+…dp[i]<br>    cin&gt;&gt;n&gt;&gt;k;<br>    sum[0]&#x3D;0;<br>    for(int i&#x3D;1;i&lt;&#x3D;n;i++)<br>    {<br>        &#x2F;<em>ll sum&#x3D;0;<br>        for(int j&#x3D;i-1;j&gt;&#x3D;1;j–)<br>            sum+&#x3D;dp[j];</em>&#x2F;<br>        &#x2F;&#x2F;这样做时间复杂度为o(n^2),考虑进行前缀和优化<br>        if(i-k-1&gt;0)dp[i]&#x3D;(sum[i-k-1]+1)%mod;<br>        else dp[i]&#x3D;1;<br>        sum[i]&#x3D;(sum[i-1]+dp[i])%mod;<br>    }</p>
<pre><code>cout&lt;&lt;sum[n]+1;
return 0;
</code></pre>
<p>}</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/05/13/week16/" data-id="clhle0zpc0001a4w16umf29ne" data-title="week16" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-week15" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/05/13/week15/" class="article-date">
  <time class="dt-published" datetime="2023-05-13T02:33:45.000Z" itemprop="datePublished">2023-05-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/05/13/week15/">week15</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>1、快快变大<br>题目描述<br>给定一个长度为 n 的数组 a1,a2,…,an，接下来进行 n−1 次操作。每次选择一个下标 x ，将 ax 和 ax+1 合并成 ax×ax+1mod1000003 ，并且你会获得 (ax−ax+1)2 的分数。</p>
<p>所以每次操作后，数组的长度将会减 1，当最后只剩下一个元素时停止操作。输出最终能获得的最大分数。</p>
<p>输入格式<br>第一行一个数字 n。<br>接下来一行 n 个整数 a1,a2,…,an。</p>
<p>输出格式<br>一个数，表示答案。</p>
<p>样例输入<br>3<br>1 2 3<br>样例输出<br>26<br>数据规模<br>所有数据保证 1≤n≤300,1≤ai≤106。</p>
<p>思路：<br>这题是区间dp题</p>
<p>但是，这题在对求从 a[i] 到 a[j] 的乘积时有一点要讲究的地方。若用sum[k]表示从a[1]乘到a[k]，我们能想到从 a[i] 到 a[j] 的乘积就是sum[j]&#x2F;sum[i-1]，但事实上数据太大我们可能无法用sum[j]来存储（注意先取余再整除是错误的），所以必须用sum[i][j]来表示从a[i]一直乘到a[j]。</p>
<p>#include<iostream><br>using namespace std;<br>#include<vector><br>#include<algorithm><br>#include&lt;math.h&gt;<br>#include<set><br>#include<numeric><br>#include<string><br>#include&lt;string.h&gt;<br>#include<map><br>#include<unordered_map><br>#include<stack><br>#include<list><br>#include<queue></p>
<p>#pragma GCC optimize(1)<br>#pragma GCC optimize(2)<br>#pragma GCC optimize(3,”Ofast”,”inline”)</p>
<p>typedef long long ll;<br>typedef pair&lt;ll, ll&gt;PII;<br>const int N &#x3D; 1010, MOD &#x3D; 1000003;<br>ll f[N][N], s[N][N],v[N];</p>
<p>int main()<br>{<br>    int n;<br>    cin &gt;&gt; n;<br>    for (int i &#x3D; 1; i &lt;&#x3D; n; i++)<br>    {<br>        cin &gt;&gt; v[i];<br>    }<br>    for (int i &#x3D; 1; i &lt;&#x3D; n; i++)<br>    {<br>        s[i][i] &#x3D; 1;<br>        s[i][i-1] &#x3D; 1;<br>        for (int j &#x3D; i; j &lt;&#x3D; n; j++)<br>        {<br>            s[i][j] &#x3D; (v[j] * s[i][j - 1]) % MOD;<br>        }<br>    }<br>    for (int len &#x3D; 2; len &lt;&#x3D; n; len++)<br>    {<br>        for (int i &#x3D; 1; i + len - 1 &lt;&#x3D; n; i++)<br>        {<br>            int j &#x3D; i + len - 1;<br>            for (int k &#x3D; i; k &lt; j; k++)<br>            {<br>                f[i][j] &#x3D; max(f[i][j], f[i][k] + f[k + 1][j] + (s[i][k]-s[k+1][j])* (s[i][k] - s[k + 1][j]));<br>            }<br>        }<br>    }<br>    cout &lt;&lt; f[1][n] &lt;&lt; endl;<br>    return 0;<br>}</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>50<br>51<br>52<br>53<br>54<br>55<br>2、饿饿 饭饭2<br>题目描述<br>接着《饿饿 饭饭》 的故事，在两天后，食堂的工作人员回来了，整个食堂又回到了原来井井有条的状态。</p>
<p>两个月后，由于天气越来越热，大家的胃口越来越小了，作为食堂管理员的CC非常担心孩子们的身体健康，所以他决定开展一个活动来调动孩子们吃饭的积极性，顺便考验一下孩子们的数学水平。活动内容如下：</p>
<p>先让每一个孩子都抽一个球，每一个球上有一个数字， 然后给这个孩子n个数字，每一个孩子都有无数次操作机会，每一次都会选中一个数将它乘上2，或者乘上3，请问这个孩子可以通过上面的操作将这n个数都变成相同的吗？</p>
<p>如果回答正确，这个回答正确的孩子就可以得到一份免费的午餐，但是这对于孩子们来说是在是太困难了，但是他们都想吃到免费的午餐，所以他们都想请你告诉他们正确的答案，让他们都迟到免费的午餐。</p>
<p>输入格式<br>第1行给定一个数T，表示有T个小孩子请你告诉他正确的答案。</p>
<p>第2到T+1行，第1个数是每个孩子抽到的数字n，第2到n+1个数是对应的n个数字。</p>
<p>输出格式<br>如果可以变成相同的，输出YES。如果不能变成相同的，输出NO。</p>
<p>数据规模<br>1≤T≤100,1≤n≤2×105,1≤ai≤109<br>数据保证∑T（i&#x3D;1）n≤2×105<br>样例输入<br>2<br>4 75 150 75 50<br>3 100 150 250<br>样例输出<br>YES<br>NO</p>
<p>#include<iostream><br>#include<algorithm><br>#define ll long long<br>using namespace std;<br>ll a[200001];<br>int main()<br>{<br>    std::ios::sync_with_stdio(false);<br>    cin.tie(0);<br>    cout.tie(0);<br>    int t;<br>    cin&gt;&gt;t;<br>    while(t–)<br>    {<br>        int n;<br>        bool flag&#x3D;0;<br>        cin&gt;&gt;n;<br>        for(int i&#x3D;1;i&lt;&#x3D;n;i++)cin&gt;&gt;a[i];<br>        for(int i&#x3D;1;i&lt;n;i++)<br>        {<br>            ll x&#x3D;a[i]<em>a[i+1]&#x2F;__gcd(a[i],a[i+1]);    &#x2F;&#x2F;最小公倍数<br>            ll x1&#x3D;x&#x2F;a[i];<br>            ll x2&#x3D;x&#x2F;a[i+1];<br>            ll record_x1&#x3D;-1,record_x2&#x3D;-1;<br>            while(x1&gt;0||x2&gt;0)<br>            {<br>                if(x1&#x2F;2</em>2&#x3D;&#x3D;x1)x1&#x2F;&#x3D;2;                &#x2F;&#x2F;能被2整除则除以2<br>                if(x1&#x2F;3<em>3&#x3D;&#x3D;x1)x1&#x2F;&#x3D;3;                &#x2F;&#x2F;能被3整除则除以3<br>                if(x2&#x2F;2</em>2&#x3D;&#x3D;x2)x2&#x2F;&#x3D;2;<br>                if(x2&#x2F;3*3&#x3D;&#x3D;x2)x2&#x2F;&#x3D;3;<br>                if(record_x1&#x3D;&#x3D;x1&amp;&amp;record_x2&#x3D;&#x3D;x2)break;<br>                record_x1&#x3D;x1;<br>                record_x2&#x3D;x2;<br>            }<br>            if(x1!&#x3D;1||x2!&#x3D;1)                        &#x2F;&#x2F;若因子只含有2和3则结果一定均为1<br>            {<br>                cout&lt;&lt;”NO”&lt;&lt;’\n’;<br>                flag&#x3D;1;<br>                break;<br>            }<br>        }<br>        if(flag&#x3D;&#x3D;0)cout&lt;&lt;”YES”&lt;&lt;’\n’;<br>    }<br>    return 0;</p>
<p>}</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>3、子串分值和<br>题目描述<br>对于一个字符串 S ，我们定义 f(S) 为 S 中出现的不同的字符个数。<br>例如 f(aba)&#x3D;2,f(abc)&#x3D;3,f(aaa)&#x3D;1。<br>现在给定一个字符串 S (假设长度为 len)，请你计算 ∑i&#x3D;0len−1∑j&#x3D;ilen−1f(S[i:j]) 。</p>
<p>输入格式<br>输入一行包含一个由小写字母组成的字符串 S 。</p>
<p>输出格式<br>输出一个整数表示答案。</p>
<p>样例输入<br>ababc<br>样例输出<br>28<br>数据规模<br>所有数据保证字符串长度 len≤1000000，字符串下标从 0 到 len−1。思路：<br>题目是需要求出每个子串中小写字母的种类数之和，即对于每一个小写字母，含有该小写字母的子串数之和。即题目所求可转化为：含a的子串数+含b的子串数+……+含z的子串数。而含有某个字母的子串数不太好求，我们又可以将其转化为：总子串数 - 不含该字母的子串数。</p>
<p>#include<iostream><br>#include<vector><br>using namespace std;<br>int main()<br>{<br>    std::ios::sync_with_stdio(false);<br>    cin.tie(0);<br>    cout.tie(0);<br>    string s;<br>    long long len;<br>    long long res&#x3D;0;<br>    long long sum&#x3D;0;<br>    cin&gt;&gt;s;<br>    len&#x3D;s.length();<br>    sum&#x3D;(len+1)*len&#x2F;2;        &#x2F;&#x2F;总的子串数<br>    for(char i&#x3D;’a’;i&lt;&#x3D;’z’;i++)<br>    {<br>        long long s1&#x3D;0;        &#x2F;&#x2F;不含该小写字母的子串数<br>        long long k&#x3D;0;<br>        for(int j&#x3D;0;j&lt;len;j++)<br>        {<br>            if(s[j]!&#x3D;i)k++;<br>            else<br>            {<br>                s1+&#x3D;(k+1)*k&#x2F;2;<br>                k&#x3D;0;<br>            }<br>        }<br>        s1+&#x3D;(k+1)*k&#x2F;2;<br>        res+&#x3D;sum-s1;<br>    }<br>    cout&lt;&lt;res;<br>    return 0;</p>
<p>}</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>4、蒟蒻<br>题目描述<br>便利蜂的货架上摆了一排蒟蒻果冻，搞得鶸尛鱻眼花缭乱…</p>
<p>对于每个果冻，都有一个价格 w 和口感 t。鶸尛鱻有一个购物篮子，在挑选蒟蒻果冻的时候，他有以下几种操作：</p>
<p>操作 1：把一个价格为 w，口感为 t 的果冻放入篮子。<br>操作 2：拿出篮子中 最为廉价 的果冻。<br>操作 3：拿出篮子中 口感最差 的果冻。（t 越小，口感越差）鶸尛鱻不喜欢重复，当操作 1 的 价格或口感 与篮中已有果冻重复时，他会立刻将其放回货架。</p>
<p>经过 n 次操作后，鶸尛鱻确定了要购买的若干果冻，请你帮他求出篮子里果冻的总价格。</p>
<p>输入格式<br>第 1 行一个正整数 n，代表操作次数。</p>
<p>第 2 行至第 (n+1) 行，每行 一个或三个 整数，分别表示 op，w，t。</p>
<p>w 和 t 当且仅当 op&#x3D;1 时存在。</p>
<p>输出格式<br>输出一个整数，表示篮子里果冻的总价格。</p>
<p>样例输入<br>6<br>1 1 1<br>1 2 5<br>2<br>1 3 3<br>3<br>1 5 2<br>样例输出<br>7<br>数据规模<br>所有数据保证 1≤n≤105，1≤w,t≤106，且保证输入合法。</p>
<p>模拟。</p>
<p>#include<iostream><br>#include<vector><br>#include<algorithm><br>#define ll long long<br>using namespace std;<br>const int N&#x3D;100001;<br>struct dd<br>{<br>    ll w;<br>    ll t;<br>};<br>bool temp_w(dd x,dd y)    &#x2F;&#x2F;按w升序<br>{<br>    return x.w&lt;y.w;<br>}<br>bool temp_t(dd x,dd y)    &#x2F;&#x2F;按t升序<br>{<br>    return x.t&lt;y.t;<br>}<br>int main()<br>{<br>    std::ios::sync_with_stdio(false);<br>    cin.tie(0);<br>    cout.tie(0);<br>    int n;<br>    ll res&#x3D;0;<br>    vector<dd>a;<br>    cin&gt;&gt;n;<br>    while(n–)<br>    {<br>        int op;<br>        int w,t;<br>        cin&gt;&gt;op;<br>        if(op&#x3D;&#x3D;1)<br>        {<br>            cin&gt;&gt;w&gt;&gt;t;<br>            dd x&#x3D;{w,t};<br>            int flag&#x3D;0;<br>            for(int i&#x3D;0;i&lt;a.size();i++)<br>            {<br>                if(a[i].w&#x3D;&#x3D;w||a[i].t&#x3D;&#x3D;t)<br>                {<br>                    flag&#x3D;1;<br>                    break;<br>                }<br>            }<br>            if(flag&#x3D;&#x3D;0)a.push_back(x);<br>        }<br>        else if(op&#x3D;&#x3D;2)<br>        {<br>            sort(a.begin(),a.begin()+a.size(),temp_w);&#x2F;&#x2F;按价格升序后再删掉价格最小的第一个元素<br>            a.erase(a.begin());<br>        }<br>        else if(op&#x3D;&#x3D;3)<br>        {<br>            sort(a.begin(),a.begin()+a.size(),temp_t);&#x2F;&#x2F;按口感升序后再删掉口感最小的第一个元素<br>            a.erase(a.begin());<br>        }<br>    }<br>    for(int i&#x3D;0;i&lt;a.size();i++)res+&#x3D;a[i].w;<br>    cout&lt;&lt;res;<br>    return 0;</p>
<p>}</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>50<br>51<br>52<br>53<br>54<br>55<br>56<br>57<br>58<br>59<br>60<br>61<br>62<br>63<br>64<br>65<br>5、锦标赛<br>题目描述<br>有n个玩家参加比赛，他们分别有能力值a1,a2,…,an。需要进行n−1轮比赛，每一轮在剩下的玩家里任选两个玩家i,j。如果|ai−aj|&gt;K，那么其中能力值高的玩家会获胜，能力值低的玩家会被淘汰。如果|ai−aj|≤K，那么两个玩家都有可能获胜，另一个玩家被淘汰。</p>
<p>n−1轮比赛之后，只剩下一个玩家。问有多少个玩家可能是最后获胜的玩家。</p>
<p>输入格式<br>第一行，两个整数n,K，表示玩家的总人数，和获胜条件中的参数。</p>
<p>接下来一行n个整数a1,a2,…,an，表示玩家的能力值。</p>
<p>输出格式<br>一个整数，表示最后可能获胜的玩家个数。</p>
<p>样例输入1<br>5 3<br>1 5 9 6 3<br>样例输出1<br>5</p>
<p>数据规模<br>共10组数据。</p>
<p>测试点1<br>满足n≤5。</p>
<p>测试点2<br>满足n≤10。</p>
<p>测试点3,4,5<br>满足n≤1000。</p>
<p>对于100%的数据，满足n≤105,1≤ai,K≤109。</p>
<p>#include<iostream><br>#include<algorithm><br>#include<cmath><br>#define ll long long<br>using namespace std;<br>int main()<br>{<br>    std::ios::sync_with_stdio(false);<br>    cin.tie(0);<br>    cout.tie(0);<br>    int n;<br>    int flag&#x3D;0;<br>    ll k;<br>    ll a[100001];<br>    cin&gt;&gt;n&gt;&gt;k;<br>    for(int i&#x3D;1;i&lt;&#x3D;n;i++)<br>    {<br>        cin&gt;&gt;a[i];<br>    }<br>    sort(a+1,a+1+n);<br>    for(int i&#x3D;1;i&lt;n;i++)<br>    {<br>        if(abs(a[i]-a[i+1])&gt;k)flag&#x3D;i;<br>    }<br>    cout&lt;&lt;n-flag;<br>    return 0;</p>
<p>}</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>6、可重排列<br>题目描述<br>请按字典序从小到大的顺序输出所有序列，满足序列中有 p1 个 1, p2 个 2, …, pn 个 n。</p>
<p>输入格式<br>第一行一个整数 n。</p>
<p>第二行 n 个整数 p1,p2,…,pn。</p>
<p>输出格式<br>按字典序从小到大的顺序一行一行输出所有满足条件的序列，每行一个序列，相邻两个数字需要用空格隔开。</p>
<p>样例输入<br>3<br>1 2 2<br>样例输出<br>1 2 2 3 3<br>1 2 3 2 3<br>1 2 3 3 2<br>1 3 2 2 3<br>1 3 2 3 2<br>1 3 3 2 2<br>2 1 2 3 3<br>2 1 3 2 3<br>2 1 3 3 2<br>2 2 1 3 3<br>2 2 3 1 3<br>2 2 3 3 1<br>2 3 1 2 3<br>2 3 1 3 2<br>2 3 2 1 3<br>2 3 2 3 1<br>2 3 3 1 2<br>2 3 3 2 1<br>3 1 2 2 3<br>3 1 2 3 2<br>3 1 3 2 2<br>3 2 1 2 3<br>3 2 1 3 2<br>3 2 2 1 3<br>3 2 2 3 1<br>3 2 3 1 2<br>3 2 3 2 1<br>3 3 1 2 2<br>3 3 2 1 2<br>3 3 2 2 1<br>数据规模<br>对于 100% 的数据，保证 1≤n≤9,1≤pi≤9，保证满足条件的序列个数不超过 105 个。</p>
<p>#include<iostream><br>using namespace std;<br>int n;<br>long long sum&#x3D;0;<br>const int N1&#x3D;10;<br>const int N2&#x3D;90;<br>int a[N1],b[N2];<br>void dfs(int i)<br>{<br>    if(i&#x3D;&#x3D;sum+1)    &#x2F;&#x2F;已经选完一行的数了就开始输出，然后再重新选<br>    {<br>        for(int j&#x3D;1;j&lt;&#x3D;sum;j++)<br>        {<br>            cout&lt;&lt;b[j]&lt;&lt;’ ‘;<br>        }<br>        cout&lt;&lt;’\n’;<br>    }<br>    for(int j&#x3D;1;j&lt;&#x3D;n;j++)<br>    {<br>        if(a[j])        &#x2F;&#x2F;如果j还没选完就选一个j<br>        {<br>            b[i]&#x3D;j;<br>            a[j]–;        &#x2F;&#x2F;已选了一个j<br>            dfs(i+1);    &#x2F;&#x2F;继续选下一个数<br>            a[j]++;<br>        }<br>    }</p>
<p>}<br>int main()<br>{<br>    std::ios::sync_with_stdio(false);<br>    cin.tie(0);<br>    cout.tie(0);<br>    cin&gt;&gt;n;<br>    for(int i&#x3D;1;i&lt;&#x3D;n;i++)<br>    {<br>        cin&gt;&gt;a[i];    &#x2F;&#x2F;有a[i]个i<br>        sum+&#x3D;a[i];    &#x2F;&#x2F;sum表示输出中一行有多少个数<br>    }<br>    dfs(1);<br>    return 0;</p>
<p>}</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>7、进制转换<br>题目描述<br>让我看看是谁不会进制转换，哦原来是我</p>
<p>以不同进制的形式输入 n 个非负整数，求出它们的和并以 m 进制的形式输出。</p>
<p>使用大写字母 A ~ Z 依次代表 10 ~ 35， 小写字母 a ~ z 依次代表 36 ~ 61。</p>
<p>输入格式<br>第一行输入两个整数 1≤n≤10 ， 2≤m≤62 。</p>
<p>接下来 n 行，每行输入一个整数 2≤t≤62， 一个 t进制数 0≤x≤109。</p>
<p>输出格式<br>一个 m 进制数，为最终的结果</p>
<p>输入样例1<br>2 2<br>2 1<br>6 10<br>输出样例1<br>111<br>输入样例2<br>1 10<br>52 aA0<br>输出样例2<br>97864<br>输入样例3<br>2 52<br>36 AMD<br>52 YES<br>输出样例3<br>dJD</p>
<p>#include<iostream><br>#include<cstring><br>#include<cmath><br>#define ll long long<br>using namespace std;<br>const int N&#x3D;100001;<br>int main()<br>{<br>    std::ios::sync_with_stdio(false);<br>    cin.tie(0);<br>    cout.tie(0);<br>    int n,m;<br>    ll sum&#x3D;0;<br>    char a[N];<br>    char res[N];<br>    int r&#x3D;0;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    for(int i&#x3D;1;i&lt;&#x3D;n;i++)        &#x2F;&#x2F;均转化为10进制并相加<br>    {<br>        int t;<br>        cin&gt;&gt;t&gt;&gt;a;<br>        int len&#x3D;strlen(a);<br>        for(int j&#x3D;len-1,k&#x3D;0;j&gt;&#x3D;0;j–,k++)<br>        {<br>            int num;<br>            if(a[j]&gt;&#x3D;’0’&amp;&amp;a[j]&lt;&#x3D;’9’)num&#x3D;a[j]-‘0’;<br>            else if(a[j]&gt;&#x3D;’A’&amp;&amp;a[j]&lt;&#x3D;’Z’)num&#x3D;a[j]-‘A’+10;<br>            else num&#x3D;a[j]-‘a’+36;<br>            sum+&#x3D;num*pow(t,k);<br>        }<br>    }<br>    while(sum&gt;0)<br>    {<br>        int num&#x3D;sum%m;            &#x2F;&#x2F;辗转除m<br>        if(num&gt;&#x3D;0&amp;&amp;num&lt;&#x3D;9)res[r]&#x3D;’0’+num;<br>        else if(num&gt;&#x3D;10&amp;&amp;num&lt;&#x3D;35)res[r]&#x3D;’A’+num-10;<br>        else res[r]&#x3D;’a’+num-36;<br>        sum&#x2F;&#x3D;m;<br>        r++;<br>    }</p>
<pre><code>for(int k=r-1;k&gt;=0;k--)cout&lt;&lt;res[k];    //倒序输出
return 0;
</code></pre>
<p>}</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>8、循环子串<br>题目描述<br>一个字符串S是另一字符串T的循环子串当且仅当存在k, T所有字符循环右移k位后得到的新串T′，满足S是T′的子串。</p>
<p>例如: abc 是 cefab的循环子串。 (cefab循环右移2位得到abcef, abc是abcef的子串)</p>
<p>一个串P是完全循环串当且仅当对于它的任一子串H, 都有Hreverse是P的循环子串 (Hreverse 为 H的倒转, 如abc reverse后 为cba)。</p>
<p>给一个长度为n的字符串, 判断它是不是完全循环串。</p>
<p>输入格式<br>第一行一个正整数t, 表示测试数据组数。</p>
<p>对于每一组数据，第一行一个正整数n, 表示字符串的长度。接下来一行一个长度为n的字符串. 仅包含小写字母。</p>
<p>输出格式<br>对于每组测试数据，如果这个串是完全循环串, 输出YES，否则输出NO。每组测试数据之间输出换行。</p>
<p>数据范围<br>对于所有数据 有 1≤t≤100, 1≤n≤103, ∑n≤103。</p>
<p>样例输入<br>2<br>4<br>ccca<br>11<br>eeaafbddfaa<br>样例输出<br>YES<br>NO<br>提示 选中可以查看</p>
<p>本道题目只需要语法知识就可以解决。</p>
<p>任意子串是什么意思呢？</p>
<p>如果一个子串包含另一个子串，那么我们是不是只需要求出大子串的合法情况，就可以推出小子串的合法情况。</p>
<p>从大的子串向小的子串考虑 最大的子串是什么呢？</p>
<p>#include<iostream><br>#include<algorithm><br>using namespace std;<br>bool check(string s,int n)<br>{<br>    string s1&#x3D;s;<br>    string s2&#x3D;s+s;<br>    reverse(s1.begin(),s1.end());&#x2F;&#x2F;即判断s1是否为s2的子串<br>    int k&#x3D;s2.find(s1,0);<br>    if(k&gt;&#x3D;0)return 1;<br>    else return 0;<br>}<br>int main()<br>{<br>    std::ios::sync_with_stdio(false);<br>    cin.tie(0);<br>    cout.tie(0);<br>    int t;<br>    cin&gt;&gt;t;<br>    while(t–)<br>    {<br>        int n;<br>        string s;<br>        cin&gt;&gt;n&gt;&gt;s;<br>        if(check(s,n))cout&lt;&lt;”YES”&lt;&lt;’\n’;<br>        else cout&lt;&lt;”NO”&lt;&lt;’\n’;<br>    }<br>    return 0;</p>
<p>}</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>9、饿饿 饭饭之暑假大狂欢<br>题目描述<br>故事接着《饿饿 饭饭 2》，又过了几个月，暑假来啦！！！</p>
<p>这天，cc和他的小伙伴们决定一起去游乐园玩，他们一天将游乐园的所有设施玩了个遍，甚至大摆锤，过山车他们还去了很多次，愉快的时间总是很短暂的，很快时间就来到了晚上，但是你以为一天的娱乐时光就这样结束了吗，那你就猜错啦。</p>
<p>晚上，游乐园晚上的party就开始啦，其中有一个游戏环节，赢的人可以得到免费的西瓜，饿到不行的cc和他的小伙伴非常希望得到这个西瓜。</p>
<p>包括cc和他的小伙伴，有t个玩家参与了这个游戏，每个玩家都有一张带有数字的卡片。第i张卡片上有ni个数字，分别是m1,m2,…mn。</p>
<p>游戏过程中，主持人从袋子里一个一个地取出编号的球。 他用洪亮而清晰的声音大声念出球的编号，然后把球收起来。 如果玩家的卡片上有对应的数字，就可以将它划掉。 最先从他的卡片上划掉所有数字的人获胜。 如果多人同时从他们的卡片上划掉所有数字，那么这些人都不能赢得比赛。 在游戏开始时，袋子里有 100 个球，编号从 1 到 100，所有球的编号都是不同的。</p>
<p>cc偷偷知道了每个玩家的数字。 想请你确定每个玩家是否可以在最有利于他的情况下赢得比赛。</p>
<p>输入格式<br>第一行给出一个数t，代表t个玩家。</p>
<p>接下来第二行到t+1行，每行第一个数为ni，代表这个人手中有n个卡片，接下来给出序列a1…an表示这个人所拥有的卡片的数字。</p>
<p>输出格式<br>输出t行，每一行给出第i个人在最有利的情况下是否能赢得比赛，可以输出YES, 不可以输出NO。</p>
<p>数据范围<br>1≤t≤100,1≤n≤100,1≤mi≤100<br>样例输入<br>3<br>1 1<br>3 2 4 1<br>2 10 11<br>样例输出<br>YES<br>NO<br>YES</p>
<p>。</p>
<p>#include<iostream><br>#include<vector><br>#include<algorithm><br>using namespace std;<br>int main()<br>{<br>    std::ios::sync_with_stdio(false);<br>    cin.tie(0);<br>    cout.tie(0);<br>    int t;<br>    bool ans[101]&#x3D;{false};<br>    vector&lt;vector<int> &gt;a(101);<br>    cin&gt;&gt;t;<br>    for(int i&#x3D;1;i&lt;&#x3D;t;i++)<br>    {<br>        int len;<br>        cin&gt;&gt;len;<br>        for(int j&#x3D;1;j&lt;&#x3D;len;j++)<br>        {<br>            int x;<br>            cin&gt;&gt;x;<br>            a[i].push_back(x);<br>        }<br>    }<br>    for(int i&#x3D;1;i&lt;&#x3D;t;i++)<br>    {<br>        bool flag1&#x3D;0;        &#x2F;&#x2F;判断是否进入过以下循环<br>        for(int j&#x3D;1;j&lt;&#x3D;t;j++)&#x2F;&#x2F;遍历所有的序列,判断序列a[j]是不是a[i]的子序列<br>        {<br>            if(j&#x3D;&#x3D;i||a[j].size()&gt;a[i].size())continue;<br>            bool flag&#x3D;0;&#x2F;&#x2F;若是子序列,则flag&#x3D;0<br>            for(int k&#x3D;0;k&lt;a[j].size();k++)&#x2F;&#x2F;判断a[j]中的每一个元素是否都能在a[i]中找到<br>            {<br>                if(find(a[i].begin(),a[i].end(),a[j][k])&#x3D;&#x3D;a[i].end())&#x2F;&#x2F;有一个元素没找到(则一定不是子序列)<br>                {<br>                    flag&#x3D;1;<br>                    flag1&#x3D;1;<br>                    break;<br>                }<br>            }<br>            if(flag&#x3D;&#x3D;0)    &#x2F;&#x2F;是子序列<br>            {<br>                flag1&#x3D;1;<br>                ans[i]&#x3D;false;<br>                break;<br>            }<br>            else<br>            {<br>                flag1&#x3D;1;<br>                ans[i]&#x3D;true;<br>            }<br>        }<br>        if(flag1&#x3D;&#x3D;0)ans[i]&#x3D;true;<br>    }<br>    for(int i&#x3D;1;i&lt;&#x3D;t;i++)<br>        if(ans[i]&#x3D;&#x3D;true)<br>            cout&lt;&lt;”YES”&lt;&lt;’\n’;<br>        else<br>            cout&lt;&lt;”NO”&lt;&lt;’\n’;<br>    return 0;</p>
<p>}</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>50<br>51<br>52<br>53<br>54<br>55<br>56<br>57<br>58<br>59<br>60<br>61<br>62<br>63<br>64<br>10、RSA<br>题目描述<br>RSA算法选择两个不同质数的积作为模数。现在有两个正整数 A,B，如果它们是不同的质数，则判定为 full credit；否则，如果A⋅B不是任意大于1的整数的平方的整数倍，则判定 partial credit；否则判定为no credit。</p>
<p>输入格式<br>一行两个正整数 A,B<br>。</p>
<p>输出格式<br>full credit 或 partial credit 或 no credit。</p>
<p>样例1输入<br>13 23<br>样例1输出<br>full credit<br>样例2输入<br>3 3<br>样例2输出<br>no credit<br>数据规模<br>所有数据保证 2≤A,B≤1012。</p>
<p>！<br>#include<iostream><br>#include<cmath><br>#include<map><br>using namespace std;<br>bool isprime(long long x)    &#x2F;&#x2F;判断是不是质数<br>{<br>    if(x&#x3D;&#x3D;1)return 0;<br>    for(int i&#x3D;2;i&lt;&#x3D;sqrt(x);i++)<br>    {<br>        if(x%i&#x3D;&#x3D;0)return 0;<br>    }<br>    return 1;<br>}<br>bool flag&#x3D;0;<br>map&lt;long long,int&gt;mymap;<br>bool check(long long a)<br>{<br>    for(int i&#x3D;2;i&lt;&#x3D;sqrt(a);i++)<br>    {<br>        if(a%i&#x3D;&#x3D;0)<br>        {<br>            mymap[i]++;<br>            mymap[a&#x2F;i]++;<br>            if(mymap[i]&gt;&#x3D;2||mymap[a&#x2F;i]&gt;&#x3D;2)<br>            {<br>                flag&#x3D;1;        &#x2F;&#x2F;标记是否有重复的因数出现<br>                return 1;<br>            }<br>        }<br>    }<br>}<br>int main()<br>{<br>    std::ios::sync_with_stdio(false);<br>    cin.tie(0);<br>    cout.tie(0);<br>    long long a,b;<br>    cin&gt;&gt;a&gt;&gt;b;<br>    if(a&#x3D;&#x3D;b)    &#x2F;&#x2F;相等则A<em>B就是一个平方数<br>    {<br>        cout&lt;&lt;”no credit”;<br>        return 0;<br>    }<br>    if(isprime(a)&amp;&amp;isprime(b))<br>    {<br>        cout&lt;&lt;”full credit”;<br>        return 0;<br>    }<br>    check(a);<br>    check(b);<br>    if(flag&#x3D;&#x3D;1)&#x2F;&#x2F;a</em>b是任意大于1的整数的平方的整数倍<br>    {<br>        cout&lt;&lt;”no credit”;<br>    }<br>    else<br>    {<br>        cout&lt;&lt;”partial credit”;<br>    }<br>    return 0;</p>
<p>}</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/05/13/week15/" data-id="clhle0zp40000a4w12990blxh" data-title="week15" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-双周赛一" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/04/01/%E5%8F%8C%E5%91%A8%E8%B5%9B%E4%B8%80/" class="article-date">
  <time class="dt-published" datetime="2023-04-01T06:57:04.000Z" itemprop="datePublished">2023-04-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/04/01/%E5%8F%8C%E5%91%A8%E8%B5%9B%E4%B8%80/">双周赛一</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>7-1 重要的话说三遍</p>
<p>分数 5</p>
<p>全屏浏览题目</p>
<p>切换布局</p>
<p>作者 陈越</p>
<p>单位 浙江大学</p>
<p>这道超级简单的题目没有任何输入。</p>
<p>你只需要把这句很重要的话 —— “I’m gonna WIN!”——连续输出三遍就可以了。</p>
<p>注意每遍占一行，除了每行的回车不能有任何多余字符。</p>
<p>代码长度限制</p>
<p>16 KB</p>
<p>时间限制</p>
<p>400 ms</p>
<p>内存限制</p>
<p>64 MB</p>
<p>#include <iostream><br>using namespace std;<br>int main(){<br>    cout&lt;&lt;”I’m gonna WIN!”&lt;&lt;endl;<br>    cout&lt;&lt;”I’m gonna WIN!”&lt;&lt;endl;<br>    cout&lt;&lt;”I’m gonna WIN!”;</p>
<p>}</p>
<p>7-2 日期格式化</p>
<p>分数 5</p>
<p>全屏浏览题目</p>
<p>切换布局</p>
<p>作者 陈越</p>
<p>单位 浙江大学</p>
<p>世界上不同国家有不同的写日期的习惯。比如美国人习惯写成“月-日-年”，而中国人习惯写成“年-月-日”。下面请你写个程序，自动把读入的美国格式的日期改写成中国习惯的日期。</p>
<h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在一行中按照“mm-dd-yyyy”的格式给出月、日、年。题目保证给出的日期是1900年元旦至今合法的日期。</p>
<h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>在一行中按照“yyyy-mm-dd”的格式给出年、月、日。</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><pre><code>03-15-2017
</code></pre>
<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><pre><code>2017-03-15
</code></pre>
<p>代码长度限制</p>
<p>16 KB</p>
<p>时间限制</p>
<p>400 ms</p>
<p>内存限制</p>
<p>64 MB</p>
<p>#include <iostream><br>#include &lt;string.h&gt;<br>using namespace std;<br>int main(){<br>    string a;<br>    cin&gt;&gt;a;<br>    for(int i&#x3D;6;i&lt;10;i++){<br>        cout&lt;&lt;a[i];<br>    }<br>    cout&lt;&lt;”-“;<br>    cout&lt;&lt;a[0]&lt;&lt;a[1]&lt;&lt;a[2]&lt;&lt;a[3]&lt;&lt;a[4];</p>
<p>}</p>
<p>7-3 大笨钟</p>
<p>分数 10</p>
<p>全屏浏览题目</p>
<p>切换布局</p>
<p>作者 陈越</p>
<p>单位 浙江大学</p>
<p>微博上有个自称“大笨钟V”的家伙，每天敲钟催促码农们爱惜身体早点睡觉。不过由于笨钟自己作息也不是很规律，所以敲钟并不定时。一般敲钟的点数是根据敲钟时间而定的，如果正好在某个整点敲，那么“当”数就等于那个整点数；如果过了整点，就敲下一个整点数。另外，虽然一天有24小时，钟却是只在后半天敲1~12下。例如在23:00敲钟，就是“当当当当当当当当当当当”，而到了23:01就会是“当当当当当当当当当当当当”。在午夜00:00到中午12:00期间（端点时间包括在内），笨钟是不敲的。</p>
<p>下面就请你写个程序，根据当前时间替大笨钟敲钟。</p>
<h3 id="输入格式：-1"><a href="#输入格式：-1" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入第一行按照<code>hh:mm</code>的格式给出当前时间。其中<code>hh</code>是小时，在00到23之间；<code>mm</code>是分钟，在00到59之间。</p>
<h3 id="输出格式：-1"><a href="#输出格式：-1" class="headerlink" title="输出格式："></a>输出格式：</h3><p>根据当前时间替大笨钟敲钟，即在一行中输出相应数量个<code>Dang</code>。如果不是敲钟期，则输出：<br>    Only hh:mm.  Too early to Dang.</p>
<p>其中<code>hh:mm</code>是输入的时间。</p>
<h3 id="输入样例1："><a href="#输入样例1：" class="headerlink" title="输入样例1："></a>输入样例1：</h3><pre><code>19:05
</code></pre>
<h3 id="输出样例1："><a href="#输出样例1：" class="headerlink" title="输出样例1："></a>输出样例1：</h3><pre><code>DangDangDangDangDangDangDangDang
</code></pre>
<h3 id="输入样例2："><a href="#输入样例2：" class="headerlink" title="输入样例2："></a>输入样例2：</h3><pre><code>07:05
</code></pre>
<h3 id="输出样例2："><a href="#输出样例2：" class="headerlink" title="输出样例2："></a>输出样例2：</h3><pre><code>Only 07:05.  Too early to Dang.
</code></pre>
<p>代码长度限制</p>
<p>16 KB</p>
<p>时间限制</p>
<p>400 ms</p>
<p>内存限制</p>
<p>64 MB</p>
<p>#include <iostream><br>#include &lt;string.h&gt;<br>using namespace std;<br>int main(){<br>    string a;<br>    cin&gt;&gt;a;<br>    if(a[0]&#x3D;&#x3D;’1’&amp;&amp;(a[1]&#x3D;&#x3D;’3’||a[1]&#x3D;&#x3D;’4’||a[1]&#x3D;&#x3D;’5’||a[1]&#x3D;&#x3D;’6’||a[1]&#x3D;&#x3D;’7’||a[1]&#x3D;&#x3D;’8’||a[1]&#x3D;&#x3D;’9’)){<br>    }<br>    if(a&#x3D;&#x3D;”00:00”){cout&lt;&lt;”Only “&lt;&lt;a&lt;&lt;”.  Too early to Dang.”;<br>        return 0;<br>    }<br>    if(a[3]&#x3D;&#x3D;’0’&amp;&amp;a[4]&#x3D;&#x3D;’0’){<br>        if(a[0]&#x3D;&#x3D;’2’&amp;&amp;a[1]&#x3D;&#x3D;’4’)cout&lt;&lt;”Only hh:mm.  Too early to Dang.”;<br>        else if(a[0]&#x3D;&#x3D;’1’&amp;&amp;a[1]&gt;’2’)for(char i&#x3D;’2’;i&lt;a[1];i++){<br>            cout&lt;&lt;”Dang”;<br>        }<br>        else if(a[0]&#x3D;&#x3D;’2’&amp;&amp;a[1]&lt;’4’){<br>            cout&lt;&lt;”DangDangDangDangDangDangDang”;<br>            for(char i&#x3D;’0’;i&lt;&#x3D;a[1];i++){<br>                cout&lt;&lt;”Dang”;<br>            }<br>        }<br>        else cout&lt;&lt;”Only “&lt;&lt;a&lt;&lt;”.  Too early to Dang.”;<br>    }<br>    else if(a[0]&#x3D;&#x3D;’1’&amp;&amp;a[1]&gt;&#x3D;’2’)for(char i&#x3D;’2’;i&lt;&#x3D;a[1];i++){<br>            cout&lt;&lt;”Dang”;<br>        }<br>    else if(a[0]&#x3D;&#x3D;’2’&amp;&amp;a[1]&lt;’4’){<br>            cout&lt;&lt;”DangDangDangDangDangDangDangDang”;<br>            for(char i&#x3D;’0’;i&lt;&#x3D;a[1];i++){<br>                cout&lt;&lt;”Dang”;<br>            }<br>        }<br>    else cout&lt;&lt;”Only “&lt;&lt;a&lt;&lt;”.  Too early to Dang.”;</p>
<p>}</p>
<p>7-4 拯救外星人</p>
<p>分数 10</p>
<p>全屏浏览题目</p>
<p>切换布局</p>
<p>作者 陈越</p>
<p>单位 浙江大学</p>
<p><img src="https://images.ptausercontent.com/6a6a0e8b-dabb-4364-b5c7-f180082ef719.jpg" alt="T.jpg"></p>
<p>你的外星人朋友不认得地球上的加减乘除符号，但是会算阶乘 —— 正整数 N 的阶乘记为 “N!”，是从 1 到 N 的连乘积。所以当他不知道“5+7”等于多少时，如果你告诉他等于“12!”，他就写出了“479001600”这个答案。</p>
<p>本题就请你写程序模仿外星人的行为。</p>
<h3 id="输入格式：-2"><a href="#输入格式：-2" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在一行中给出两个正整数 A 和 B。</p>
<h3 id="输出格式：-2"><a href="#输出格式：-2" class="headerlink" title="输出格式："></a>输出格式：</h3><p>在一行中输出 (A+B) 的阶乘。题目保证 (A+B) 的值小于 12。</p>
<h3 id="输入样例：-1"><a href="#输入样例：-1" class="headerlink" title="输入样例："></a>输入样例：</h3><pre><code>3 6
</code></pre>
<h3 id="输出样例：-1"><a href="#输出样例：-1" class="headerlink" title="输出样例："></a>输出样例：</h3><pre><code>362880
</code></pre>
<p>代码长度限制</p>
<p>16 KB</p>
<p>时间限制</p>
<p>400 ms</p>
<p>内存限制</p>
<p>64 MB</p>
<p>#include <iostream><br>using namespace std;<br>int main(){<br>    int A,B;<br>    cin&gt;&gt;A&gt;&gt;B;<br>    int c&#x3D;A+B;<br>    int ans&#x3D;1;<br>    for(int i&#x3D;c;i&gt;&#x3D;1;i–){<br>        ans&#x3D;ans*i;<br>    }<br>    cout&lt;&lt;ans;</p>
<p>}</p>
<p>7-5 个位数统计</p>
<p>分数 15</p>
<p>全屏浏览题目</p>
<p>切换布局</p>
<p>作者 CHEN, Yue</p>
<p>单位 浙江大学</p>
<p>给定一个 k 位整数 N&#x3D;dk−1​10k−1+⋯+d1​101+d0​ (0≤di​≤9, i&#x3D;0,⋯,k−1, dk−1​&gt;0)，请编写程序统计每种不同的个位数字出现的次数。例如：给定 N&#x3D;100311，则有 2 个 0，3 个 1，和 1 个 3。</p>
<h3 id="输入格式：-3"><a href="#输入格式：-3" class="headerlink" title="输入格式："></a>输入格式：</h3><p>每个输入包含 1 个测试用例，即一个不超过 1000 位的正整数 N。</p>
<h3 id="输出格式：-3"><a href="#输出格式：-3" class="headerlink" title="输出格式："></a>输出格式：</h3><p>对 N 中每一种不同的个位数字，以 <code>D:M</code> 的格式在一行中输出该位数字 <code>D</code> 及其在 N 中出现的次数 <code>M</code>。要求按 <code>D</code> 的升序输出。</p>
<h3 id="输入样例：-2"><a href="#输入样例：-2" class="headerlink" title="输入样例："></a>输入样例：</h3><pre><code>100311
</code></pre>
<h3 id="输出样例：-2"><a href="#输出样例：-2" class="headerlink" title="输出样例："></a>输出样例：</h3><pre><code>0:2
1:3
3:1
</code></pre>
<p>代码长度限制</p>
<p>16 KB</p>
<p>时间限制</p>
<p>400 ms</p>
<p>内存限制</p>
<p>64 MB</p>
<p>#include <iostream><br>#include <string><br>using namespace std;<br>int main(){<br>    string a;<br>    int a0&#x3D;0,a1&#x3D;0,a2&#x3D;0,a3&#x3D;0,a4&#x3D;0,a5&#x3D;0,a6&#x3D;0,a7&#x3D;0,a8&#x3D;0,a9&#x3D;0;<br>    cin&gt;&gt;a;<br>    for(int i&#x3D;0;i&lt;a.length();i++){<br>        if(a[i]&#x3D;&#x3D;’0’)a0++;<br>        else if(a[i]&#x3D;&#x3D;’1’)a1++;<br>        else if(a[i]&#x3D;&#x3D;’2’)a2++;<br>        else if(a[i]&#x3D;&#x3D;’3’)a3++;<br>        else if(a[i]&#x3D;&#x3D;’4’)a4++;<br>        else if(a[i]&#x3D;&#x3D;’5’)a5++;<br>        else if(a[i]&#x3D;&#x3D;’6’)a6++;<br>        else if(a[i]&#x3D;&#x3D;’7’)a7++;<br>        else if(a[i]&#x3D;&#x3D;’8’)a8++;<br>        else if(a[i]&#x3D;&#x3D;’9’)a9++;<br>    }<br>    if(a0!&#x3D;0)cout&lt;&lt;”0:”&lt;&lt;a0&lt;&lt;endl;<br>    if(a1!&#x3D;0)cout&lt;&lt;”1:”&lt;&lt;a1&lt;&lt;endl;<br>    if(a2!&#x3D;0)cout&lt;&lt;”2:”&lt;&lt;a2&lt;&lt;endl;<br>    if(a3!&#x3D;0)cout&lt;&lt;”3:”&lt;&lt;a3&lt;&lt;endl;<br>    if(a4!&#x3D;0)cout&lt;&lt;”4:”&lt;&lt;a4&lt;&lt;endl;<br>    if(a5!&#x3D;0)cout&lt;&lt;”5:”&lt;&lt;a5&lt;&lt;endl;<br>    if(a6!&#x3D;0)cout&lt;&lt;”6:”&lt;&lt;a6&lt;&lt;endl;<br>    if(a7!&#x3D;0)cout&lt;&lt;”7:”&lt;&lt;a7&lt;&lt;endl;<br>    if(a8!&#x3D;0)cout&lt;&lt;”8:”&lt;&lt;a8&lt;&lt;endl;<br>    if(a9!&#x3D;0)cout&lt;&lt;”9:”&lt;&lt;a9;</p>
<p>}</p>
<p>7-6 正整数A+B</p>
<p>分数 15</p>
<p>全屏浏览题目</p>
<p>切换布局</p>
<p>作者 陈越</p>
<p>单位 浙江大学</p>
<p>题的目标很简单，就是求两个正整数<code>A</code>和<code>B</code>的和，其中<code>A</code>和<code>B</code>都在区间[1,1000]。稍微有点麻烦的是，输入并不保证是两个正整数。</p>
<h3 id="输入格式：-4"><a href="#输入格式：-4" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在一行给出<code>A</code>和<code>B</code>，其间以空格分开。问题是<code>A</code>和<code>B</code>不一定是满足要求的正整数，有时候可能是超出范围的数字、负数、带小数点的实数、甚至是一堆乱码。</p>
<p>注意：我们把输入中出现的第1个空格认为是<code>A</code>和<code>B</code>的分隔。题目保证至少存在一个空格，并且<code>B</code>不是一个空字符串。</p>
<h3 id="输出格式：-4"><a href="#输出格式：-4" class="headerlink" title="输出格式："></a>输出格式：</h3><p>如果输入的确是两个正整数，则按格式<code>A + B = 和</code>输出。如果某个输入不合要求，则在相应位置输出<code>?</code>，显然此时和也是<code>?</code>。</p>
<h3 id="输入样例1：-1"><a href="#输入样例1：-1" class="headerlink" title="输入样例1："></a>输入样例1：</h3><pre><code>123 456
</code></pre>
<h3 id="输出样例1：-1"><a href="#输出样例1：-1" class="headerlink" title="输出样例1："></a>输出样例1：</h3><pre><code>123 + 456 = 579
</code></pre>
<h3 id="输入样例2：-1"><a href="#输入样例2：-1" class="headerlink" title="输入样例2："></a>输入样例2：</h3><pre><code>22. 18
</code></pre>
<h3 id="输出样例2：-1"><a href="#输出样例2：-1" class="headerlink" title="输出样例2："></a>输出样例2：</h3><pre><code>? + 18 = ?
</code></pre>
<h3 id="输入样例3："><a href="#输入样例3：" class="headerlink" title="输入样例3："></a>输入样例3：</h3><pre><code>-100 blabla bla...33
</code></pre>
<h3 id="输出样例3："><a href="#输出样例3：" class="headerlink" title="输出样例3："></a>输出样例3：</h3><pre><code>? + ? = ?
</code></pre>
<p>代码长度限制</p>
<p>16 KB</p>
<p>时间限制</p>
<p>400 ms</p>
<p>内存限制</p>
<p>64 MB</p>
<p>#include<iostream><br>using namespace std;<br>&#x2F;&#x2F;123 456<br>&#x2F;*<br>解题思路：<br>每读入一个字符，把它转换成相应的整数，直到结束，然后再参与运算<br>如对于123来说<br>    读入1，就是1<br>    读入2，就是1<em>10+2<br>    读入3，就是（1</em>10+2）*10+3<br>    即前一个数乘10再加上新的数<br>*&#x2F; </p>
<p>int main(){<br>    char s[100];&#x2F;&#x2F;声明一个字符串<br>    bool flagA &#x3D; true , flagB &#x3D;true;&#x2F;&#x2F;标识A B是否满足条件<br>    int A &#x3D; 0 , B &#x3D; 0;<br>    cin.getline(s,100);<br>    int i;<br>    for( i&#x3D;0 ; s[i]!&#x3D;’ ‘;++i);</p>
<pre><code>for( int j=0 ; j&lt; i ;++j )&#123;
    if(s[j] &gt;=&#39;0&#39; &amp;&amp; s[j] &lt;=&#39;9&#39;)&#123;
        A = A * 10 + (s[j]-&#39;0&#39;);
    &#125; else&#123;
        flagA = false; //判断输入的是否是数字，不是记为false，直接退出
        break;
    &#125;
&#125; 
//判断范围，这个一定要做，因为题目中明确说了可能是超过范围的
if(A ==0 || A &gt;1000) flagA = false;
//i是空格位置，往后部分是B,
for( int j=i+1 ; s[j]!=&#39;\0&#39; ;++j )&#123;
    if(s[j] &gt;=&#39;0&#39; &amp;&amp; s[j] &lt;=&#39;9&#39;)&#123;
        B = B * 10 + (s[j]-&#39;0&#39;);
    &#125; else&#123;
        flagB = false; 
        break;
    &#125;
&#125; 
if(B ==0 || B &gt;1000) flagB = false;

if(flagA)&#123;
    if(flagB)&#123;
        printf(&quot;%d + %d = %d&quot;,A,B,A+B);
    &#125;else&#123;
        printf(&quot;%d + ? = ?&quot;,A);
    &#125;
&#125; else&#123;
    if(flagB)&#123;
        printf(&quot;? + %d = ?&quot;,B);
    &#125;else&#123;
        printf(&quot;? + ? = ?&quot;);
    &#125;
&#125;
</code></pre>
<p>}</p>
<p>7-7 打印沙漏</p>
<p>分数 20</p>
<p>全屏浏览题目</p>
<p>切换布局</p>
<p>作者 陈越</p>
<p>单位 浙江大学</p>
<p>本题要求你写个程序把给定的符号打印成沙漏的形状。例如给定17个“*”，要求按下列格式打印<br>    *****<br>     ***<br>      *<br>     ***<br>    *****</p>
<p>所谓“沙漏形状”，是指每行输出奇数个符号；各行符号中心对齐；相邻两行符号数差2；符号数先从大到小顺序递减到1，再从小到大顺序递增；首尾符号数相等。</p>
<p>给定任意N个符号，不一定能正好组成一个沙漏。要求打印出的沙漏能用掉尽可能多的符号。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>输入在一行给出1个正整数N（≤1000）和一个符号，中间以空格分隔。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>首先打印出由给定符号组成的最大的沙漏形状，最后在一行中输出剩下没用掉的符号数。</p>
<h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><pre><code>19 *
</code></pre>
<h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><pre><code>*****
 ***
  *
 ***
*****
2
</code></pre>
<p>代码长度限制</p>
<p>16 KB</p>
<p>时间限制</p>
<p>400 ms</p>
<p>内存限制</p>
<p>64 MB</p>
<p>&#x2F;&#x2F;6 10 14 18 n*4+2</p>
<p>&#x2F;&#x2F;(n*2+4 )*n+1<br>#include <iostream><br>using namespace std;</p>
<p>int main(){<br>    int a[1000];<br>    int key&#x3D;0;<br>    for(int i&#x3D;0;((i*2+4)*i+1)&lt;2000;i++){ &#x2F;&#x2F;值<br>        a[i]&#x3D;((i*2+4)*i+1);<br>        key++;<br>    }<br>    int n;<br>    string f;<br>    cin&gt;&gt;n;<br>    cin&gt;&gt;f;<br>    int le;<br>    int yu;<br>    for(int i&#x3D;0;i&lt;key;i++){<br>        if(n&lt;a[i]){<br>            le&#x3D;i-1;<br>            yu&#x3D;n-a[i-1];<br>            break;<br>        }<br>    }<br>    if(le&#x3D;&#x3D;0){<br>        cout&lt;&lt;f&lt;&lt;endl;<br>        cout&lt;&lt;yu;<br>        return 0;<br>    }<br>    int x&#x3D;(2*le+1);<br>    int ans[x][x];<br>    for(int i&#x3D;0;i&lt;x;i++){<br>        for(int j&#x3D;0;j&lt;x;j++){<br>            ans[i][j]&#x3D;0;<br>        }<br>    }<br>    for(int i&#x3D;0;i&lt;x&#x2F;2;i++){<br>        for(int j&#x3D;i;j&lt;x-i;j++){<br>            ans[i][j]&#x3D;1;<br>        }<br>    }<br>    ans[x&#x2F;2][x&#x2F;2]&#x3D;1;<br>    for(int i&#x3D;x-1;i&gt;x&#x2F;2;i–){<br>        for(int j&#x3D;x-1-i;j&lt;x-(x-1-i);j++){<br>            ans[i][j]&#x3D;1;<br>        }<br>    }<br>    int tt&#x3D;0;<br>    for(int i&#x3D;0;i&lt;x;i++){<br>        for(int j&#x3D;0;j&lt;x;j++){<br>            if(ans[i][j]&#x3D;&#x3D;0&amp;&amp;tt&#x3D;&#x3D;0)cout&lt;&lt;” “;<br>            else if(ans[i][j]&#x3D;&#x3D;0&amp;&amp;tt&#x3D;&#x3D;1)break;<br>            else {cout&lt;&lt;f;tt&#x3D;1;}</p>
<pre><code>    &#125;
    tt=0;
    cout&lt;&lt;endl;
&#125;

cout&lt;&lt;yu;
</code></pre>
<p>}</p>
<p>7-8 机工士姆斯塔迪奥</p>
<p>分数 20</p>
<p>全屏浏览题目</p>
<p>切换布局</p>
<p>作者 DAI, Longao</p>
<p>单位 杭州百腾教育科技有限公司</p>
<p>在 MMORPG《最终幻想14》的副本“乐欲之所瓯博讷修道院”里，BOSS 机工士姆斯塔迪奥将会接受玩家的挑战。</p>
<p>你需要处理这个副本其中的一个机制：N×M 大小的地图被拆分为了 N×M 个 1×1 的格子，BOSS 会选择若干行或&#x2F;及若干列释放技能，玩家不能站在释放技能的方格上，否则就会被击中而失败。</p>
<p>给定 BOSS 所有释放技能的行或列信息，请你计算出最后有多少个格子是安全的。</p>
<h3 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>输入第一行是三个整数 N,M,Q (1≤N×M≤105，0≤Q≤1000)，表示地图为 N 行 M 列大小以及选择的行&#x2F;列数量。</p>
<p>接下来 Q 行，每行两个数 Ti​,Ci​，其中 Ti​&#x3D;0 表示 BOSS 选择的是一整行，Ti​&#x3D;1 表示选择的是一整列，Ci​ 为选择的行号&#x2F;列号。行和列的编号均从 1 开始。</p>
<h3 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>输出一个数，表示安全格子的数量。</p>
<h3 id="输入样例-1"><a href="#输入样例-1" class="headerlink" title="输入样例:"></a>输入样例:</h3><pre><code>5 5 3
0 2
0 4
1 3
</code></pre>
<h3 id="输出样例-1"><a href="#输出样例-1" class="headerlink" title="输出样例:"></a>输出样例:</h3><pre><code>12
</code></pre>
<p>代码长度限制</p>
<p>16 KB</p>
<p>时间限制</p>
<p>400 ms</p>
<p>内存限制</p>
<p>64 MB</p>
<p>#include&lt;stdio.h&gt;<br>int flagr[100001]&#x3D;{0},flagc[100001]&#x3D;{0};<br>int main(){<br>    int n,m,q,Ti,Ci,r&#x3D;0,c&#x3D;0;<br>    scanf(“%d%d%d”,&amp;n,&amp;m,&amp;q);<br>    while(q–){<br>        scanf(“%d%d”,&amp;Ti,&amp;Ci);<br>        if(Ti&#x3D;&#x3D;0&amp;&amp;flagr[Ci]||Ti&#x3D;&#x3D;1&amp;&amp;flagc[Ci])<br>             continue;   &#x2F;&#x2F;如果是之前被攻击的行或者列就直接跳过<br>        if(Ti&#x3D;&#x3D;0){<br>             r++;<br>             flagr[Ci]&#x3D;1;<br>        }<br>        else{<br>            c++;       &#x2F;&#x2F;标记已经被攻击过了<br>            flagc[Ci]&#x3D;1;<br>        }<br>    }<br>    printf(“%d”,m<em>n-r</em>m-c<em>n+r</em>c);<br>}</p>
<p>7-9 排座位</p>
<p>分数 25</p>
<p>全屏浏览题目</p>
<p>切换布局</p>
<p>作者 陈越</p>
<p>单位 浙江大学</p>
<p>布置宴席最微妙的事情，就是给前来参宴的各位宾客安排座位。无论如何，总不能把两个死对头排到同一张宴会桌旁！这个艰巨任务现在就交给你，对任何一对客人，请编写程序告诉主人他们是否能被安排同席。</p>
<h3 id="输入格式：-5"><a href="#输入格式：-5" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入第一行给出3个正整数：<code>N</code>（≤100），即前来参宴的宾客总人数，则这些人从1到<code>N</code>编号；<code>M</code>为已知两两宾客之间的关系数；<code>K</code>为查询的条数。随后<code>M</code>行，每行给出一对宾客之间的关系，格式为：<code>宾客1 宾客2 关系</code>，其中<code>关系</code>为1表示是朋友，-1表示是死对头。注意两个人不可能既是朋友又是敌人。最后<code>K</code>行，每行给出一对需要查询的宾客编号。</p>
<p>这里假设朋友的朋友也是朋友。但敌人的敌人并不一定就是朋友，朋友的敌人也不一定是敌人。只有单纯直接的敌对关系才是绝对不能同席的。</p>
<h3 id="输出格式：-5"><a href="#输出格式：-5" class="headerlink" title="输出格式："></a>输出格式：</h3><p>对每个查询输出一行结果：如果两位宾客之间是朋友，且没有敌对关系，则输出<code>No problem</code>；如果他们之间并不是朋友，但也不敌对，则输出<code>OK</code>；如果他们之间有敌对，然而也有共同的朋友，则输出<code>OK but...</code>；如果他们之间只有敌对关系，则输出<code>No way</code>。</p>
<h3 id="输入样例：-3"><a href="#输入样例：-3" class="headerlink" title="输入样例："></a>输入样例：</h3><pre><code>7 8 4
5 6 1
2 7 -1
1 3 1
3 4 1
6 7 -1
1 2 1
1 4 1
2 3 -1
3 4
5 7
2 3
7 2
</code></pre>
<h3 id="输出样例：-3"><a href="#输出样例：-3" class="headerlink" title="输出样例："></a>输出样例：</h3><pre><code>No problem
OK
OK but...
No way
</code></pre>
<p>代码长度限制</p>
<p>16 KB</p>
<p>时间限制</p>
<p>200 ms</p>
<p>内存限制</p>
<p>64 MB</p>
<p>#include&lt;bits&#x2F;stdc++.h&gt;<br>using namespace std;<br>#define Maxn 120<br>int a[Maxn][Maxn];<br>int n,m,l;<br>int find(int c,int d){<br>  for(int i&#x3D;1;i&lt;&#x3D;n;i++) {<br>    if(a[c][i]&amp;&amp;a[d][i]) return 1;<br>  }<br>  return 0;<br>}<br>int main(){<br>    cin&gt;&gt;n&gt;&gt;m&gt;&gt;l;<br>    memset(a,0,sizeof(a));<br>    int q,w,e;<br>    for(int i&#x3D;1;i&lt;&#x3D;m;i++){<br>        cin&gt;&gt;q&gt;&gt;w&gt;&gt;e;<br>        a[w][q]&#x3D;a[q][w]&#x3D;e;<br>    }<br>    int r,t;<br>    int flag&#x3D;0;<br>    for(int i&#x3D;1;i&lt;&#x3D;l;i++){<br>        cin&gt;&gt;r&gt;&gt;t;<br>        if(a[r][t]&#x3D;&#x3D;1){<br>            cout&lt;&lt;”No problem”&lt;&lt;endl;<br>            continue;<br>        }else if(a[r][t]&#x3D;&#x3D;0){<br>            cout&lt;&lt;”OK”&lt;&lt;endl;<br>        }else if(a[r][t]&#x3D;&#x3D;-1&amp;&amp;find(r,t)){<br>            cout&lt;&lt;”OK but…”&lt;&lt;endl;<br>        }else{<br>            cout&lt;&lt;”No way”&lt;&lt;endl;<br>        }<br>    }<br>    return 0;</p>
<p>} </p>
<p>7-10 名人堂与代金券</p>
<p>分数 25</p>
<p>全屏浏览题目</p>
<p>切换布局</p>
<p>作者 陈越</p>
<p>单位 浙江大学</p>
<p>对于在中国大学MOOC（<a target="_blank" rel="noopener" href="http://www.icourse163.org/">http://www.icourse163.org/</a> ）学习“数据结构”课程的学生，想要获得一张合格证书，总评成绩必须达到 60 分及以上，并且有另加福利：总评分在 [G, 100] 区间内者，可以得到 50 元 PAT 代金券；在 [60, G) 区间内者，可以得到 20 元PAT代金券。全国考点通用，一年有效。同时任课老师还会把总评成绩前 K 名的学生列入课程“名人堂”。本题就请你编写程序，帮助老师列出名人堂的学生，并统计一共发出了面值多少元的 PAT 代金券。</p>
<h3 id="输入格式：-6"><a href="#输入格式：-6" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在第一行给出 3 个整数，分别是 N（不超过 10 000 的正整数，为学生总数）、G（在 (60,100) 区间内的整数，为题面中描述的代金券等级分界线）、K（不超过 100 且不超过 N 的正整数，为进入名人堂的最低名次）。接下来 N 行，每行给出一位学生的账号（长度不超过15位、不带空格的字符串）和总评成绩（区间 [0, 100] 内的整数），其间以空格分隔。题目保证没有重复的账号。</p>
<h3 id="输出格式：-6"><a href="#输出格式：-6" class="headerlink" title="输出格式："></a>输出格式：</h3><p>首先在一行中输出发出的 PAT 代金券的总面值。然后按总评成绩非升序输出进入名人堂的学生的名次、账号和成绩，其间以 1 个空格分隔。需要注意的是：成绩相同的学生享有并列的排名，排名并列时，按账号的字母序升序输出。</p>
<h3 id="输入样例：-4"><a href="#输入样例：-4" class="headerlink" title="输入样例："></a>输入样例：</h3><pre><code>10 80 5
cy@zju.edu.cn 78
cy@pat-edu.com 87
1001@qq.com 65
uh-oh@163.com 96
test@126.com 39
anyone@qq.com 87
zoe@mit.edu 80
jack@ucla.edu 88
bob@cmu.edu 80
ken@163.com 70
</code></pre>
<h3 id="输出样例：-4"><a href="#输出样例：-4" class="headerlink" title="输出样例："></a>输出样例：</h3><pre><code>360
1 uh-oh@163.com 96
2 jack@ucla.edu 88
3 anyone@qq.com 87
3 cy@pat-edu.com 87
5 bob@cmu.edu 80
5 zoe@mit.edu 80
</code></pre>
<p>代码长度限制</p>
<p>16 KB</p>
<p>时间限制</p>
<p>250 ms</p>
<p>内存限制</p>
<p>64 MB</p>
<p>#include<iostream><br>#include<cstdio><br>#include<vector><br>#include<algorithm><br>#include<string><br>using namespace std;<br>&#x2F;&#x2F;测试点2、3 名人堂是全部的人<br>int n,g,k,grade,sum;<br>string a;<br>pair&lt;int,string&gt; v[10010];<br>int state[10010];</p>
<p>bool my_cmp(pair&lt;int,string&gt; a,pair&lt;int,string&gt; b){<br>    if(a.first&#x3D;&#x3D;b.first) return a.second&lt;b.second;<br>    else return a.first&gt;b.first;<br>}</p>
<p>int main(){<br>    cin&gt;&gt;n&gt;&gt;g&gt;&gt;k;<br>    for(int i&#x3D;0;i&lt;n;i++){<br>        cin&gt;&gt;a&gt;&gt;grade;<br>        if(grade&gt;&#x3D;g) sum+&#x3D;50;<br>        else if(grade&gt;&#x3D;60) sum+&#x3D;20;<br>        v[i]&#x3D;{grade,a};<br>    }<br>    sort(v,v+n,my_cmp);<br>    state[0]&#x3D;1;<br>    for(int i&#x3D;1;i&lt;n;i++){<br>        if(v[i].first&#x3D;&#x3D;v[i-1].first) state[i]&#x3D;state[i-1];<br>        else state[i]&#x3D;i+1;<br>    }<br>    cout&lt;&lt;sum&lt;&lt;endl;<br>    for(int i&#x3D;0;state[i]&lt;&#x3D;k&amp;&amp;i&lt;n;i++){<br>        cout&lt;&lt;state[i]&lt;&lt;’ ‘&lt;&lt;v[i].second&lt;&lt;’ ‘&lt;&lt;v[i].first&lt;&lt;endl;<br>    }<br>    system(“pause”);<br>}</p>
<p>7-11 包装机</p>
<p>分数 25</p>
<p>全屏浏览题目</p>
<p>切换布局</p>
<p>作者 陈越</p>
<p>单位 浙江大学</p>
<p>一种自动包装机的结构如图 1 所示。首先机器中有 N 条轨道，放置了一些物品。轨道下面有一个筐。当某条轨道的按钮被按下时，活塞向左推动，将轨道尽头的一件物品推落筐中。当 0 号按钮被按下时，机械手将抓取筐顶部的一件物品，放到流水线上。图 2 显示了顺序按下按钮 3、2、3、0、1、2、0 后包装机的状态。</p>
<p><img src="https://images.ptausercontent.com/40282bd3-1adb-43f9-9db7-6af4ae06d6c3.JPG" alt="图1.JPG"></p>
<p>图1 自动包装机的结构</p>
<p><img src="https://images.ptausercontent.com/0092f601-031c-4b74-a7f1-d26846fe65a1.JPG" alt="图2.JPG"></p>
<p>图 2 顺序按下按钮 3、2、3、0、1、2、0 后包装机的状态</p>
<p>一种特殊情况是，因为筐的容量是有限的，当筐已经满了，但仍然有某条轨道的按钮被按下时，系统应强制启动 0 号键，先从筐里抓出一件物品，再将对应轨道的物品推落。此外，如果轨道已经空了，再按对应的按钮不会发生任何事；同样的，如果筐是空的，按 0 号按钮也不会发生任何事。</p>
<p>现给定一系列按钮操作，请你依次列出流水线上的物品。</p>
<h3 id="输入格式：-7"><a href="#输入格式：-7" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入第一行给出 3 个正整数 N（≤100）、M（≤1000）和 Smax​（≤100），分别为轨道的条数（于是轨道从 1 到 N 编号）、每条轨道初始放置的物品数量、以及筐的最大容量。随后 N 行，每行给出 M 个英文大写字母，表示每条轨道的初始物品摆放。</p>
<p>最后一行给出一系列数字，顺序对应被按下的按钮编号，直到 −1 标志输入结束，这个数字不要处理。数字间以空格分隔。题目保证至少会取出一件物品放在流水线上。</p>
<h3 id="输出格式：-7"><a href="#输出格式：-7" class="headerlink" title="输出格式："></a>输出格式：</h3><p>在一行中顺序输出流水线上的物品，不得有任何空格。</p>
<h3 id="输入样例：-5"><a href="#输入样例：-5" class="headerlink" title="输入样例："></a>输入样例：</h3><pre><code>3 4 4
GPLT
PATA
OMSA
3 2 3 0 1 2 0 2 2 0 -1
</code></pre>
<h3 id="输出样例：-5"><a href="#输出样例：-5" class="headerlink" title="输出样例："></a>输出样例：</h3><pre><code>MATA
</code></pre>
<p>代码长度限制</p>
<p>16 KB</p>
<p>时间限制</p>
<p>400 ms</p>
<p>内存限制</p>
<p>64 MB</p>
<p>#include <iostream><br>#include &lt;bits&#x2F;stdc++.h&gt;<br>#define ll long long<br>using namespace std;<br>const int maxn &#x3D; 105;<br>queue<char> v[maxn]; &#x2F;&#x2F;&#x2F;存储每个轨道上的物品<br>stack<char> s;  &#x2F;&#x2F;&#x2F;筐<br>queue<char> q;  &#x2F;&#x2F;&#x2F;结果输出<br>int main()<br>{<br>    int N,M,S;<br>    int a[1005];<br>    char ch;<br>    cin&gt;&gt;N&gt;&gt;M&gt;&gt;S;<br>    getchar();<br>    for(int i&#x3D;1;i&lt;&#x3D;N;i++){<br>        for(int j&#x3D;0;j&lt;M;j++){<br>            cin&gt;&gt;ch;<br>            v[i].push(ch);<br>            a[i]++;<br>        }<br>        getchar();<br>    }<br>    int x;<br>    while(true){<br>        cin&gt;&gt;x;<br>        if(x&#x3D;&#x3D;-1)break;<br>        if(x&#x3D;&#x3D;0){<br>            if(s.size()&#x3D;&#x3D;0)continue;    &#x2F;&#x2F;如果筐里面的为空就不做任何处理，跳过<br>            else{<br>                q.push(s.top());        &#x2F;&#x2F;否则，弹出栈顶元素，放入流水线上<br>                s.pop();<br>            }<br>        }<br>        if(x&gt;&#x3D;1 &amp;&amp; x&lt;&#x3D;N){<br>            if(v[x].size()&#x3D;&#x3D;0)continue;        &#x2F;&#x2F;如果对应轨道上没有物品了不做任何处理，跳过<br>            else{<br>                if(s.size()&#x3D;&#x3D;S){    &#x2F;&#x2F;如果筐已经满了，就弹出筐顶物品到流水线上，再将物品放入框中<br>                    q.push(s.top());<br>                    s.pop();<br>                }<br>                s.push(v[x].front());<br>                v[x].pop();<br>            }<br>        }<br>    }<br>    &#x2F;*<br>    for(int i&#x3D;0;i&lt;N;i++){<br>        for(int j&#x3D;0;j&lt;M;j++){<br>            cout&lt;&lt;v[i][j];<br>        }<br>    }<br>    *&#x2F;<br>    while(!q.empty()){<br>        cout&lt;&lt;q.front();<br>        q.pop();<br>    }<br>    return 0;<br>}</p>
<p>7-12 愿天下有情人都是失散多年的兄妹</p>
<p>分数 25</p>
<p>全屏浏览题目</p>
<p>切换布局</p>
<p>作者 陈越</p>
<p>单位 浙江大学</p>
<p>呵呵。大家都知道五服以内不得通婚，即两个人最近的共同祖先如果在五代以内（即本人、父母、祖父母、曾祖父母、高祖父母）则不可通婚。本题就请你帮助一对有情人判断一下，他们究竟是否可以成婚？</p>
<h3 id="输入格式：-8"><a href="#输入格式：-8" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入第一行给出一个正整数<code>N</code>（2 ≤ <code>N</code> ≤104），随后<code>N</code>行，每行按以下格式给出一个人的信息：<br>    本人ID 性别 父亲ID 母亲ID</p>
<p>其中<code>ID</code>是5位数字，每人不同；性别<code>M</code>代表男性、<code>F</code>代表女性。如果某人的父亲或母亲已经不可考，则相应的<code>ID</code>位置上标记为<code>-1</code>。</p>
<p>接下来给出一个正整数<code>K</code>，随后<code>K</code>行，每行给出一对有情人的<code>ID</code>，其间以空格分隔。</p>
<p>注意：题目保证两个人是同辈，每人只有一个性别，并且血缘关系网中没有乱伦或隔辈成婚的情况。</p>
<h3 id="输出格式：-8"><a href="#输出格式：-8" class="headerlink" title="输出格式："></a>输出格式：</h3><p>对每一对有情人，判断他们的关系是否可以通婚：如果两人是同性，输出<code>Never Mind</code>；如果是异性并且关系出了五服，输出<code>Yes</code>；如果异性关系未出五服，输出<code>No</code>。</p>
<h3 id="输入样例：-6"><a href="#输入样例：-6" class="headerlink" title="输入样例："></a>输入样例：</h3><pre><code>24
00001 M 01111 -1
00002 F 02222 03333
00003 M 02222 03333
00004 F 04444 03333
00005 M 04444 05555
00006 F 04444 05555
00007 F 06666 07777
00008 M 06666 07777
00009 M 00001 00002
00010 M 00003 00006
00011 F 00005 00007
00012 F 00008 08888
00013 F 00009 00011
00014 M 00010 09999
00015 M 00010 09999
00016 M 10000 00012
00017 F -1 00012
00018 F 11000 00013
00019 F 11100 00018
00020 F 00015 11110
00021 M 11100 00020
00022 M 00016 -1
00023 M 10012 00017
00024 M 00022 10013
9
00021 00024
00019 00024
00011 00012
00022 00018
00001 00004
00013 00016
00017 00015
00019 00021
00010 00011
</code></pre>
<h3 id="输出样例：-6"><a href="#输出样例：-6" class="headerlink" title="输出样例："></a>输出样例：</h3><pre><code>Never Mind
Yes
Never Mind
No
Yes
No
Yes
No
No
</code></pre>
<p><strong>鸣谢用户 徐校波 修正数据！</strong></p>
<p>代码长度限制</p>
<p>16 KB</p>
<p>时间限制</p>
<p>200 ms</p>
<p>内存限制</p>
<p>64 MB</p>
<p>#include&lt;bits&#x2F;stdc++.h&gt;<br>using namespace std;<br>const int maxn&#x3D;1e5+5;<br>int a[maxn],father[maxn],mother[maxn];<br>char sex[maxn];<br>int judge(int x,int y,int num)<br>{<br>    if(x&#x3D;&#x3D;-1 &amp;&amp; y&#x3D;&#x3D;-1)&#x2F;&#x2F;善意的爱护，如果无法考证就算是符合<br>        return 1;<br>    if((mother[x]!&#x3D;-1 &amp;&amp; mother[x]&#x3D;&#x3D;mother[y]) || (father[x]!&#x3D;-1 &amp;&amp; father[x]&#x3D;&#x3D;father[y]))<br>        return 0;&#x2F;&#x2F;父母亲可以考证，且相同，那可是不行的<br>    num++;<br>    if(num&gt;&#x3D;4)&#x2F;&#x2F;超过了五代就牵手成功了，哈哈哈，有情人终成眷属了<br>        return 1;<br>    return judge(mother[x],mother[y],num)&amp;&amp;&#x2F;&#x2F;别激动，判断一下你们的父母是不是近亲<br>           judge(father[x],father[y],num)&amp;&amp;<br>           judge(mother[x],father[y],num)&amp;&amp;&#x2F;&#x2F;判断你的老妈和他的老爸是不是近亲<br>           judge(father[x],mother[y],num);&#x2F;&#x2F;判断你的老爸和他的老妈是不是近亲<br>}<br>int main()<br>{<br>    int n,m;<br>    memset(father,-1,sizeof(father));<br>    memset(mother,-1,sizeof(mother));<br>    scanf(“%d”,&amp;n);<br>    while(n–)<br>    {<br>        int x,f,m;<br>        char ch;<br>        scanf(“%d”,&amp;x);<br>        getchar();<br>        scanf(“%c”,&amp;sex[x]);<br>        scanf(“%d%d”,&amp;f,&amp;m);<br>        father[x]&#x3D;f;sex[f]&#x3D;’M’;&#x2F;&#x2F;注意一下爸妈也是要设置性别哦<br>        mother[x]&#x3D;m;sex[m]&#x3D;’F’;<br>    }<br>    scanf(“%d”,&amp;m);<br>    while(m–)<br>    {<br>        int x,y;<br>        scanf(“%d%d”,&amp;x,&amp;y);<br>        if(sex[x]&#x3D;&#x3D;sex[y])<br>            printf(“Never Mind\n”);<br>        else<br>        {<br>            if(judge(x,y,0))<br>                printf(“Yes\n”);<br>            else<br>                printf(“No\n”);<br>        }<br>    }<br>    return 0;<br>}</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/04/01/%E5%8F%8C%E5%91%A8%E8%B5%9B%E4%B8%80/" data-id="clfxsuq1l000ju4w1elkoanwg" data-title="双周赛一" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-第三周" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/04/01/%E7%AC%AC%E4%B8%89%E5%91%A8/" class="article-date">
  <time class="dt-published" datetime="2023-04-01T06:56:44.000Z" itemprop="datePublished">2023-04-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/04/01/%E7%AC%AC%E4%B8%89%E5%91%A8/">第三周</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/04/01/%E7%AC%AC%E4%B8%89%E5%91%A8/" data-id="clfxsuq1m000mu4w105tl9l5t" data-title="第三周" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-第二周" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/03/27/%E7%AC%AC%E4%BA%8C%E5%91%A8/" class="article-date">
  <time class="dt-published" datetime="2023-03-27T13:19:56.000Z" itemprop="datePublished">2023-03-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/03/27/%E7%AC%AC%E4%BA%8C%E5%91%A8/">第二周</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="路径计数"><a href="#路径计数" class="headerlink" title="路径计数"></a>路径计数</h2><p> <a target="_blank" rel="noopener" href="http://oj.daimayuan.top/download.php?type=problem&id=126">附加文件</a> <a target="_blank" rel="noopener" href="http://oj.daimayuan.top/course/11/problem/126/statistics">统计</a></p>
<ul>
<li> <a target="_blank" rel="noopener" href="http://oj.daimayuan.top/course/11/problem/126#tab-statement">描述</a></li>
<li> <a target="_blank" rel="noopener" href="http://oj.daimayuan.top/course/11/problem/126#tab-submit-answer">提交</a></li>
<li> <a target="_blank" rel="noopener" href="http://oj.daimayuan.top/course/11/problem/126#tab-custom-test">自定义测试</a></li>
</ul>
<p>有一个n×n的网格，有些格子是可以通行的，有些格子是障碍。</p>
<p>一开始你在左上角的位置，你可以每一步往下或者往右走，问有多少种走到右下角的方案。</p>
<p>由于答案很大，输出对109+7取模的结果。</p>
<h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行一个正整数n。</p>
<p>接下来n行，每行n个正整数，1表示可以通行，0表示不能通行。</p>
<h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>一个整数，表示答案。</p>
<h4 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h4><pre><code>3
1 1 1
1 0 1
1 1 1
</code></pre>
<h4 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h4><pre><code>2
</code></pre>
<h4 id="数据规模"><a href="#数据规模" class="headerlink" title="数据规模"></a>数据规模</h4><p>对于100%的数据，保证2≤n≤100，左上角右下角都是可以通行的。<img src="https://cdn.luogu.com.cn/upload/pic/652.png"></p>
<h2 id="Analyse"><a href="#Analyse" class="headerlink" title="Analyse:"></a>Analyse:</h2><p>唯一的问题就是数量实在是太多了</p>
<p>直接写模板的话肯定会超时</p>
<p>那么就需要用到优化了</p>
<p>这里用到的是二进制优化</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h2><pre><code>#include &lt;bits/stdc++.h&gt;
 
using namespace std;
 
typedef pair&lt;int, int&gt; pii;
typedef long long ll;
typedef vector&lt;int&gt; vi;
//#define int long long
#define fir first
#define sec second
#define all(x) (x).begin(), (x).end()
#define sz(x) (int)x.size()
#define rep(i, l, r) for (int i = l; i &lt;= r; ++i)
#define repd(i, l, r) for (int i = l; i &gt;= r; --i)
#define pb push_back
 
 
const int mod=1e9+7;
const int N=1e3+10;
int f[N][N];
int a[N][N];
 
int main() &#123;
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    int n;
    cin&gt;&gt;n;
    rep(i,1,n)
    &#123;
        rep(j,1,n)
        &#123;
            cin&gt;&gt;a[i][j];
        &#125;
    &#125;
    f[1][1]=1;
    rep(i,1,n)
    &#123;
        rep(j,1,n)
        &#123;
            if(i==1&amp;&amp;j==1)continue;
            if(a[i][j]==1)
            &#123;
                f[i][j]=(f[i-1][j]+f[i][j-1])%mod;
            &#125;
        &#125;
    &#125;
    cout&lt;&lt;f[n][n]&lt;&lt;endl;
    return 0;
&#125;
</code></pre>
<h1 id="最大和上升子序列"><a href="#最大和上升子序列" class="headerlink" title="最大和上升子序列"></a>最大和上升子序列</h1><p> <a target="_blank" rel="noopener" href="http://oj.daimayuan.top/download.php?type=problem&id=289">附加文件</a> <a target="_blank" rel="noopener" href="http://oj.daimayuan.top/course/11/problem/289/statistics">统计</a></p>
<ul>
<li> <a target="_blank" rel="noopener" href="http://oj.daimayuan.top/course/11/problem/289#tab-statement">描述</a></li>
<li> <a target="_blank" rel="noopener" href="http://oj.daimayuan.top/course/11/problem/289#tab-submit-answer">提交</a></li>
<li> <a target="_blank" rel="noopener" href="http://oj.daimayuan.top/course/11/problem/289#tab-custom-test">自定义测试</a></li>
</ul>
<p>给定一个长度为 n 的数组 a1,a2,…,an，问其中的和最大的上升子序列。也就是说，我们要找到数组 p1,p2,…,pm，满足 1≤p1&lt;p2&lt;⋯&lt;pm≤n 并且 ap1&lt;ap2&lt;⋯&lt;apm，使得ap1+ap2+⋯+apm最大。</p>
<h4 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行一个数字 n。</p>
<p>接下来一行 n 个整数 a1,a2,…,an。</p>
<h4 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h4><p>一个数，表示答案。</p>
<h4 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入"></a>样例输入</h4><pre><code>6
3 7 4 2 6 8
</code></pre>
<h4 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出"></a>样例输出</h4><pre><code>21
</code></pre>
<h4 id="数据规模-1"><a href="#数据规模-1" class="headerlink" title="数据规模"></a>数据规模</h4><p>所有数据保证 1≤n≤1000,1≤ai≤105。</p>
<p>#include <iostream><br>using namespace std;<br>int main(){<br>    int n;<br>    cin&gt;&gt;n;<br>    int a[10000];<br>    for(int i&#x3D;0;i&lt;n;i++){<br>        cin&gt;&gt;a[i];<br>    }<br>    int p;<br>    int max&#x3D;0;<br>    int sum;<br>    for(int i&#x3D;0;i&lt;n;i++){<br>        sum&#x3D;a[i];<br>        p&#x3D;a[i];<br>        for(int j&#x3D;i+1;j&lt;n;j++){<br>            if(a[j]&gt;p){<br>                sum+&#x3D;a[j];<br>                p&#x3D;a[j];<br>            }<br>        }<br>        if(sum&gt;max)max&#x3D;sum;</p>
<pre><code>&#125;
cout&lt;&lt;max;
</code></pre>
<p>}</p>
<h1 id="加一"><a href="#加一" class="headerlink" title="加一"></a>加一</h1><p> <a target="_blank" rel="noopener" href="http://oj.daimayuan.top/download.php?type=problem&id=498">附加文件</a> <a target="_blank" rel="noopener" href="http://oj.daimayuan.top/course/11/problem/498/statistics">统计</a></p>
<ul>
<li> <a target="_blank" rel="noopener" href="http://oj.daimayuan.top/course/11/problem/498#tab-statement">描述</a></li>
<li> <a target="_blank" rel="noopener" href="http://oj.daimayuan.top/course/11/problem/498#tab-submit-answer">提交</a></li>
<li> <a target="_blank" rel="noopener" href="http://oj.daimayuan.top/course/11/problem/498#tab-custom-test">自定义测试</a></li>
</ul>
<p>给定一个整数 n。你需要对它做 m 次操作。在一次操作中，你要将这个数的每一位 d 替换成 d+1。比如，1912 在进行一次操作后将变成 21023。</p>
<p>请求出整数 n 进行了 m 次操作后的长度。答案可能很大，输出对 109+7 取模后的结果。</p>
<h3 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式"></a>输入格式</h3><p>​ 第一行一个整数 t，表示测试单元的个数。</p>
<p>​ 接下来 t 行，每行有两个整数 n 和 m，表示最初的数字和进行多少次操作。</p>
<h3 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式"></a>输出格式</h3><p>​ 对于每个测试单元输出最终数字的长度，答案对 109+7 取模。</p>
<h3 id="样例输入-2"><a href="#样例输入-2" class="headerlink" title="样例输入"></a>样例输入</h3><pre><code>5
1912 1
5 6
999 1
88 2
12 100
</code></pre>
<h3 id="样例输出-2"><a href="#样例输出-2" class="headerlink" title="样例输出"></a>样例输出</h3><pre><code>5
2
6
4
2115
</code></pre>
<h3 id="数据规模-2"><a href="#数据规模-2" class="headerlink" title="数据规模"></a>数据规模</h3><p>​ 所有数据保证 1≤t≤2⋅105，1≤n≤109，1≤m≤2⋅105。</p>
<p>#include&lt;bits&#x2F;stdc++.h&gt;<br>#include<iostream><br>using namespace std;<br>#include<vector><br>#include<algorithm><br>#include&lt;math.h&gt;<br>#include<set><br>#include<numeric><br>#include<string><br>#include<map><br>#include<unordered_map><br>#include<stack></p>
<p>typedef long long ll;<br>typedef pair&lt;int, int&gt;PII;<br>const int MOD &#x3D; 1e9 + 7;<br>const int N &#x3D; 200010;<br>ll f[N+50][10];</p>
<p>int main()<br>{<br>    int n;<br>    scanf(“%d”, &amp;n);<br>    for (int i &#x3D; 0; i &lt;&#x3D; 9; i++)f[0][i] &#x3D; 1;<br>    for (int i &#x3D; 1; i &lt;&#x3D; N; i++)<br>    {<br>        for (int j &#x3D; 1; j &lt;&#x3D; 9; j++)f[i][j - 1] &#x3D; f[i-1][j];<br>        f[i][9] &#x3D; (f[i-1][1] + f[i-1][0]) % MOD;<br>    }<br>    while (n–)<br>    {<br>        char str[20];<br>        int m, res &#x3D; 0;<br>        scanf(“%s %d”, &amp;str, &amp;m);<br>        int len &#x3D; strlen(str);<br>        for (int i &#x3D; 0; i &lt; len; i++)<br>        {<br>            res +&#x3D; f[m][str[i] - ‘0’];<br>            res %&#x3D; MOD;<br>        }<br>        cout &lt;&lt; res &lt;&lt; “\n”;<br>    }<br>    return 0;<br>}</p>
<h1 id="跳跳"><a href="#跳跳" class="headerlink" title="跳跳"></a>跳跳</h1><p> <a target="_blank" rel="noopener" href="http://oj.daimayuan.top/download.php?type=problem&id=496">附加文件</a> <a target="_blank" rel="noopener" href="http://oj.daimayuan.top/course/11/problem/496/statistics">统计</a></p>
<ul>
<li> <a target="_blank" rel="noopener" href="http://oj.daimayuan.top/course/11/problem/496#tab-statement">描述</a></li>
<li> <a target="_blank" rel="noopener" href="http://oj.daimayuan.top/course/11/problem/496#tab-submit-answer">提交</a></li>
<li> <a target="_blank" rel="noopener" href="http://oj.daimayuan.top/course/11/problem/496#tab-custom-test">自定义测试</a></li>
</ul>
<p>平面上给定了一些<strong>整点</strong>（横纵坐标均为整数的点），被称为 “魔法阵”。魔法少女派派想要在各魔法阵之间传送，每一次传送，她将使用下面的方式：</p>
<ol>
<li>刚开始，派派已经位于某传送阵之上；</li>
<li>如果派派掌握一种魔法 (A,B)，其中 A,B 均为整数。使用一次这个魔法可以让派派从任意整点 (X,Y) 瞬间移动至 (X+A,Y+B)；</li>
<li>选择一种魔法并开始传送，<strong>在一次传送过程中可以使用多次该魔法，但在抵达下一个传送阵之前仅能使用这一种魔法</strong>。</li>
</ol>
<p>问派派<strong>至少</strong>需要掌握多少种魔法，才能在从任意魔法阵直接传送到任意魔法阵？</p>
<h4 id="输入格式-3"><a href="#输入格式-3" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行一个整数 N。</p>
<p>接下来一行 N 行，每行包含两个整数 Xi,Yi， 表示每个魔法阵的坐标。</p>
<h4 id="输出格式-3"><a href="#输出格式-3" class="headerlink" title="输出格式"></a>输出格式</h4><p>一个数，表示答案。</p>
<h4 id="样例1输入"><a href="#样例1输入" class="headerlink" title="样例1输入"></a>样例1输入</h4><pre><code>3
1 1
4 5
1 4
</code></pre>
<h4 id="样例1输出"><a href="#样例1输出" class="headerlink" title="样例1输出"></a>样例1输出</h4><pre><code>6
</code></pre>
<p>解释： 任务是从 (1,1) 传送至 (4,5) 以及 (1,4) 、从 (4,5) 传送至 (1,1) 以及 (1,4) 、从 (1,4) 传送至 (1,1) 以及 (4,5) 。</p>
<p>注意你不能使用 (0,3)+(3,1) 的魔法从 (1,1) 到达 (4,5)。因为每次移动，你只能使用一种魔法。</p>
<p>当然，你可以学习 (0,1)，那样的话，从 (1,1) 到达 (1,4) 则需要使用 3 次 (0,1) 魔法了。</p>
<h4 id="样例2输入"><a href="#样例2输入" class="headerlink" title="样例2输入"></a>样例2输入</h4><pre><code>3
1 1
2 2
1000000000 1000000000
</code></pre>
<h4 id="样例2输出"><a href="#样例2输出" class="headerlink" title="样例2输出"></a>样例2输出</h4><pre><code>2
</code></pre>
<h4 id="数据规模-3"><a href="#数据规模-3" class="headerlink" title="数据规模"></a>数据规模</h4><ul>
<li>N∈[10,500]</li>
<li>Xi,Yi∈[0,109], 但保证坐标之间<strong>两两不同</strong>。</li>
</ul>
<p>#include <iostream><br>#include <set><br>#include <algorithm><br>typedef long long ll;<br>using namespace std;<br>struct magic{<br>    ll x;<br>    ll y;<br>};<br>&#x2F;&#x2F;化为最简<br>&#x2F;&#x2F;欧几里得gcd</p>
<p>ll gcd(ll a,ll b){<br>    ll t;<br>    while(b!&#x3D;0){<br>        t&#x3D;a%b;<br>        a&#x3D;b;<br>        b&#x3D;t;<br>    }<br>    return a;</p>
<p>}</p>
<p>set&lt;pair&lt;ll,ll&gt;&gt;ans;</p>
<p>int main(){<br>    int n;<br>    cin&gt;&gt;n;<br>    magic m[n];<br>    for(int i&#x3D;0;i&lt;n;i++){<br>        cin&gt;&gt;m[i].x&gt;&gt;m[i].y;<br>    }<br>    ll sx,sy;<br>    ll t;<br>    for(int i&#x3D;0;i&lt;n-1;i++){<br>        for(int j&#x3D;i+1;j&lt;n;j++){<br>            sx&#x3D;m[i].x-m[j].x;<br>            sy&#x3D;m[i].y-m[j].y;<br>            if(sx &amp;&amp; sy){<br>                if(sx<em>sy&lt;0){<br>                    sx&#x3D;abs(sx);<br>                    sy&#x3D;abs(sy)</em>-1;<br>                }<br>                t&#x3D;gcd(sx,-1*sy);</p>
<pre><code>        &#125;
        else if(sx)&#123;
            t=sx;
        &#125;
        else t=sy;
        ans.insert(pair&lt;ll,ll&gt;(sx/t,sy/t));


    &#125;


&#125;
cout&lt;&lt;ans.size()*2;
</code></pre>
<p>}</p>
<h1 id="异或和或"><a href="#异或和或" class="headerlink" title="异或和或"></a>异或和或</h1><p> <a target="_blank" rel="noopener" href="http://oj.daimayuan.top/download.php?type=problem&id=500">附加文件</a> <a target="_blank" rel="noopener" href="http://oj.daimayuan.top/course/11/problem/500/statistics">统计</a></p>
<ul>
<li> <a target="_blank" rel="noopener" href="http://oj.daimayuan.top/course/11/problem/500#tab-statement">描述</a></li>
<li> <a target="_blank" rel="noopener" href="http://oj.daimayuan.top/course/11/problem/500#tab-submit-answer">提交</a></li>
<li> <a target="_blank" rel="noopener" href="http://oj.daimayuan.top/course/11/problem/500#tab-custom-test">自定义测试</a></li>
</ul>
<p>对于一个长度为 n 的01序列 a1,a2,…,an。</p>
<p>你可以执行以下操作任意多次：</p>
<ul>
<li><p>选择两个下标 1≤i,j≤n(i≠j)。</p>
</li>
<li><p>记x&#x3D;ai xor aj , y&#x3D;ai or aj , 其中 xor 表示按位异或 , or 表示按位或。</p>
</li>
<li><p>然后令 ai&#x3D;x,aj&#x3D;y 或 ai&#x3D;y,aj&#x3D;x。</p>
</li>
</ul>
<p>给定两个01序列 s,t , 请你判断是否可以通过有限次(可以为0次)操作将序列 s 变为 t。</p>
<h4 id="输入格式-4"><a href="#输入格式-4" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行一个整数 t , 表示数据的组数(1≤t≤103)。接下来 t 组数据：</p>
<p>每组第一行一个01字符串 s(1≤|s|≤103)，每组第二行一个01字符串 t(1≤|t|≤103)。</p>
<p>注意：|s| 可能不等于 |t|。</p>
<h4 id="输出格式-4"><a href="#输出格式-4" class="headerlink" title="输出格式"></a>输出格式</h4><p>如果可以通过有限次(可以为0次)操作将序列 s 变为 t , 输出 <code>YES</code> , 否则输出 <code>NO</code>。</p>
<h4 id="样例输入-3"><a href="#样例输入-3" class="headerlink" title="样例输入"></a>样例输入</h4><pre><code>2
001
011
11
101
</code></pre>
<h4 id="样例输出-3"><a href="#样例输出-3" class="headerlink" title="样例输出"></a>样例输出</h4><pre><code>YES
NO
</code></pre>
<h4 id="样例解释"><a href="#样例解释" class="headerlink" title="样例解释"></a>样例解释</h4><p>第一组数据选择 i&#x3D;2,j&#x3D;3 , 那么 x&#x3D;1,y&#x3D;1 , 接着令 ai&#x3D;x,aj&#x3D;y 即可得到 t 序列。</p>
<p>第二组数据 |s|&#x3D;2,|t|&#x3D;3 显然无法满足要求。</p>
<p> #include <iostream><br>#include <algorithm><br>using namespace std;<br>int main(){<br>    int n;<br>    cin&gt;&gt;n;<br>    string a,b;<br>    string a2,b2;<br>    int len1,len2;<br>    int len01&#x3D;0,len02&#x3D;0;<br>    for(int j&#x3D;0;j&lt;n;j++){<br>        cin&gt;&gt;a&gt;&gt;b;<br>        len1&#x3D;a.length();<br>        len2&#x3D;b.length();<br>        for(int i&#x3D;0;i&lt;len1;i++){<br>            if(a[i]&#x3D;&#x3D;’0’){<br>                len01++;<br>            }</p>
<pre><code>    &#125;
    for(int i=0;i&lt;len2;i++)&#123;
        if(b[i]==&#39;0&#39;)&#123;
            len02++;
        &#125;
    &#125;

    if(len1!=len2)&#123;
        cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl;
    &#125;
    else if(len1==1&amp;&amp;a!=b)&#123;
        cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl;
    &#125;
    else if((len01==0&amp;&amp;len02!=0)||(len02==0&amp;&amp;len01!=0))&#123;
        cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl;
    &#125;
    else cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl;





&#125;
</code></pre>
<p>}</p>
<h1 id="整齐的数组"><a href="#整齐的数组" class="headerlink" title="整齐的数组"></a>整齐的数组</h1><p> <a target="_blank" rel="noopener" href="http://oj.daimayuan.top/download.php?type=problem&id=554">附加文件</a> <a target="_blank" rel="noopener" href="http://oj.daimayuan.top/course/11/problem/554/statistics">统计</a></p>
<ul>
<li> <a target="_blank" rel="noopener" href="http://oj.daimayuan.top/course/11/problem/554#tab-statement">描述</a></li>
<li> <a target="_blank" rel="noopener" href="http://oj.daimayuan.top/course/11/problem/554#tab-submit-answer">提交</a></li>
<li> <a target="_blank" rel="noopener" href="http://oj.daimayuan.top/course/11/problem/554#tab-custom-test">自定义测试</a></li>
</ul>
<p>​ Polycarp 有一个长度为 n 的数组 a1,a2,…,an（n 是偶数）。Polycarp 还得到了一个正整数 k，他开始对数组 a 做如下操作：选择一个下标 i (1≤i≤n) 使 ai 减去 k。</p>
<p>​ 在 Polycarp 进行若干次操作后（可能 0 次），数组 a 中的所有数都变成相同的了。请你找到最大的符合要求的 k，如果 k 可以为任意大，请输出 −1。<br>输入格式</p>
<hr>
<p>​ 第一行一个整数 t，表示测试单元的个数。</p>
<p>​ 接下来每个测试单元有两行。第一行包含一个偶数 n。第二行包含 n 个整数 a1,a2,…,an。<br>输出格式</p>
<hr>
<p>​ 对于每个测试单元输出单独一行一个整数 k (k≥1) —— Polycarp 能用来对数组进行操作的最大的数，或者 −1 —— 如果 k 能任意大的话。<br>样例输入</p>
<hr>
<pre><code>3
6
1 5 3 1 1 5
8
-1 0 1 -1 0 1 -1 0
4
100 -1000 -1000 -1000
</code></pre>
<h2 id="样例输出-4"><a href="#样例输出-4" class="headerlink" title="样例输出"></a>样例输出</h2><pre><code>2
1
1100
</code></pre>
<h2 id="数据规模-4"><a href="#数据规模-4" class="headerlink" title="数据规模"></a>数据规模</h2><p>​ 所有数据保证 1≤t≤10，4≤n≤40（n 是偶数），−106≤ai≤106，并且 n 的总和不超过100。</p>
<p> 中文</p>
<p>#include<iostream><br>using namespace std;<br>#include<vector><br>#include<algorithm><br>#include&lt;math.h&gt;<br>#include<set><br>#include<numeric><br>#include<string><br>#include&lt;string.h&gt;<br>#include<map><br>#include<unordered_map><br>#include<stack><br>#include<queue></p>
<p>typedef long long ll;<br>typedef pair&lt;int, ll&gt;PII;<br>const int MOD &#x3D; 1e9 + 7;<br>const int N &#x3D; 1e5 + 10;<br>ll a[N], b[N], w[N], v[N], f[N];</p>
<p>int main() {<br>    int t;<br>    cin &gt;&gt; t;<br>    while (t–)<br>    {<br>        int n, res &#x3D; 0, min_num &#x3D; 1e9,k&#x3D;-1;<br>        cin &gt;&gt; n;<br>        vector<int>v(n + 1);<br>        for (int i &#x3D; 1; i &lt;&#x3D; n; i++)<br>        {<br>            cin &gt;&gt; v[i];<br>            min_num &#x3D; min(min_num, v[i]);<br>        }<br>        map&lt;int, int&gt;mymap;<br>        for (int i &#x3D; 1; i &lt;&#x3D; n; i++)<br>        {<br>            if (v[i] !&#x3D; min_num)<br>            {<br>                int ans &#x3D; v[i] - min_num;<br>                for (int j &#x3D; 1; j * j &lt;&#x3D; ans; j++)<br>                {<br>                    if (ans % j &#x3D;&#x3D; 0)<br>                    {<br>                        mymap[j]++;<br>                        mymap[ans &#x2F; j]++;<br>                    }<br>                }<br>            }<br>            else<br>            {<br>                res++;<br>            }<br>        }<br>        for (auto i : mymap)<br>        {<br>            if (i.second &gt;&#x3D; n - res)k &#x3D; max(k, i.first);<br>        }<br>        cout &lt;&lt; k &lt;&lt; ‘\n’;<br>    }<br>    return 0;<br>}</p>
<h1 id="01序列"><a href="#01序列" class="headerlink" title="01序列"></a>01序列</h1><p> <a target="_blank" rel="noopener" href="http://oj.daimayuan.top/download.php?type=problem&id=502">附加文件</a> <a target="_blank" rel="noopener" href="http://oj.daimayuan.top/course/11/problem/502/statistics">统计</a></p>
<ul>
<li> <a target="_blank" rel="noopener" href="http://oj.daimayuan.top/course/11/problem/502#tab-statement">描述</a></li>
<li> <a target="_blank" rel="noopener" href="http://oj.daimayuan.top/course/11/problem/502#tab-submit-answer">提交</a></li>
<li> <a target="_blank" rel="noopener" href="http://oj.daimayuan.top/course/11/problem/502#tab-custom-test">自定义测试</a></li>
</ul>
<p>我们称一个字符串为好字符串，指这个字符串中只包含<code>0</code>和<code>1</code>。</p>
<p>现在有一个好字符串，求这个字符串中<code>1</code>恰好出现k次的子串有多少个。</p>
<h4 id="输入格式-5"><a href="#输入格式-5" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行给出一个数字k，表示子串中<code>1</code>的个数。</p>
<p>第二行给出好字符串。</p>
<h4 id="输出格式-5"><a href="#输出格式-5" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示好字符串中有多少个符合条件的子串</p>
<h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>0≤k≤106, |s|≤106</p>
<h4 id="样例输入1"><a href="#样例输入1" class="headerlink" title="样例输入1"></a>样例输入1</h4><pre><code>1
1010
</code></pre>
<h4 id="样例输出1"><a href="#样例输出1" class="headerlink" title="样例输出1"></a>样例输出1</h4><pre><code>6
</code></pre>
<h4 id="样例输入2"><a href="#样例输入2" class="headerlink" title="样例输入2"></a>样例输入2</h4><pre><code>2
01010
</code></pre>
<h4 id="样例输出2"><a href="#样例输出2" class="headerlink" title="样例输出2"></a>样例输出2</h4><pre><code>4
</code></pre>
<p>#include<iostream><br>using namespace std;<br>#include<vector><br>#include<algorithm><br>#include&lt;math.h&gt;<br>#include<set><br>#include<numeric><br>#include<string><br>#include<map><br>#include<unordered_map><br>#include<stack><br>#include<queue></p>
<p>typedef long long ll;<br>typedef pair&lt;int, int&gt;PII;<br>const int MOD &#x3D; 1e9 + 7;<br>const int N &#x3D; 100100;</p>
<p>int main()<br>{<br>    ios_base::sync_with_stdio(false);<br>    cin.tie(nullptr);<br>    cout.tie(nullptr);<br>    int k, l &#x3D; 0;<br>    cin &gt;&gt; k;<br>    string str;<br>    cin &gt;&gt; str;<br>    int n &#x3D; str.size();<br>    map&lt;int, ll&gt;mymap;<br>    mymap[0]++;<br>    ll res &#x3D; 0;<br>    vector<int>v(n + 1), sum(n + 1);<br>    if (k &#x3D;&#x3D; 0)<br>    {<br>        ll ans &#x3D; 0;<br>        str +&#x3D; ‘1’;<br>        n++;<br>        for (int i &#x3D; 0; i &lt; n; i++)<br>        {<br>            if (str[i] &#x3D;&#x3D; ‘0’)ans++;<br>            else<br>            {<br>                res +&#x3D; (ans + 1) * ans &#x2F; 2;<br>                ans &#x3D; 0;<br>            }<br>        }<br>    }<br>    else<br>    {<br>        for (int i &#x3D; 1; i &lt;&#x3D; n; i++)<br>        {<br>            v[i] &#x3D; str[i - 1] - ‘0’;<br>            sum[i] &#x3D; v[i] + sum[i - 1];<br>            mymap[sum[i]]++;<br>        }<br>        int ans &#x3D; 0;<br>        while (mymap[ans + k] !&#x3D; 0)<br>        {<br>            res +&#x3D; mymap[ans] * mymap[ans + k];<br>            ans++;<br>        }<br>    }<br>    cout &lt;&lt; res &lt;&lt; endl;<br>    return 0;<br>}</p>
<h1 id="出栈序列判断"><a href="#出栈序列判断" class="headerlink" title="出栈序列判断"></a>出栈序列判断</h1><p> <a target="_blank" rel="noopener" href="http://oj.daimayuan.top/download.php?type=problem&id=55">附加文件</a> <a target="_blank" rel="noopener" href="http://oj.daimayuan.top/course/11/problem/55/statistics">统计</a></p>
<ul>
<li> <a target="_blank" rel="noopener" href="http://oj.daimayuan.top/course/11/problem/55#tab-statement">描述</a></li>
<li> <a target="_blank" rel="noopener" href="http://oj.daimayuan.top/course/11/problem/55#tab-submit-answer">提交</a></li>
<li> <a target="_blank" rel="noopener" href="http://oj.daimayuan.top/course/11/problem/55#tab-custom-test">自定义测试</a></li>
</ul>
<p>现在有一个栈，有 n 个元素，分别为 1,2,…,n。我们可以通过 <code>push</code> 和 <code>pop</code> 操作，将这 n 个元素依次放入栈中，然后从栈中弹出，依次把出栈的元素写下来得到的序列就是出栈序列。</p>
<p>比如 n&#x3D;3，如果执行 <code>push 1, push 2, pop, push 3, pop, pop</code>，那么我们 <code>pop</code> 操作得到的元素依次是 2,3,1。也就是说出栈序列就是 2,3,1。</p>
<p>现在给定一个合法的出栈序列，请输出一个合法的由 <code>push</code> 和 <code>pop</code> 操作构成的操作序列。这里要求 <code>push</code> 操作一定是按 1,2,…,n 的顺序。</p>
<h4 id="输入格式-6"><a href="#输入格式-6" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行一个整数 n。接下来一行 n 个整数，表示出栈序列。</p>
<h4 id="输出格式-6"><a href="#输出格式-6" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出 2n 行，每行一个 <code>push</code> 或 <code>pop</code> 操作，可以证明一个出栈序列对应的操作序列是唯一的。</p>
<h4 id="样例输入1-1"><a href="#样例输入1-1" class="headerlink" title="样例输入1"></a>样例输入1</h4><pre><code>3
2 3 1
</code></pre>
<h4 id="样例输出1-1"><a href="#样例输出1-1" class="headerlink" title="样例输出1"></a>样例输出1</h4><pre><code>push 1
push 2
pop
push 3
pop
pop
</code></pre>
<h4 id="样例输入2-1"><a href="#样例输入2-1" class="headerlink" title="样例输入2"></a>样例输入2</h4><pre><code>5
1 3 5 4 2
</code></pre>
<h4 id="样例输出2-1"><a href="#样例输出2-1" class="headerlink" title="样例输出2"></a>样例输出2</h4><pre><code>push 1
pop
push 2
push 3
pop
push 4
push 5
pop
pop
pop
</code></pre>
<h4 id="数据规模-5"><a href="#数据规模-5" class="headerlink" title="数据规模"></a>数据规模</h4><p>对于 100% 的数据，保证 1≤n≤100000，输入一定是个合法的出栈序列。</p>
<p>#include <iostream><br>#include <algorithm><br>#include <stack></p>
<p>using namespace std;<br>int n;<br>int s[100001];<br>int top &#x3D; 0;<br>int l &#x3D; 0;<br>int main() {<br>    scanf(“%d”, &amp;n);<br>    for(int i &#x3D; 1; i &lt;&#x3D; n; i++) {<br>        int x;<br>        scanf(“%d”, &amp;x);<br>        if(s[top] !&#x3D; x) {&#x2F;&#x2F;因为我是从1开始的，而我们的数字里面必定没有0，所以第一次进入循环的时候是必定是不相等的<br>            for(int j &#x3D; l + 1; j &lt;&#x3D; x; j++) {<br>                printf(“push %d\n”, j);<br>                s[++top] &#x3D; j;<br>            }<br>            l &#x3D; x;<br>        }<br>        printf(“pop\n”);<br>        top–;<br>    }<br>    return 0;<br>}</p>
<h1 id="序列维护"><a href="#序列维护" class="headerlink" title="序列维护"></a>序列维护</h1><p> <a target="_blank" rel="noopener" href="http://oj.daimayuan.top/download.php?type=problem&id=57">附加文件</a> <a target="_blank" rel="noopener" href="http://oj.daimayuan.top/course/11/problem/57/statistics">统计</a></p>
<ul>
<li> <a target="_blank" rel="noopener" href="http://oj.daimayuan.top/course/11/problem/57#tab-statement">描述</a></li>
<li> <a target="_blank" rel="noopener" href="http://oj.daimayuan.top/course/11/problem/57#tab-submit-answer">提交</a></li>
<li> <a target="_blank" rel="noopener" href="http://oj.daimayuan.top/course/11/problem/57#tab-custom-test">自定义测试</a></li>
</ul>
<p>你有一个序列，现在你要支持几种操作：</p>
<ul>
<li><p><code>insert x y</code>，在从前往后的第x个元素后面插入y这个数。如果x&#x3D;0，那么就在开头插入。</p>
</li>
<li><p><code>delete x</code>，删除从前往后的第x个元素。</p>
</li>
<li><p><code>query k</code>，询问从前往后数第k个元素是多少。</p>
</li>
</ul>
<h4 id="输入格式-7"><a href="#输入格式-7" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行一个整数m，表示操作个数。</p>
<p>接下来m行，每行一个上面所述的操作。</p>
<h4 id="输出格式-7"><a href="#输出格式-7" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出若干行，对于每个查询操作，输出答案。</p>
<h4 id="样例输入-4"><a href="#样例输入-4" class="headerlink" title="样例输入"></a>样例输入</h4><pre><code>10
insert 0 1
insert 1 2
query 1
query 2
insert 0 3
query 1
delete 1
query 1
insert 1 4 
query 2
</code></pre>
<h4 id="样例输出-5"><a href="#样例输出-5" class="headerlink" title="样例输出"></a>样例输出</h4><pre><code>1
2
3
1
4
</code></pre>
<h4 id="数据规模-6"><a href="#数据规模-6" class="headerlink" title="数据规模"></a>数据规模</h4><p>对于100%的数据，保证m≤103。</p>
<p>对于insert操作，保证1≤y≤109。</p>
<p>对于所有操作，保证位置不会超出当前序列的长度。</p>
<p>#include &lt;bits&#x2F;stdc++.h&gt;</p>
<p>using namespace std;</p>
<p>typedef pair&lt;int, int&gt; pii;<br>typedef long long ll;<br>typedef vector<int> vi;<br>&#x2F;&#x2F;#define int long long<br>#define fir first<br>#define sec second<br>#define all(x) (x).begin(), (x).end()<br>#define sz(x) (int)x.size()<br>#define rep(i, l, r) for (int i &#x3D; l; i &lt;&#x3D; r; ++i)<br>#define repd(i, l, r) for (int i &#x3D; l; i &gt;&#x3D; r; –i)<br>#define pb push_back</p>
<p>const int N&#x3D;1e3+10;<br>int a[N];<br>vector<int>v;</p>
<p>int main() {<br>    ios_base::sync_with_stdio(false);<br>    cin.tie(NULL);<br>    int n;<br>    cin&gt;&gt;n;<br>    string s;<br>    int start,val;<br>    while(n–)<br>    {<br>        cin&gt;&gt;s;<br>        if(s&#x3D;&#x3D;”insert”)<br>        {<br>            cin&gt;&gt;start&gt;&gt;val;<br>            v.insert(v.begin()+start,val);<br>        }<br>        else if(s&#x3D;&#x3D;”delete”)<br>        {<br>            cin&gt;&gt;start;<br>            v.erase(v.begin()+start-1);<br>        }<br>        else if(s&#x3D;&#x3D;”query”)<br>        {<br>            cin&gt;&gt;start;<br>            cout&lt;&lt;v[start-1]&lt;&lt;endl;<br>        }<br>    }<br>    return 0;<br>}</p>
<h1 id="网格判断"><a href="#网格判断" class="headerlink" title="网格判断"></a>网格判断</h1><p> <a target="_blank" rel="noopener" href="http://oj.daimayuan.top/download.php?type=problem&id=551">附加文件</a> <a target="_blank" rel="noopener" href="http://oj.daimayuan.top/course/11/problem/551/statistics">统计</a></p>
<ul>
<li> <a target="_blank" rel="noopener" href="http://oj.daimayuan.top/course/11/problem/551#tab-statement">描述</a></li>
<li> <a target="_blank" rel="noopener" href="http://oj.daimayuan.top/course/11/problem/551#tab-submit-answer">提交</a></li>
<li> <a target="_blank" rel="noopener" href="http://oj.daimayuan.top/course/11/problem/551#tab-custom-test">自定义测试</a></li>
</ul>
<p>您将获得一个 n×n 的网格，网格中每个正方形的颜色为黑色或白色。如果满足以下所有条件，则网格是正确的：</p>
<ul>
<li><p>每行的黑色方块数与白色方块数相同。</p>
</li>
<li><p>每列的黑色正方形数与白色方块数相同。</p>
</li>
<li><p>没有行或列具有 3 个及以上相同颜色的连续正方形。</p>
</li>
</ul>
<p>给定网格，确定它是否正确。</p>
<h4 id="输入格式-8"><a href="#输入格式-8" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行一个数字 n（2≤n≤24)， 并且数字 n 是偶数。</p>
<p>接下来 n 行，每行包含一个长度为n的由字符<code>B</code>和<code>W</code>组成的字符串，代表网格正方形的颜色。</p>
<h4 id="输出格式-8"><a href="#输出格式-8" class="headerlink" title="输出格式"></a>输出格式</h4><p>如果网格正确，请打印数字 1 在一行上。否则，请打印数字 0 在一行上。</p>
<h4 id="样例输入-5"><a href="#样例输入-5" class="headerlink" title="样例输入"></a>样例输入</h4><pre><code>4
WBBW
WBWB
BWWB
BWBW
</code></pre>
<h4 id="样例输出-6"><a href="#样例输出-6" class="headerlink" title="样例输出"></a>样例输出</h4><pre><code>1
</code></pre>
<p> #include <iostream><br>#include <string><br>using namespace std;<br>const int max_n &#x3D; 24;</p>
<p>int n;<br>int row_sum, row_seq, row_status &#x3D; -1;<br>int col_sum[max_n], col_seq[max_n], col_status[max_n];</p>
<p>int main() {<br>    for (int i &#x3D; 0; i &lt; max_n; i++) col_status[i] &#x3D; -1;<br>    cin &gt;&gt; n; cin.ignore();<br>    string str;<br>    bool ans &#x3D; true, c;<br>    for (int i &#x3D; 0; i &lt; n; i++) {<br>        getline(cin, str);<br>        int len &#x3D; str.size();</p>
<pre><code>    if (ans) &#123;
        for (int j = 0; j &lt; len; j++) &#123;
            if (str[j] == &#39;B&#39;) c = 1;
            else c = 0;

            row_sum += c;
            if (row_status == c) &#123;
                row_seq++;
                if (row_seq == 3) &#123;
                    ans = false;
                    break;
                &#125;
            &#125;
            else &#123;
                row_seq = 1;
                row_status = c;
            &#125;

            col_sum[j] += c;
            if (col_status[j] == c) &#123;
                col_seq[j]++;
                if (col_seq[j] == 3) &#123;
                    ans = false;
                    break;
                &#125;
            &#125;
            else &#123;
                col_seq[j] = 1;
                col_status[j] = c;
            &#125;
        &#125;

        if (row_sum != n / 2) ans = false;
        row_sum = 0;
        row_seq = 0;
        row_status = -1;
    &#125;
&#125;

if (ans) &#123;
    for (int i = 0; i &lt; n; i++)
        if (col_sum[i] != n / 2) &#123;
            ans = false;
            break;
        &#125;
&#125;

cout &lt;&lt; ans &lt;&lt; endl;
return 0;
</code></pre>
<p>}</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/03/27/%E7%AC%AC%E4%BA%8C%E5%91%A8/" data-id="clfxsuq1n000nu4w1ertt32z1" data-title="第二周" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-first" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/03/21/first/" class="article-date">
  <time class="dt-published" datetime="2023-03-21T10:12:44.000Z" itemprop="datePublished">2023-03-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/03/21/first/">first</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>This is the 8th week.</p>
<h3 id="特殊的正方形"><a href="#特殊的正方形" class="headerlink" title="特殊的正方形"></a>特殊的正方形</h3><p> <a target="_blank" rel="noopener" href="http://oj.daimayuan.top/download.php?type=problem&id=386">附加文件</a> <a target="_blank" rel="noopener" href="http://oj.daimayuan.top/course/11/problem/386/statistics">统计</a></p>
<ul>
<li> <a target="_blank" rel="noopener" href="http://oj.daimayuan.top/course/11/problem/386#tab-statement">描述</a></li>
<li> <a target="_blank" rel="noopener" href="http://oj.daimayuan.top/course/11/problem/386#tab-submit-answer">提交</a></li>
<li> <a target="_blank" rel="noopener" href="http://oj.daimayuan.top/course/11/problem/386#tab-custom-test">自定义测试</a></li>
</ul>
<p>输入n，输出n行n列的由<code>+</code>和<code>.</code>组成的正方形，其中最外面一圈全是<code>+</code>，第二圈全是<code>.</code>，…，对于第i圈，如果i是奇数，那么全是<code>+</code>，否则全是<code>.</code>。</p>
<h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>一行，一个整数n。</p>
<h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>n行，为满足题目要求的正方形。注意不要有行末空格。</p>
<h4 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h4><pre><code>10
</code></pre>
<h4 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h4><pre><code>++++++++++
+........+
+.++++++.+
+.+....+.+
+.+.++.+.+
+.+.++.+.+
+.+....+.+
+.++++++.+
+........+
++++++++++
</code></pre>
<h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>对于100%的数据，保证2≤n≤100。</p>
<p> 中文</p>
<h3 id="Analyse："><a href="#Analyse：" class="headerlink" title="Analyse："></a>Analyse：</h3><p><a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98&spm=1001.2101.3001.7020">背包问题</a></p>
<p><strong>很清晰看到樱花树可以看得次数有三种，一次，多次，无数次，很显然这是一道混合背包的裸题，要用到二进制优化。</strong></p>
<p>这是一道混合背包板子题。使用二进制对数量有限且不为1的物品进行分割，化归为数量为1的物品。然后依据物品数为1或无限，分别按照0&#x2F;1背包、完全背包进行处理。0&#x2F;1背包、完全背包具体步骤 #include <iostream> using namespace std; int main() { const int A &#x3D; 1e4 + 5; int a[A], b[A], c[A], e[1005]; int x1, x2, x3, x4, n, m; char a1, a2; cin &gt;&gt; x1 &gt;&gt; a1 &gt;&gt; x2 &gt;&gt; x3 &gt;&gt; a2 &gt;&gt; x4 &gt;&gt; n; m &#x3D; (x3 - x1) * 60 + x4 - x2; for (int i &#x3D; 1; i &lt;&#x3D; n; i++) { cin &gt;&gt; a[i] &gt;&gt; b[i] &gt;&gt; c[i]; if (c[i] &#x3D;&#x3D; 0) c[i] &#x3D; 1e9; } for(int i&#x3D;1;i&lt;&#x3D;n;i++) for (int j &#x3D; m; j &gt;&#x3D; a[i]; j–) { if (a[i] &#x3D;&#x3D; 0) { for (int p &#x3D; 1; p &lt;&#x3D; m; p++) e[p] +&#x3D; b[i] * c[i]; break; } else { for (int t &#x3D; 1; t &lt;&#x3D; c[i] &amp;&amp; j &gt;&#x3D; a[i] * t; t++) e[j] &#x3D; max(e[j], e[j - a[i] * t] + b[i] * t); } } cout &lt;&lt; e[m]; return 0; }</p>
<h3 id="My-Code"><a href="#My-Code" class="headerlink" title="My Code:"></a>My Code:</h3><pre><code>#include &lt;iostream&gt;
using namespace std;
string a[101][101];
void scf(int w,int n)&#123;
    string aa;
    if(n%2==0)&#123;
        aa=&quot;+&quot;;
    &#125;else aa=&quot;.&quot;;
    for(int i=n;i&lt;w-n;i++)&#123;
        a[n][i]=aa;
        a[w-n-1][i]=aa;
        a[i][n]=aa;
        a[i][w-n-1]=aa;
    &#125;
&#125;
int main()&#123;
    int len;
    cin&gt;&gt;len;
    int len1;
    len1=(len-1)/2;
    for(int i=0;i&lt;=len1;i++)&#123;
        scf(len,i);
    &#125;
    for(int i=0;i&lt;len-1;i++)&#123;
        for(int j=0;j&lt;len;j++)&#123;
            cout&lt;&lt;a[i][j];

        &#125;
        cout&lt;&lt;endl;
    &#125;
    for(int j=0;j&lt;len;j++)&#123;
        cout&lt;&lt;a[len-1][j];

    &#125;
&#125;
</code></pre>
<h1 id="走楼梯2"><a href="#走楼梯2" class="headerlink" title="走楼梯2"></a>走楼梯2</h1><p> <a target="_blank" rel="noopener" href="http://oj.daimayuan.top/download.php?type=problem&id=129">附加文件</a> <a target="_blank" rel="noopener" href="http://oj.daimayuan.top/course/11/problem/129/statistics">统计</a></p>
<ul>
<li> <a target="_blank" rel="noopener" href="http://oj.daimayuan.top/course/11/problem/129#tab-statement">描述</a></li>
<li> <a target="_blank" rel="noopener" href="http://oj.daimayuan.top/course/11/problem/129#tab-submit-answer">提交</a></li>
<li> <a target="_blank" rel="noopener" href="http://oj.daimayuan.top/course/11/problem/129#tab-custom-test">自定义测试</a></li>
</ul>
<p>楼梯有 n 阶，上楼可以一步上一阶，也可以一步上二阶。</p>
<p>但你不能连续三步都走两阶，计算走到第n阶共有多少种不同的走法。</p>
<h4 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h4><p>一行，一个数字，表示n。</p>
<h4 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出走楼梯的方式总数。</p>
<h4 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入"></a>样例输入</h4><pre><code>6
</code></pre>
<h4 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出"></a>样例输出</h4><pre><code>12
</code></pre>
<h4 id="数据规模"><a href="#数据规模" class="headerlink" title="数据规模"></a>数据规模</h4><p>对于100%的数据，保证n≤50。</p>
<p> 中文</p>
<h3 id="Analyse：-1"><a href="#Analyse：-1" class="headerlink" title="Analyse："></a>Analyse：</h3><p>这道题的价值在于，它既可以从简单的动态规划开始，一路优化，也可以从生成函数的视角观察，继续优化。</p>
<p>从这个题我才知道DP并不是全都有max,min函数的啊，DP的核心其实是从上一层的最优解推下一层的最优解，但这个题的最优即所有方案加起来的和，所以这个题没有取max,min。</p>
<h3 id="My-Code-1"><a href="#My-Code-1" class="headerlink" title="My Code:"></a>My Code:</h3><pre><code>#include &lt;iostream&gt;
using namespace std;
int fun(int n,int key)&#123;
    if(n&lt;0||key==3)return 0;
    else if(n==1)&#123;
        return 1;

    &#125;
    else if(n==2)&#123;
        if(key==2)return 1;
        else return 2;
    &#125;
    else return fun(n-1,0)+fun(n-2,++key);


&#125;



int main()
&#123;
    int n;
    cin&gt;&gt;n;
    cout&lt;&lt;fun(n,0);
    return 0;
&#125;
</code></pre>
<h1 id="走路"><a href="#走路" class="headerlink" title="走路"></a>走路</h1><p> <a target="_blank" rel="noopener" href="http://oj.daimayuan.top/download.php?type=problem&id=460">附加文件</a> <a target="_blank" rel="noopener" href="http://oj.daimayuan.top/course/11/problem/460/statistics">统计</a></p>
<ul>
<li> <a target="_blank" rel="noopener" href="http://oj.daimayuan.top/course/11/problem/460#tab-statement">描述</a></li>
<li> <a target="_blank" rel="noopener" href="http://oj.daimayuan.top/course/11/problem/460#tab-submit-answer">提交</a></li>
<li> <a target="_blank" rel="noopener" href="http://oj.daimayuan.top/course/11/problem/460#tab-custom-test">自定义测试</a></li>
</ul>
<p>有一条很长的数轴，一开始你在0的位置。接下来你要走n步，第i步你可以往右走ai或者bi。</p>
<p>问n步之后，0到m的每个位置，能不能走到？</p>
<h3 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行，两个整数n,m。</p>
<p>接下来n行，每行两个整数ai,bi。</p>
<h3 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式"></a>输出格式</h3><p>一行，一共m+1个数，每个数都是<code>0</code>或<code>1</code>表示能否走到，数字之间不用空格隔开。</p>
<h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h3><pre><code>3 10
1 2
2 6
3 3
</code></pre>
<h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h3><pre><code>00000011001
</code></pre>
<h3 id="数据规模-1"><a href="#数据规模-1" class="headerlink" title="数据规模"></a>数据规模</h3><p>对于所有数据，保证1≤n≤100,1≤m≤105,1≤ai,bi≤1000。</p>
<p> 中文</p>
<h3 id="Analyse：-2"><a href="#Analyse：-2" class="headerlink" title="Analyse："></a>Analyse：</h3><ol>
<li><ul>
<li><p>我们可以对主件i的“附件集合”先进行一次01背包，得到费用依次为0..V-c[i]。所有这些值时相应的最大价值f’[0..V-c[i]]。</p>
</li>
<li><p>那么这个主件及它的附件集合相当于V-c[i]+1个物品的物品组，其中费用为c[i]+k的物品的价值为f’[k]+w[i]。也就是说原来指数级的策略中有很多策略都是冗余的，通过一次01背包后，将主件i转化为V-c[i]+1个物品的物品组，就可以直接解决问题了。</p>
</li>
</ul>
</li>
</ol>
<h3 id="My-Code-2"><a href="#My-Code-2" class="headerlink" title="My Code:"></a>My Code:</h3><pre><code>#include &lt;iostream&gt;
using namespace std;
#define N 100000 
typedef long long ll;

ll f[110][N]=&#123;0&#125;;
int a[1000];
int b[1000];
int n,m;
int main()&#123;
    cin&gt;&gt;n&gt;&gt;m;
    for(int i=0;i&lt;n;i++)&#123;
        cin&gt;&gt;a[i];
        cin&gt;&gt;b[i];
    &#125;
    f[0][0]=1;
    for(int i=0;i&lt;n;i++)&#123;
        for(int j=0;j&lt;=m;j++)&#123;
            if(f[i][j]==1)&#123;
                if((f[i][j]+a[i])&lt;m+1)f[i+1][j+a[i]]=1;
                if((f[i][j]+b[i])&lt;m+1)f[i+1][j+b[i]]=1;

            &#125;
        &#125;


    &#125;
    for(int i=0;i&lt;m+1;i++)&#123;
        cout&lt;&lt;f[n][i];
    &#125;


&#125;
</code></pre>
<h1 id="简单分数统计"><a href="#简单分数统计" class="headerlink" title="简单分数统计"></a>简单分数统计</h1><p> <a target="_blank" rel="noopener" href="http://oj.daimayuan.top/download.php?type=problem&id=455">附加文件</a> <a target="_blank" rel="noopener" href="http://oj.daimayuan.top/course/11/problem/455/statistics">统计</a></p>
<ul>
<li> <a target="_blank" rel="noopener" href="http://oj.daimayuan.top/course/11/problem/455#tab-statement">描述</a></li>
<li> <a target="_blank" rel="noopener" href="http://oj.daimayuan.top/course/11/problem/455#tab-submit-answer">提交</a></li>
<li> <a target="_blank" rel="noopener" href="http://oj.daimayuan.top/course/11/problem/455#tab-custom-test">自定义测试</a></li>
</ul>
<p>N 个好朋友在codeforces上参加一场包含 M 个题目的比赛, 比赛期间codeforces网站一共有 k 次提交。</p>
<p>已知每个题目的分数，</p>
<p>但是由于他们只能查到在比赛期间codeforces总共的提交记录(其他用户提交的其他题目记录也包含在内, 即存在不属于该场比赛的题目)，</p>
<p>所以想请你编写一个程序算出他们每个人的分数。</p>
<h4 id="输入格式-3"><a href="#输入格式-3" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行三个整数 N, M, K 分别表示好朋友的个数, 题目的个数, 和提交的总次数(其中0&lt;N,M,K&lt;&#x3D;200）。</p>
<p>接下来 N 行 第 i 行输入为第 i 个人的id，</p>
<p>接下来 M 行 第 j 行输入为第 j 个题目的名称和分数，</p>
<p>接下来 K 行 第 k 行输入为第 k 次提交的提交者id, 题目名称和结果(“WA” 或 “AC”, 如果”AC”代表通过这个题目, 提交者获得对应分数)。</p>
<p>注: 题目名称和id均为仅包含英文字母和数字的字符串, 题目分数为小于等于 1e6 的正整数. 每一行的多个输入之间用空格隔开。</p>
<p>所有输入的字符串长度 length 满足 0&lt;length≤500。</p>
<p>所有用户id和题目名称不存在重名, 用户AC了某个题之后之后不会再重复提交该题, 好朋友们只会提交属于比赛的题目。</p>
<h4 id="输出格式-3"><a href="#输出格式-3" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出 N 行, 第 i 行输出第 i 个人的名字和对应分数 (名字和分数用空格隔开)。</p>
<h4 id="样例输入-2"><a href="#样例输入-2" class="headerlink" title="样例输入"></a>样例输入</h4><pre><code>2 2 4
GabrielPessoa
beza
metebronca 100
geometry 200
beza metebronca AC
ffern numbertheory AC
GabrielPessoa geometry WA
beza geometry AC
</code></pre>
<h4 id="样例输出-2"><a href="#样例输出-2" class="headerlink" title="样例输出"></a>样例输出</h4><pre><code>GabrielPessoa 0
beza 300
</code></pre>
<h4 id="样例解释"><a href="#样例解释" class="headerlink" title="样例解释"></a>样例解释</h4><p>beza 过了 metebronca和geometry 拿到 300 分。</p>
<p>GabrielPessos 没有过题, 所以是 0 分。</p>
<p>还有一些其他选手提交的其他题目忽略不计。</p>
<p>Analyse：</p>
<ol>
<li><ul>
<li><p>我们可以对主件i的“附件集合”先进行一次01背包，得到费用依次为0..V-c[i]。所有这些值时相应的最大价值f’[0..V-c[i]]。</p>
</li>
<li><p>那么这个主件及它的附件集合相当于V-c[i]+1个物品的物品组，其中费用为c[i]+k的物品的价值为f’[k]+w[i]。也就是说原来指数级的策略中有很多策略都是冗余的，通过一次01背包后，将主件i转化为V-c[i]+1个物品的物品组，就可以直接解决问题了。</p>
</li>
</ul>
</li>
</ol>
<h3 id="My-Code-3"><a href="#My-Code-3" class="headerlink" title="My Code:"></a>My Code:</h3><pre><code>#include &lt;iostream&gt;
#include &lt;string.h&gt;
using namespace std;
int N,M,J;
struct T&#123;
    string name;
    int core;
&#125;;
struct P&#123;
    string name;
    string pname;
    string result;

&#125;;
struct F&#123;
    string name;
    int core=0;
&#125;;
T test[100];
P data[1000];
F guys[100];
string f[100],t[100];//名字
int core[100];   //单科分
string p=&quot;AC&quot;;

int dd(string a[],string result)&#123;
    for(int i=0;i&lt;N;i++)&#123;  //i&lt;sizeof(a)/sizeof(a[0])
        if(a[i]==result)return i;     //strcmp(const char[],const char[])
    &#125;
    return -1;
&#125;

int nn(string a[],string b)&#123;
    for(int i=0;i&lt;M;i++)&#123;
        if(a[i]==b)return i;

    &#125;
    return -1;

&#125;

int main()&#123;
    int DD, NN;
    cin&gt;&gt;N;
    cin&gt;&gt;M;
    cin&gt;&gt;J;
    for(int i=0;i&lt;N;i++)&#123;
        cin&gt;&gt;f[i];
        guys[i].name=f[i];
    &#125;
    for(int i=0;i&lt;M;i++)&#123;
        cin&gt;&gt;t[i];
        cin&gt;&gt;core[i];
        test[i].name=t[i];
        test[i].core=core[i];
    &#125;
    
    for(int i=0;i&lt;J;i++)&#123;
        cin&gt;&gt;(data+i)-&gt;pname;
        cin&gt;&gt;(data+i)-&gt;name;
        cin&gt;&gt;data[i].result;
        if((DD=dd(f,data[i].pname))!=-1&amp;&amp;data[i].result!=&quot;WA&quot;)&#123;
            NN=nn(t,data[i].name);
            guys[DD].core+=test[NN].core;
    
        &#125;
    &#125;
    for(int i=0;i&lt;N;i++)&#123;
        cout&lt;&lt;guys[i].name&lt;&lt;&quot; &quot;&lt;&lt;guys[i].core&lt;&lt;endl;
    &#125;



&#125;
</code></pre>
<h1 id="Alice的德州扑克"><a href="#Alice的德州扑克" class="headerlink" title="Alice的德州扑克"></a>Alice的德州扑克</h1><p> <a target="_blank" rel="noopener" href="http://oj.daimayuan.top/download.php?type=problem&id=453">附加文件</a> <a target="_blank" rel="noopener" href="http://oj.daimayuan.top/course/11/problem/453/statistics">统计</a></p>
<ul>
<li> <a target="_blank" rel="noopener" href="http://oj.daimayuan.top/course/11/problem/453#tab-statement">描述</a></li>
<li> <a target="_blank" rel="noopener" href="http://oj.daimayuan.top/course/11/problem/453#tab-submit-answer">提交</a></li>
<li> <a target="_blank" rel="noopener" href="http://oj.daimayuan.top/course/11/problem/453#tab-custom-test">自定义测试</a></li>
</ul>
<blockquote>
<p>德州扑克是目前世界上最流行的扑克游戏，全世界有众多相关的比赛，例如是 WSOP，WPT，EPT等，也让这款游戏的玩法变得层出不穷，丰富多变。 不要被简单的游戏规则而误导，复杂多变的比赛状况，让这款游戏在高水平的竞技中会变得非常复杂，这也让人们为德州扑克给出了这样一句评价 ”用一刻就能学会，但要用一生才能掌握” 。</p>
</blockquote>
<p>现在我们并不在乎游戏规则是什么，因为 Alice 是一个德州扑克高手，他对于德州扑克的规则烂熟于心，不过他每次都记不得牌型的大小关系，他知道你是一个编程高手，所以他想让你帮他写一个程序：输入五张牌的大小和花色，输出这五张牌能组成的最大牌型.你能帮帮他吗?</p>
<p>为了降低你的编程难度，我们规定：</p>
<ol>
<li><p><strong>输入的牌都是来源于同一副扑克牌</strong></p>
</li>
<li><p><strong>输入的牌的点数都是非递减的</strong></p>
</li>
<li><p><strong>所有花色没有大小之分</strong></p>
</li>
</ol>
<p>下面给出各牌型，(从大到小)</p>
<ol>
<li><p>**皇家同花顺(ROYAL FLUSH)<strong>：五张顺连的牌(点数连续单调递增)，</strong>且最大的一张牌是A(Ace)**，并且五张牌的花色相同</p>
</li>
<li><p>**同花顺(STRAIGHT FLUSH)<strong>：五张顺连的牌(点数连续单调递增)，</strong>不规定最大的一张牌是A(Ace)**，并且五张牌的花色相同</p>
</li>
<li><p>**四条(FOUR OF A KIND)**：至少四张牌的点数相同</p>
</li>
<li><p>**葫芦(FULL HOUSE)**：至少三张牌的点数相同，并且除此之外还有两张牌的点数相同</p>
</li>
<li><p>**同花(FLUSH)**：五张牌的花色都相同</p>
</li>
<li><p>**顺子(STRAIGHT)**：五张顺连的牌(点数连续单调递增)，不要求五张牌的花色相同</p>
</li>
<li><p><strong>特别注意</strong>：由于 Alice 是个谨慎的人，所以比 <strong>三条(THREE OF A KIND)</strong> (包括三条) 小的牌型 Alice 不在乎他们的大小关系，你只需要告诉 Alice 弃牌就行</p>
</li>
</ol>
<h4 id="输入格式-4"><a href="#输入格式-4" class="headerlink" title="输入格式"></a>输入格式</h4><p>输入两行，每行五个数字，第一行的第 i 个字符表示第 i 张扑克的点数，</p>
<p>第二行的第 i 个数字表示第 i 张扑克花色。**(保证输入的牌的点数是非递减的，且所有输入均合法)**。</p>
<p>点数和对应输入的数字：</p>
<ul>
<li>2−10 对应 2 - 10</li>
<li>J(Jack) 对应 11</li>
<li>Q(Queen) 对应 12</li>
<li>K(King) 对应 13</li>
<li>A(Ace) 对应 14</li>
</ul>
<p>花色和对应输入的数字：</p>
<ul>
<li>黑桃 (Spades) 对应 1</li>
<li>方片 (Diamonds) 对应 2</li>
<li>红桃 (Hearts) 对应 3</li>
<li>梅花 (Clubs) 对应 4</li>
</ul>
<h4 id="输出格式-4"><a href="#输出格式-4" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出这五张牌能组成的最大牌型。</p>
<ul>
<li>如果最大是皇家同花顺输出 “ROYAL FLUSH”</li>
<li>如果最大是同花顺输出 “STRAIGHT FLUSH”</li>
<li>如果最大是四条输出 “FOUR OF A KIND”</li>
<li>如果最大是葫芦输出 “FULL HOUSE”</li>
<li>如果最大是同花输出 “FLUSH”</li>
<li>如果最大是顺子输出 “STRAIGHT”</li>
<li>如果最大的牌型小于等于三条输出”FOLD”，劝 Alice 弃牌</li>
<li>输出不包括引号</li>
</ul>
<h4 id="样例输入1"><a href="#样例输入1" class="headerlink" title="样例输入1"></a>样例输入1</h4><pre><code>10 11 12 13 14
1 1 1 1 1
</code></pre>
<h4 id="样例输出1"><a href="#样例输出1" class="headerlink" title="样例输出1"></a>样例输出1</h4><pre><code>ROYAL FLUSH
</code></pre>
<h4 id="样例输入2"><a href="#样例输入2" class="headerlink" title="样例输入2"></a>样例输入2</h4><pre><code>10 11 12 13 14
1 2 1 3 4
</code></pre>
<h4 id="样例输出2"><a href="#样例输出2" class="headerlink" title="样例输出2"></a>样例输出2</h4><pre><code>STRAIGHT
</code></pre>
<h4 id="样例输入3"><a href="#样例输入3" class="headerlink" title="样例输入3"></a>样例输入3</h4><pre><code>6 6 6 7 7
1 2 3 1 3
</code></pre>
<h4 id="样例输出3"><a href="#样例输出3" class="headerlink" title="样例输出3"></a>样例输出3</h4><pre><code>FULL HOUSE
</code></pre>
<h4 id="样例输入4"><a href="#样例输入4" class="headerlink" title="样例输入4"></a>样例输入4</h4><pre><code>3 3 6 6 9
1 2 1 2 1
</code></pre>
<h4 id="样例输出4"><a href="#样例输出4" class="headerlink" title="样例输出4"></a>样例输出4</h4><pre><code>FOLD
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/QiuHong-1202/FigureBed/2021/202203011202618.png" alt="image-20220301120214464"></p>
<h3 id="My-Code-4"><a href="#My-Code-4" class="headerlink" title="My Code:"></a>My Code:</h3><pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
using namespace std;
bool flush(int color[])&#123;
    for(int i=0;i&lt;4;i++)&#123;
        if(color[i]!=color[i+1])&#123;
            return false;
        &#125;
    &#125;
    return true;

&#125;
bool straight(int a[])&#123;
    for(int i=0;i&lt;4;i++)&#123;
        if(a[i+1]-a[i]!=1)
        return false;
    &#125;
    return true;
&#125;
int kind(int a[])&#123;
    int k=0;
    int key1=1;
    int key2=0;
    int num1=a[0];
    int num2=a[1];
    for(int i=1;i&lt;5;i++)&#123;
        if(a[i]==num1)&#123;
            key1++;
        &#125;
        else if(k==0) &#123;
            num2=a[i];
            key2++;
            k=1;
        &#125;
        else if(a[i]==num2) &#123;
            key2++;
        &#125;
        else return 0;
        
    &#125;
    if(key1&gt;=4||key2&gt;=4)return 4;
    if(key1==3||key2==3)return 3;
    return 0;

&#125;

int main()&#123;
    vector&lt;int&gt;a;
    int nn[5];
    int color[5];
    int num;
    for(int i=0;i&lt;5;i++)&#123;
        cin&gt;&gt;num;
        a.push_back(num);
    &#125;
    for(int i=0;i&lt;5;i++)&#123;
        cin&gt;&gt;color[i];
    &#125;
    sort(a.begin(),a.end());
    for(int i=0;i&lt;5;i++)&#123;
        nn[i]=a[i];

    &#125;
    if(flush(color))&#123;
        if(straight(nn)&amp;&amp;nn[4]==14)cout&lt;&lt;&quot;ROYAL FLUSH&quot;;
        else if(straight(nn))cout&lt;&lt;&quot;STRAIGHT FLUSH&quot;;
        else cout&lt;&lt;&quot;FLUSH&quot;;
        return 0;
    &#125;
    if(straight(nn))&#123;
        cout&lt;&lt;&quot;STRAIGHT&quot;;
        return 0;
    &#125;
    int kk=kind(nn);
    if(kk==4)&#123;
        cout&lt;&lt;&quot;FOUR OF A KIND&quot;;
        return 0;
        &#125;
    else if(kk==3)&#123;
        cout&lt;&lt;&quot;FULL HOUSE&quot;; 
        return 0;
    &#125;
    cout&lt;&lt;&quot;FOLD&quot;;
    


&#125;
</code></pre>
<h1 id="订单编号"><a href="#订单编号" class="headerlink" title="订单编号"></a>订单编号</h1><p> <a target="_blank" rel="noopener" href="http://oj.daimayuan.top/download.php?type=problem&id=465">附加文件</a> <a target="_blank" rel="noopener" href="http://oj.daimayuan.top/course/11/problem/465/statistics">统计</a></p>
<ul>
<li> <a target="_blank" rel="noopener" href="http://oj.daimayuan.top/course/11/problem/465#tab-statement">描述</a></li>
<li> <a target="_blank" rel="noopener" href="http://oj.daimayuan.top/course/11/problem/465#tab-submit-answer">提交</a></li>
<li> <a target="_blank" rel="noopener" href="http://oj.daimayuan.top/course/11/problem/465#tab-custom-test">自定义测试</a></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://space.bilibili.com/5055">小缘</a>开了一家公司，生意很好，每天都会收到很多订单，自动交易系统会自动给这些订单生成没有重复的订单编号。但是有一天，系统出现了未知的错误，导致当天的订单编号可能有重复的，这可把小缘急坏了。你可以帮助小缘按照规则给这些订单重新编号吗？</p>
<p>按照时间先后顺序给出 N 个正整数作为原订单编号，你需要按照规则依次赋予这些订单新的编号，对于任意一个订单，要找到大于等于其原订单编号且未被使用过的（没有被之前的订单作为新的订单编号）的最小整数，作为它的新订单编号。</p>
<p>例如： 原订单编号依次为1 2 3 1，则新订单编号应该为1 2 3 4 （前3个订单的原订单编号都没有使用过，所以用其原订单编号即可，对于第四个订单，原订单编号为1，而1, 2, 3都已经被使用过，所以新订单编号为4）。</p>
<h4 id="输入格式-5"><a href="#输入格式-5" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行输入一个整数 N (1≤N≤5×105)。</p>
<p>第二行输入 N 个数 ai (1≤ai≤109) 作为原订单编号。</p>
<h4 id="输出格式-5"><a href="#输出格式-5" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一行，包含 N 个整数为新的订单编号。</p>
<h4 id="样例输入1-1"><a href="#样例输入1-1" class="headerlink" title="样例输入1"></a>样例输入1</h4><pre><code>6
2 3 4 1 1 1
</code></pre>
<h4 id="样例输出1-1"><a href="#样例输出1-1" class="headerlink" title="样例输出1"></a>样例输出1</h4><pre><code>2 3 4 1 5 6
</code></pre>
<h4 id="样例输入2-1"><a href="#样例输入2-1" class="headerlink" title="样例输入2"></a>样例输入2</h4><pre><code>3
1000000000 1000000000 1000000000
</code></pre>
<h4 id="样例输出2-1"><a href="#样例输出2-1" class="headerlink" title="样例输出2"></a>样例输出2</h4><pre><code>1000000000 1000000001 1000000002
</code></pre>
<h4 id="样例输入3-1"><a href="#样例输入3-1" class="headerlink" title="样例输入3"></a>样例输入3</h4><pre><code>6
4 5 1 2 1 1
</code></pre>
<h4 id="样例输出3-1"><a href="#样例输出3-1" class="headerlink" title="样例输出3"></a>样例输出3</h4><pre><code>4 5 1 2 3 6
</code></pre>
<p> 中文</p>
<h3 id="My-Code-5"><a href="#My-Code-5" class="headerlink" title="My Code:"></a>My Code:</h3><pre><code>#include&lt;iostream&gt;
using namespace std;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
#include&lt;set&gt;
#include&lt;string&gt;
#include&lt;map&gt;
#include&lt;unordered_map&gt;
#include&lt;stack&gt;

typedef long long ll;
typedef pair&lt;int, int&gt;PII;

set&lt;PII&gt;s;

void myinsert(int l, int r)
&#123;
    if (l &gt; r)return;
    s.insert(&#123; r,l &#125;);
&#125;

int main()
&#123;
    int n;
    cin &gt;&gt; n;
    s.insert(&#123; 2e9,1 &#125;);
    for (int i = 1; i &lt;= n; i++)
    &#123;
        int x;
        scanf(&quot;%d&quot;,&amp;x);
        auto it = s.lower_bound(&#123; x,0 &#125;);
        if (it-&gt;second &lt;= x)
        &#123;
            cout &lt;&lt; x &lt;&lt; &quot; &quot;;
            myinsert(it-&gt;second, x - 1);
            myinsert(x + 1, it-&gt;first);
            s.erase(it);
        &#125;
        else
        &#123;
            cout &lt;&lt; it-&gt;second &lt;&lt; &quot; &quot;;
            myinsert(it-&gt;second + 1, it-&gt;first);
            s.erase(it);
        &#125;
    &#125;
    return 0;
&#125;
</code></pre>
<h1 id="饿饿-饭饭"><a href="#饿饿-饭饭" class="headerlink" title="饿饿 饭饭"></a>饿饿 饭饭</h1><p> <a target="_blank" rel="noopener" href="http://oj.daimayuan.top/download.php?type=problem&id=463">附加文件</a> <a target="_blank" rel="noopener" href="http://oj.daimayuan.top/course/11/problem/463/statistics">统计</a></p>
<ul>
<li> <a target="_blank" rel="noopener" href="http://oj.daimayuan.top/course/11/problem/463#tab-statement">描述</a></li>
<li> <a target="_blank" rel="noopener" href="http://oj.daimayuan.top/course/11/problem/463#tab-submit-answer">提交</a></li>
<li> <a target="_blank" rel="noopener" href="http://oj.daimayuan.top/course/11/problem/463#tab-custom-test">自定义测试</a></li>
</ul>
<p>有n个同学正在排队打饭，第i个同学排在从前往后第i个位置。但是这天食堂内只有一个食堂阿姨，为了使同学们都能尽快的吃上饭，每一个同学在打完一份饭之后就会排在队伍的末尾先吃着打到的饭，我们知道第i个同学的饭量为ai，也就是说第i个同学要吃ai份饭才能吃饱，当一位同学吃饱后，他就会立刻离开食堂，不会排在队伍的末尾。食堂阿姨想知道，在打完k份饭之后，队伍的样子是怎样的，但是食堂阿姨数学不太好，想让你帮忙想想办法。</p>
<h4 id="输入格式-6"><a href="#输入格式-6" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行给出两个整数n，k。</p>
<p>第二行给出n个整数a1,a2,……an。</p>
<h4 id="输出格式-6"><a href="#输出格式-6" class="headerlink" title="输出格式"></a>输出格式</h4><p>如果食堂阿姨打饭数少于k，请输出”-1”。</p>
<p>否则按照队伍顺序输出每一个同学的编号。</p>
<h4 id="样例输入1-2"><a href="#样例输入1-2" class="headerlink" title="样例输入1"></a>样例输入1</h4><pre><code>3 3
1 2 1
</code></pre>
<h4 id="样例输出1-2"><a href="#样例输出1-2" class="headerlink" title="样例输出1"></a>样例输出1</h4><pre><code>2
</code></pre>
<h4 id="样例输入2-2"><a href="#样例输入2-2" class="headerlink" title="样例输入2"></a>样例输入2</h4><pre><code>4 10
3 3 2 1
</code></pre>
<h4 id="样例输出2-2"><a href="#样例输出2-2" class="headerlink" title="样例输出2"></a>样例输出2</h4><pre><code>-1
</code></pre>
<h4 id="样例输入3-2"><a href="#样例输入3-2" class="headerlink" title="样例输入3"></a>样例输入3</h4><pre><code>7 10
1 3 3 1 2 3 1
</code></pre>
<h4 id="样例输出3-2"><a href="#样例输出3-2" class="headerlink" title="样例输出3"></a>样例输出3</h4><pre><code>6 2 3
</code></pre>
<h4 id="数据规模-2"><a href="#数据规模-2" class="headerlink" title="数据规模"></a>数据规模</h4><p>数据保证1≤n≤105, 0≤k≤1014, 1≤ai≤109。</p>
<p> 中文</p>
<pre><code>#include&lt;iostream&gt;
using namespace std;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
#include&lt;set&gt;
#include&lt;string&gt;
#include&lt;map&gt;
#include&lt;unordered_map&gt;
#include&lt;stack&gt;

typedef long long ll;
typedef pair&lt;int, int&gt;PII;


int main()
&#123;
    map&lt;ll, int&gt;mymap;
    ll n, k;
    ll sum = 0;
    cin &gt;&gt; n &gt;&gt; k;
    vector&lt;ll&gt;v(n + 1);
    for (int i = 1; i &lt;= n; i++)
    &#123;
        cin &gt;&gt; v[i];
        sum += v[i];
        mymap[v[i]]++;
    &#125;
    if (sum &lt; k)
    &#123;
        cout &lt;&lt; -1 &lt;&lt; endl;
        return 0;
    &#125;
    ll len = n, res = 0, algo = 0;
    auto it = mymap.begin();
    while (it!=mymap.end()&amp;&amp;k &gt;= (it-&gt;first - algo) * len)
    &#123;
        k -= (it-&gt;first - algo) * len;
        len -= it-&gt;second;
        res = it-&gt;first;
        algo = it-&gt;first;
        it++;
        if (len == 1)
            cout &lt;&lt; &quot; &quot;;
    &#125;
    if (len == 0)
    &#123;
        return 0;
    &#125;
    k %= len;
    int ans = 1;
    vector&lt;ll&gt;back;
    bool flag = false;
    for (int i = ans; i &lt;= n &amp;&amp; k; i++)
    &#123;
        flag = false;
        if (v[i] == res + 1)
        &#123;
            k--;
            ans = i;
            flag = true;
        &#125;
        else if (v[i] &gt; res)
        &#123;
            back.push_back(i);
            ans = i;
            k--;
            flag = true;
        &#125;
    &#125;
    if (flag)ans++;
    for (int i = ans; i &lt;= n; i++)
    &#123;
        if (v[i] &gt; res)cout &lt;&lt; i &lt;&lt; &quot; &quot;;
    &#125;
    for (int i = 0; i &lt; back.size(); i++)cout &lt;&lt; back[i] &lt;&lt; &quot; &quot;;

    return 0;
&#125;
</code></pre>
<h1 id="任务分配"><a href="#任务分配" class="headerlink" title="任务分配"></a>任务分配</h1><p> <a target="_blank" rel="noopener" href="http://oj.daimayuan.top/download.php?type=problem&id=461">附加文件</a> <a target="_blank" rel="noopener" href="http://oj.daimayuan.top/course/11/problem/461/statistics">统计</a></p>
<ul>
<li> <a target="_blank" rel="noopener" href="http://oj.daimayuan.top/course/11/problem/461#tab-statement">描述</a></li>
<li> <a target="_blank" rel="noopener" href="http://oj.daimayuan.top/course/11/problem/461#tab-submit-answer">提交</a></li>
<li> <a target="_blank" rel="noopener" href="http://oj.daimayuan.top/course/11/problem/461#tab-custom-test">自定义测试</a></li>
</ul>
<p>你有n个任务，其中第i个任务，在si开始，ei时刻结束，如果做这个任务，你能获得wi的收益。</p>
<p>但是你在一个时刻只能做一个任务，问选择哪些任务，能让你的收益尽量大。</p>
<p>注意：你在上一个任务结束后马上开始下一个任务是可以的。</p>
<h3 id="输入格式-7"><a href="#输入格式-7" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行一个整数n。</p>
<p>接下来n行，每行三个整数si,ei,wi。</p>
<h3 id="输出格式-7"><a href="#输出格式-7" class="headerlink" title="输出格式"></a>输出格式</h3><p>一个数，表示答案。</p>
<h3 id="样例输入-3"><a href="#样例输入-3" class="headerlink" title="样例输入"></a>样例输入</h3><pre><code>3
1 3 100
2 4 199
3 5 100
</code></pre>
<h3 id="样例输出-3"><a href="#样例输出-3" class="headerlink" title="样例输出"></a>样例输出</h3><pre><code>200
</code></pre>
<h3 id="数据规模-3"><a href="#数据规模-3" class="headerlink" title="数据规模"></a>数据规模</h3><p>对于所有数据，保证1≤n≤103,1≤si&lt;ei≤103,1≤wi≤105。</p>
<p> 中文</p>
<h3 id="My-Code-6"><a href="#My-Code-6" class="headerlink" title="My Code:"></a>My Code:</h3><pre><code>#include&lt;iostream&gt;
using namespace std;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
#include&lt;set&gt;
#include&lt;string&gt;
#include&lt;stack&gt;

typedef long long ll;
typedef pair&lt;ll, ll&gt;PII;
const int N = 1010;
ll s[N], w[N], e[N];
PII f[N];

bool cmp(vector&lt;ll&gt;a, vector&lt;ll&gt;b)
&#123;
    if (a[0] != b[0])return a[0] &lt; b[0];
    else if (a[1] != b[1])return a[1] &lt; b[1];
    return a[2] &lt; b[2];
&#125;

int main()
&#123;
    int n, m;
    cin &gt;&gt; n;
    vector&lt;vector&lt;ll&gt;&gt;v(n, vector&lt;ll&gt;(3));
    for (int i = 0; i &lt; n; i++)
    &#123;
        cin &gt;&gt; v[i][0] &gt;&gt; v[i][1] &gt;&gt; v[i][2];
    &#125;
    sort(v.begin(), v.end(), cmp);
    f[0].first = v[0][1];
    f[0].second = v[0][2];
    ll res = f[0].second;
    for (int i = 1; i &lt; n; i++)
    &#123;
        ll ans = 0;
        f[i].first = v[i][1];
        f[i].second = v[i][2];
        for (int j = i - 1; j &gt;= 0; j--)
        &#123;
            if (v[i][0] &gt;= f[j].first)
            &#123;
                f[i].second = max(f[i].second, f[j].second + v[i][2]);
                
            &#125;
        &#125;
        res = max(res, f[i].second);
    &#125;
    cout &lt;&lt; res &lt;&lt; endl;
    
    return 0;
&#125;
</code></pre>
<p>Analyse：</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/03/21/first/" data-id="clfxsuq1c0004u4w1hkya482y" data-title="first" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-建栈链表" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/02/13/%E5%BB%BA%E6%A0%88%E9%93%BE%E8%A1%A8/" class="article-date">
  <time class="dt-published" datetime="2023-02-13T03:30:18.000Z" itemprop="datePublished">2023-02-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/02/13/%E5%BB%BA%E6%A0%88%E9%93%BE%E8%A1%A8/">建栈链表</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/02/13/%E5%BB%BA%E6%A0%88%E9%93%BE%E8%A1%A8/" data-id="clfxsuq1k000iu4w1fzn79v7s" data-title="建栈链表" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-双周赛Third" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/10/%E5%8F%8C%E5%91%A8%E8%B5%9BThird/" class="article-date">
  <time class="dt-published" datetime="2023-01-10T04:44:22.000Z" itemprop="datePublished">2023-01-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/01/10/%E5%8F%8C%E5%91%A8%E8%B5%9BThird/">双周赛Third</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <pre><code>title: 双周1
date: 2022-11-28 21:35:31
tags:
</code></pre>
<p>7-1 打字</p>
<p>全屏浏览题目</p>
<p>作者 neuqAcmClub</p>
<p>单位 东北大学秦皇岛分校</p>
<p>如果你仍然再用二指禅打字，那我建议你重新学习打字，这样你打字会更快，感觉更舒适和愉快。</p>
<p>有很多网站教授正确的打字。下图描述了基本原理: 用同一手指按压颜色相同的键。黄色键需要用小指按压，蓝色的用无名指，绿色的用中指，红色的用食指。</p>
<p><img src="https://images.ptausercontent.com/d74db112-b0a0-413f-9611-bdcabb6b6bd7.JPG" alt="打字.JPG"></p>
<p>另外，左手按键盘的左侧（从左侧的5、T、G、B键开始）右手按压右侧（从右侧的键6、Y、H、N开始）。拇指负责空格键。</p>
<p>图片描述的键盘是美式键盘。</p>
<p>现在，给出一段长度为 len(1≤len≤50) 的字符串，请你计算如果正确打出这个字符串，每个手指敲击键盘的次数。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>输入为一行，一个由大写字母、数字和特殊符号组成的字符串（不包括空格，不需要管图片中未显示的按键）。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>输出8行，表示左手小指、无名指、中指、食指以及右手食指、中指、无名指、小指敲击键盘的次数。</p>
<h3 id="输入样例1"><a href="#输入样例1" class="headerlink" title="输入样例1:"></a>输入样例1:</h3><pre><code>AON=BOO; 
</code></pre>
<h3 id="输出样例1"><a href="#输出样例1" class="headerlink" title="输出样例1:"></a>输出样例1:</h3><pre><code>1
0
0
1
1
0
3
2
</code></pre>
<h3 id="输入样例2"><a href="#输入样例2" class="headerlink" title="输入样例2:"></a>输入样例2:</h3><pre><code>PRINT&#39;NY&#39;[NASLA] 
</code></pre>
<h3 id="输出样例2"><a href="#输出样例2" class="headerlink" title="输出样例2:"></a>输出样例2:</h3><pre><code>2
1
0
2
4
1
1
5
</code></pre>
<p>代码长度限制</p>
<p>16 KB</p>
<p>时间限制</p>
<p>400 ms</p>
<p>内存限制</p>
<p>64 MB</p>
<p>Analyse：</p>
<p>先读入格子的状态</p>
<p>再遍历每一个格子检测其相邻格子中是否有有百合&#96;</p>
<ul>
<li><p>Code:</p>
<p>#include<iostream> using namespace std; int main(){</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;string.h&gt;
using namespace std;
int main()&#123;
    string x;
    cin&gt;&gt;x;
    int len=x.length();
    int a=0,b=0,c=0,d=0,e=0,f=0,g=0,h=0;
    for(int i=0;i&lt;len;i++)&#123;
        if(x[i]==&#39;1&#39;||x[i]==&#39;Q&#39;||x[i]==&#39;A&#39;||x[i]==&#39;Z&#39;)a++;
        else if(x[i]==&#39;2&#39;||x[i]==&#39;W&#39;||x[i]==&#39;S&#39;||x[i]==&#39;X&#39;)b++;
        else if(x[i]==&#39;3&#39;||x[i]==&#39;E&#39;||x[i]==&#39;D&#39;||x[i]==&#39;C&#39;)c++;
        else if(x[i]==&#39;5&#39;||x[i]==&#39;4&#39;||x[i]==&#39;T&#39;||x[i]==&#39;R&#39;||x[i]==&#39;F&#39;||x[i]==&#39;G&#39;||x[i]==&#39;V&#39;||x[i]==&#39;B&#39;)d++;
        else if(x[i]==&#39;7&#39;||x[i]==&#39;6&#39;||x[i]==&#39;Y&#39;||x[i]==&#39;U&#39;||x[i]==&#39;J&#39;||x[i]==&#39;H&#39;||x[i]==&#39;N&#39;||x[i]==&#39;M&#39;)e++;
        else if(x[i]==&#39;8&#39;||x[i]==&#39;I&#39;||x[i]==&#39;K&#39;||x[i]==&#39;,&#39;)f++;
        else if(x[i]==&#39;9&#39;||x[i]==&#39;O&#39;||x[i]==&#39;L&#39;||x[i]==&#39;.&#39;)g++;
        else if(x[i]==&#39;0&#39;||x[i]==&#39;-&#39;||x[i]==&#39;=&#39;||x[i]==&#39;P&#39;||x[i]==&#39;[&#39;||x[i]==&#39;]&#39;||x[i]==&#39;;&#39;||x[i]==&#39;\&#39;&#39;||x[i]==&#39;/&#39;)h++;

    &#125;
    cout&lt;&lt;a&lt;&lt;endl&lt;&lt;b&lt;&lt;endl&lt;&lt;c&lt;&lt;endl&lt;&lt;d&lt;&lt;endl&lt;&lt;e&lt;&lt;endl&lt;&lt;f&lt;&lt;endl&lt;&lt;g&lt;&lt;endl&lt;&lt;h;
    &#125;
</code></pre>
<p>}</p>
</li>
</ul>
<p>7-2 分香肠</p>
<p>全屏浏览题目</p>
<p>作者 neuqAcmClub</p>
<p>单位 东北大学秦皇岛分校</p>
<p>有 N 根完全相同的香肠， 现在要平均分给 M 个客人。 问最少需要切几刀才能将其平均分给客人（不能多个香肠一起切）。</p>
<h3 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>两个整数 N(1≤N≤105) 和 M(1≤M≤105)</p>
<h3 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>一个整数，表示要切的刀数</p>
<h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><p>在这里给出一组输入。例如：</p>
<pre><code>2 6
</code></pre>
<h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><p>在这里给出相应的输出。例如：</p>
<pre><code>4
</code></pre>
<p>代码长度限制</p>
<p>16 KB</p>
<p>时间限制</p>
<p>400 ms</p>
<p>内存限制</p>
<p>64 MB</p>
<p>C (gcc)</p>
<p>1</p>
<p>​</p>
<h3 id="Analyse："><a href="#Analyse：" class="headerlink" title="Analyse："></a>Analyse：</h3><p>存储每个位置的数字时,我们要注意字母与数字的转化.同样,在输出时也要注意输出数字若大于等于10,就要转化成字母.</p>
<h3 id="My-Code"><a href="#My-Code" class="headerlink" title="My Code:"></a>My Code:</h3><ul>
<li>}a[N];</li>
</ul>
<h3 id="My-Code-1"><a href="#My-Code-1" class="headerlink" title="My Code:"></a>My Code:</h3><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
int main()
&#123;
    int n,m;
    cin &gt;&gt; n &gt;&gt; m;
    cout &lt;&lt; m-__gcd(m,n);
    return 0;
&#125;
</code></pre>
<p>7-3 h0145. 会议安排</p>
<p>全屏浏览题目</p>
<p>作者 黄正鹏</p>
<p>单位 贵州工程应用技术学院</p>
<p>学校的礼堂每天都会有许多活动，有时间这些活动的计划时间会发生冲突，需要选择出一些活动进行举办。小刘的工作就是安排学校礼堂的活动，每个时间最多安排一个活动。现在小刘有一些活动计划的时间表，他想尽可能的安排更多的活动，请问他该如何安排。</p>
<h3 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>第一行是一个整型数m(m&lt;100)表示共有m组测试数据。<br>每组测试数据的第一行是一个整数n(1&lt;n&lt;10000)表示该测试数据共有n个活动。<br>随后的n行，每行有两个正整数Bi,Ei(0&lt;&#x3D;Bi,Ei&lt;10000),分别表示第i个活动的起始与结束时间（Bi&lt;&#x3D;Ei)</p>
<h3 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>对于每一组输入，输出最多能够安排的活动数量。<br>每组的输出占一行</p>
<h3 id="输入样例-1"><a href="#输入样例-1" class="headerlink" title="输入样例:"></a>输入样例:</h3><p>在这里给出一组输入。例如：</p>
<pre><code>2
2
1 10
10 11
3
1 10
9 11
11 20
</code></pre>
<h3 id="输出样例-1"><a href="#输出样例-1" class="headerlink" title="输出样例:"></a>输出样例:</h3><p>在这里给出相应的输出。例如：</p>
<pre><code>2
2
</code></pre>
<p>代码长度限制</p>
<p>16 KB</p>
<p>时间限制</p>
<p>400 ms</p>
<p>内存限制</p>
<p>64 MB</p>
<h3 id="My-Code-2"><a href="#My-Code-2" class="headerlink" title="My Code:"></a>My Code:</h3><pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
struct Meet&#123;
    int bi,ei;
&#125;;
bool cmp(Meet a,Meet b)
&#123;
    return a.ei &lt;b.ei ;
&#125;
int main()
&#123;
    int m;
    cin&gt;&gt;m;
    while(m--)
    &#123;
        int n,ans=1;
        Meet meet[100005];
        cin&gt;&gt;n;
        for(int i=1;i&lt;=n;i++)
        cin&gt;&gt;meet[i].bi&gt;&gt;meet[i].ei;
        sort(meet+1,meet+n+1,cmp);
        int last=meet[1].ei;
        for(int i=2;i&lt;=n;i++)
        &#123;
            if(meet[i].bi &gt;=last)
            &#123;
                ans++;
                last=meet[i].ei;
            &#125;
        &#125;
        cout&lt;&lt;ans&lt;&lt;endl;
    &#125;
    return 0;
&#125;
</code></pre>
<p>7-4 神秘密码</p>
<p>全屏浏览题目</p>
<p>作者 neuqAcmClub</p>
<p>单位 东北大学秦皇岛分校</p>
<p>传说二战时X国收到了上帝的一串密码，只有解开密码，才能阻止战争的继续进行，世界才会恢复和平。解开密码的第一道工序就是解压缩密码，上帝对于连续的若干个相同的子串”X”会压缩为”[DX]”的形式(D是一个整数且1&lt;&#x3D;D&lt;&#x3D;99),比如说字符串”CBCBCBCB”就压缩为”[4CB]”或者”[2[2CB]]”,类似于后面这种压缩之后再压缩的称为二重压缩。如果是”[2[2[2CB]]]”则是三重的。现在我们给你上帝发送的密码，请你对其进行解压缩。</p>
<h3 id="输入格式-3"><a href="#输入格式-3" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>一个字符串。</p>
<h3 id="输出格式-3"><a href="#输出格式-3" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>一个字符串。</p>
<h3 id="输入样例-2"><a href="#输入样例-2" class="headerlink" title="输入样例:"></a>输入样例:</h3><p>在这里给出一组输入。例如：</p>
<pre><code>AC[3FUN]
</code></pre>
<h3 id="输出样例-2"><a href="#输出样例-2" class="headerlink" title="输出样例:"></a>输出样例:</h3><p>在这里给出相应的输出。例如：</p>
<pre><code>ACFUNFUNFUN
</code></pre>
<p>【数据范围】</p>
<p>解压后的字符串长度在 20000 以内，最多只有十重压缩。保证只包含数字、大写字母、<code>[</code> 和 <code>]</code>。</p>
<p>代码长度限制</p>
<p>16 KB</p>
<p>时间限制</p>
<p>400 ms</p>
<p>内存限制</p>
<p>64 MB</p>
<p>Analyse：</p>
<p>就是用一个<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84&spm=1001.2101.3001.7020">二维数组</a>存储第i个柜子和第j个格子。个人认为用二维数组过于浪费空间，所以用STL中的map来存储。</p>
<ul>
<li><h3 id="My-Code-3"><a href="#My-Code-3" class="headerlink" title="My Code:"></a>My Code:</h3><p>#include&lt;bits&#x2F;stdc++.h&gt; using namespace std; map&lt;int,int&gt;a1[100001]; int n,q; int main() {</p>
<pre><code>#include &lt;iostream&gt;
using namespace std;
string str()
&#123;
    string ans;
    string temp;
    int k;
    char c;
    while(cin &gt;&gt; c)
    &#123;
        if(c==&#39;[&#39;)
        &#123;
            cin &gt;&gt; k;
            temp = str();
            for(int i = 1;i&lt;=k;i++) ans+=temp;
        &#125;
        else if(c==&#39;]&#39;)
        &#123;
            return ans;
        &#125;
        else
        &#123;
            ans+=c;
        &#125;
    &#125;
    return ans;
&#125;
int main()
&#123;
    cout &lt;&lt; str();
    return 0;
&#125;
</code></pre>
<p>}</p>
</li>
</ul>
<p>7-5 h0114.国王游戏</p>
<p>全屏浏览题目</p>
<p>作者 黄正鹏</p>
<p>单位 贵州工程应用技术学院</p>
<p>恰逢 H 国国庆，国王邀请 n 位大臣来玩一个有奖游戏。<br>首先，他让每个大臣在左、右手上面分别写下一个整数，国王自己也在左、右手上各写一个整数。<br>然后，让这 n 位大臣排成一排，国王站在队伍的最前面。<br>排好队后，所有的大臣都会获得国王奖赏的若干金币，每位大臣获得的金币数分别是:<br>排在该大臣前面的所有人的左手上的数的乘积除以他自己右手上的数，然后向下取整得到的结果。<br>国王不希望某一个大臣获得特别多的奖赏，所以他想请你帮他重新安排一下队伍的顺序，使得获得奖赏最多的大臣，所获奖赏尽可能的少。<br>注意，国王的位置始终在队伍的最前面。</p>
<h3 id="输入格式-4"><a href="#输入格式-4" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>第一行包含一个整数 n(1≤n≤1000)，表示大臣的人数。<br>第二行包含两个整数 a (0&lt;a)和 b(b&lt;10000)，之间用一个空格隔开，分别表示国王左手和右手上的整数。<br>接下来 n 行，每行包含两个整数 a 和 b，之间用一个空格隔开，分别表示每个大臣左手和右手上的整数。</p>
<h3 id="输出格式-4"><a href="#输出格式-4" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>输出只有一行，包含一个整数，表示重新排列后的队伍中获奖赏最多的大臣所获得的金币数。</p>
<h3 id="输入样例-3"><a href="#输入样例-3" class="headerlink" title="输入样例:"></a>输入样例:</h3><p>在这里给出一组输入。例如：</p>
<pre><code>3
1 1
2 3
7 4
4 6
</code></pre>
<h3 id="输出样例-3"><a href="#输出样例-3" class="headerlink" title="输出样例:"></a>输出样例:</h3><p>在这里给出相应的输出。例如：</p>
<pre><code>2
</code></pre>
<p>代码长度限制</p>
<p>16 KB</p>
<p>时间限制</p>
<p>400 ms</p>
<p>内存限制</p>
<p>64 MB</p>
<h3 id="分析：必定在p和q的区间里有极大值点a和极小值点b-则方程的解也就是在-p-min-a-b-min-a-b-max-a-b-max-a-b-q-这三个区间内"><a href="#分析：必定在p和q的区间里有极大值点a和极小值点b-则方程的解也就是在-p-min-a-b-min-a-b-max-a-b-max-a-b-q-这三个区间内" class="headerlink" title="分析：必定在p和q的区间里有极大值点a和极小值点b, 则方程的解也就是在(p,min{a,b})(min{a,b},max{a,b})(max{a,b},q)这三个区间内,"></a>分析：必定在p和q的区间里有极大值点a和极小值点b, 则方程的解也就是在(p,min{a,b})(min{a,b},max{a,b})(max{a,b},q)这三个区间内,</h3><h3 id="My-Code-4"><a href="#My-Code-4" class="headerlink" title="My Code:"></a>My Code:</h3><pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
struct people&#123;
    int l;
    int r;
    int ans;  //ans为左右手数字的乘积
&#125;arr[1005];   //用arr存放每位大臣的信息
bool cmp(const people &amp;p1,const people &amp;p2)&#123;
    return p1.ans&lt;p2.ans;  //让每位大臣按照每位大臣的左右手乘积从小到大排序
&#125;
int numarr[10010],len_num2=1,ans[10010],len_ans=1,numshuzu[10010],finalans[10010];
string money[1005];
int turn(int len)&#123;   //模拟进位
    for(int i=0;i&lt;len;i++)&#123;
        if(numshuzu[i]&gt;=10)&#123;
            numshuzu[i+1]+=numshuzu[i]/10;
            numshuzu[i]%=10;
        &#125;
        if(numshuzu[len]&gt;0)&#123;
            len++;
        &#125;
    &#125;
    return len;
&#125;
string chu(int len,int chushu)&#123;  //高精度除法
    int a=0,len_finalans=0;
    string ans1;
    for(int i=0;i&lt;len;i++)&#123;
        a=a*10+ans[i];
        if(a&gt;=chushu)&#123;
            finalans[len_finalans++]=a/chushu;
            ans1+=to_string(a/chushu);
            a%=chushu;
        &#125;
        else if(a&lt;chushu&amp;&amp;len_finalans&gt;0)&#123;
            ans1+=&quot;0&quot;;
        &#125;
    &#125;
    return ans1;  
&#125;
void cheng(int num,int chushu)&#123;   
    memset(numshuzu,0,sizeof(numshuzu));
    string a=to_string(num);
    int len_num1=a.length(),len_zong=0;
    for(int i=0;i&lt;len_num1;i++)&#123;
        numarr[i]=a[i]-&#39;0&#39;;
    &#125;
    for(int i=len_ans-1;i&gt;=0;i--)&#123;			
        len_zong=len_ans-1-i;	
        for(int a=len_num1-1;a&gt;=0;a--)&#123;
            numshuzu[len_zong++]+=ans[i]*numarr[a];
        &#125;		
    &#125;
    len_ans=turn(len_zong);
    for(int i=len_ans-1;i&gt;=0;i--)&#123;
        ans[len_ans-1-i]=numshuzu[i];
    &#125;
&#125;
int main()&#123;
    long long num,l,r,sum=1;
    ans[0]=1;
    cin&gt;&gt;num&gt;&gt;l&gt;&gt;r;
    arr[0].l=l;
    arr[0].r=r;
    for(int i=1;i&lt;=num;i++)&#123;
        cin&gt;&gt;arr[i].l&gt;&gt;arr[i].r;
        arr[i].ans=arr[i].l*arr[i].r;  
    &#125;
    sort(arr+1,arr+num+1,cmp); 
    for(int i=1;i&lt;=num;i++)&#123;
        cheng(arr[i-1].l,arr[i].r);   
    &#125;
    if(chu(len_ans,arr[num].r)==&quot;&quot;)&#123;  
        cout&lt;&lt;&quot;1&quot;&lt;&lt;endl;
    &#125;
    else&#123;
        cout&lt;&lt;chu(len_ans,arr[num].r);  
    &#125;
    return 0;
&#125;
</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/01/10/%E5%8F%8C%E5%91%A8%E8%B5%9BThird/" data-id="clfxsuq1j000gu4w1f3fxatev" data-title="双周赛Third" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-0x3f3f3f3f" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/10/0x3f3f3f3f/" class="article-date">
  <time class="dt-published" datetime="2023-01-10T04:28:40.000Z" itemprop="datePublished">2023-01-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/01/10/0x3f3f3f3f/">1061109567</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>ACM中常用的无穷大常量——0x3f3f3f3f<br>最近做题看题解的时候发现在大佬的题解报告中常会出现这么一行：↓↓↓</p>
<p>const int inf &#x3D; 0x3f3f3f3f;<br>然后我就去探索了一下，0x3f3f3f3f的十进制是1061109567，是10^9级别的，而一般场合下的数据都是小于10^9的，所以它可以作为无穷大使用而不致出现数据大于无穷大的情形。 </p>
<p>一般dfs或者dp求最小值的问题中间会出现一些不存在的情况，我一般会采用一种方法就是返回一个很大的值，这样去最小的时候就不会取到这种情况了（不知道是不是专业做法），我一般在取这个“很大的值”的时候会选一个答案不可能的值，比如bfs求最短路一共是一个10000层的树，就取一个10005。</p>
<p>而宏定义一个0x3f3f3f3f可以减少考虑的时间，一般情况下就可以当作是一个无穷大的数去用。</p>
<p>引用一段别人的博客中的介绍：</p>
<p>0x3f3f3f3f是一个很有用的数值，它是满足以下两个条件的最大整数。</p>
<p>1、整数的两倍不超过 0x7f7f7f7f，即int能表示的最大正整数。</p>
<p>2、整数的每8位（每个字节）都是相同的。</p>
<p>我们在程序设计中经常需要使用 memset(a, val, sizeof a) 初始化一个数组a，该语句把数值 val（0x00~0xFF）填充到数组a 的每个字节上，所以用memset只能赋值出“每8位都相同”的 int。</p>
<p>当需要把一个数组中的数值初始化成正无穷时，为了避免加法算术上溢出或者繁琐的判断，我们经常用 memset(a, 0x3f, sizeof(a)) 给数组赋 0x3f3f3f3f的值来代替。<br>————————————————<br>版权声明：本文为CSDN博主「我对算法一无所知」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_31267769/article/details/88890612">https://blog.csdn.net/qq_31267769/article/details/88890612</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/01/10/0x3f3f3f3f/" data-id="clfxsuq190001u4w110l7gjti" data-title="1061109567" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/05/">May 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/04/">April 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/03/">March 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/02/">February 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/01/">January 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/12/">December 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/11/">November 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/05/13/week17/">week17</a>
          </li>
        
          <li>
            <a href="/2023/05/13/week16/">week16</a>
          </li>
        
          <li>
            <a href="/2023/05/13/week15/">week15</a>
          </li>
        
          <li>
            <a href="/2023/04/01/%E5%8F%8C%E5%91%A8%E8%B5%9B%E4%B8%80/">双周赛一</a>
          </li>
        
          <li>
            <a href="/2023/04/01/%E7%AC%AC%E4%B8%89%E5%91%A8/">第三周</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>